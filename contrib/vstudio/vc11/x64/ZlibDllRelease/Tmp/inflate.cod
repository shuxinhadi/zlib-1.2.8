; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
	ORG $+10
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	inflateMark
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateInit2_
PUBLIC	inflateReset
PUBLIC	inflate
PUBLIC	inflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN15
	DD	imagerel $LN15+73
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateCopy DD imagerel $LN15+73
	DD	imagerel $LN15+113
	DD	imagerel $chain$1$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN15+113
	DD	imagerel $LN15+172
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN15+172
	DD	imagerel $LN15+190
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN15+190
	DD	imagerel $LN15+557
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN15+557
	DD	imagerel $LN15+570
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN17
	DD	imagerel $LN17+66
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateSync DD imagerel $LN17+66
	DD	imagerel $LN17+225
	DD	imagerel $chain$1$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateSync DD imagerel $LN17+225
	DD	imagerel $LN17+252
	DD	imagerel $chain$3$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN17+252
	DD	imagerel $LN17+268
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+104
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN11
	DD	imagerel $LN11+165
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN8
	DD	imagerel $LN8+138
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+78
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$updatewindow DD imagerel updatewindow+78
	DD	imagerel updatewindow+233
	DD	imagerel $chain$0$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$updatewindow DD imagerel updatewindow+233
	DD	imagerel updatewindow+254
	DD	imagerel $chain$1$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateReset2 DD imagerel $LN14+34
	DD	imagerel $LN14+102
	DD	imagerel $chain$0$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateReset2 DD imagerel $LN14+102
	DD	imagerel $LN14+147
	DD	imagerel $chain$2$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateReset2 DD imagerel $LN14+147
	DD	imagerel $LN14+168
	DD	imagerel $chain$3$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN13+63
	DD	imagerel $LN13+167
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN13+167
	DD	imagerel $LN13+209
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN13+209
	DD	imagerel $LN13+225
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN935
	DD	imagerel $LN935+80
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate DD imagerel $LN935+80
	DD	imagerel $LN935+5494
	DD	imagerel $chain$4$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflate DD imagerel $LN935+5494
	DD	imagerel $LN935+5860
	DD	imagerel $chain$6$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflate DD imagerel $LN935+5860
	DD	imagerel $LN935+6004
	DD	imagerel $chain$7$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN7
	DD	imagerel $LN7+86
	DD	imagerel $unwind$inflateEnd
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflate DD 021H
	DD	imagerel $LN935
	DD	imagerel $LN935+80
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflate DD 0a0021H
	DD	0bf400H
	DD	0ce400H
	DD	0dd400H
	DD	0e6400H
	DD	0f3400H
	DD	imagerel $LN935
	DD	imagerel $LN935+80
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate DD 0a1921H
	DD	0bf419H
	DD	0ce414H
	DD	0dd40fH
	DD	0e640aH
	DD	0f3405H
	DD	imagerel $LN935
	DD	imagerel $LN935+80
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 041701H
	DD	0c00df217H
	DD	0500a700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateReset2 DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateReset2 DD 020021H
	DD	066400H
	DD	imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateReset2 DD 020521H
	DD	066405H
	DD	imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$updatewindow DD 021H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+78
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$updatewindow DD 020521H
	DD	06e405H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+78
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateSync DD 040021H
	DD	085400H
	DD	073400H
	DD	imagerel $LN17
	DD	imagerel $LN17+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateSync DD 040a21H
	DD	08540aH
	DD	073405H
	DD	imagerel $LN17
	DD	imagerel $LN17+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+73
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 060021H
	DD	0af400H
	DD	09e400H
	DD	086400H
	DD	imagerel $LN15
	DD	imagerel $LN15+73
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 021H
	DD	imagerel $LN15+73
	DD	imagerel $LN15+113
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 020521H
	DD	09e405H
	DD	imagerel $LN15+73
	DD	imagerel $LN15+113
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateCopy DD 040a21H
	DD	0af40aH
	DD	086405H
	DD	imagerel $LN15
	DD	imagerel $LN15+73
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 040801H
	DD	070043208H
	DD	030025003H
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1256 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1257 :     struct inflate_state FAR *state;
; 1258 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3d		 je	 SHORT $LN2@inflateEnd
  0000e	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00012	48 85 c0	 test	 rax, rax
  00015	74 34		 je	 SHORT $LN2@inflateEnd
  00017	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 2b		 je	 SHORT $LN2@inflateEnd

; 1260 :     state = (struct inflate_state FAR *)strm->state;
; 1261 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00020	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00024	48 85 d2	 test	 rdx, rdx
  00027	74 07		 je	 SHORT $LN1@inflateEnd
  00029	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002d	41 ff d0	 call	 r8
$LN1@inflateEnd:

; 1262 :     ZFREE(strm, strm->state);

  00030	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00034	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00038	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1263 :     strm->state = Z_NULL;

  0003b	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1264 :     Tracev((stderr, "inflate: end\n"));
; 1265 :     return Z_OK;

  00043	33 c0		 xor	 eax, eax

; 1266 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN2@inflateEnd:

; 1259 :         return Z_STREAM_ERROR;

  0004b	b8 fe ff ff ff	 mov	 eax, -2

; 1266 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
hbuf$ = 48
out$1$ = 52
last$ = 56
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 160
flush$ = 168
ret$1$ = 176
left$1$ = 184
inflate	PROC						; COMDAT

; 608  : {

$LN935:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8b f9	 mov	 rdi, rcx

; 609  :     struct inflate_state FAR *state;
; 610  :     z_const unsigned char FAR *next;    /* next input */
; 611  :     unsigned char FAR *put;     /* next output */
; 612  :     unsigned have, left;        /* available input and output */
; 613  :     unsigned long hold;         /* bit buffer */
; 614  :     unsigned bits;              /* bits in bit buffer */
; 615  :     unsigned in, out;           /* save starting available input and output */
; 616  :     unsigned copy;              /* number of stored or match bytes to copy */
; 617  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 618  :     code here;                  /* current decoding table entry */
; 619  :     code last;                  /* parent table entry */
; 620  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 621  :     int ret;                    /* return code */
; 622  : #ifdef GUNZIP
; 623  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 624  : #endif
; 625  :     static const unsigned short order[19] = /* permutation of code lengths */
; 626  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 627  : 
; 628  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 629  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	0f 84 c1 16 00
	00		 je	 $LN498@inflate
  00023	4c 8b 61 28	 mov	 r12, QWORD PTR [rcx+40]
  00027	4d 85 e4	 test	 r12, r12
  0002a	0f 84 b4 16 00
	00		 je	 $LN498@inflate
  00030	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  00035	0f 84 a9 16 00
	00		 je	 $LN498@inflate
  0003b	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0003f	75 0a		 jne	 SHORT $LN499@inflate
  00041	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00045	0f 85 99 16 00
	00		 jne	 $LN498@inflate
$LN499@inflate:

; 631  : 
; 632  :     state = (struct inflate_state FAR *)strm->state;
; 633  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  0004b	41 83 3c 24 0b	 cmp	 DWORD PTR [r12], 11
  00050	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  00055	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0005a	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  0005f	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00064	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15
  00069	75 08		 jne	 SHORT $LN496@inflate
  0006b	41 c7 04 24 0c
	00 00 00	 mov	 DWORD PTR [r12], 12
$LN496@inflate:

; 634  :     LOAD();

  00073	44 8b 59 18	 mov	 r11d, DWORD PTR [rcx+24]

; 635  :     in = have;
; 636  :     out = left;
; 637  :     ret = Z_OK;
; 638  :     for (;;)
; 639  :         switch (state->mode) {

  00077	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  0007b	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0007f	8b 71 08	 mov	 esi, DWORD PTR [rcx+8]
  00082	4c 8b 31	 mov	 r14, QWORD PTR [rcx]
  00085	45 8b 7c 24 40	 mov	 r15d, DWORD PTR [r12+64]
  0008a	41 8b 5c 24 44	 mov	 ebx, DWORD PTR [r12+68]
  0008f	45 33 ed	 xor	 r13d, r13d
  00092	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00096	44 89 5d 38	 mov	 DWORD PTR left$1$[rbp-128], r11d
  0009a	89 75 bc	 mov	 DWORD PTR in$1$[rbp-128], esi
  0009d	45 8b d3	 mov	 r10d, r11d
  000a0	44 89 5d b4	 mov	 DWORD PTR out$1$[rbp-128], r11d
  000a4	44 89 6d 30	 mov	 DWORD PTR ret$1$[rbp-128], r13d
  000a8	83 f8 1e	 cmp	 eax, 30
  000ab	0f 87 29 16 00
	00		 ja	 $LN12@inflate
$LN929@inflate:
  000b1	48 98		 cdqe
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  000ba	49 8d 54 24 6c	 lea	 rdx, QWORD PTR [r12+108]
  000bf	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN793@inflate[rcx+rax*4]
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000cd	4d 8d 44 24 68	 lea	 r8, QWORD PTR [r12+104]
  000d2	48 03 c8	 add	 rcx, rax
  000d5	ff e1		 jmp	 rcx
$LN489@inflate:

; 640  :         case HEAD:
; 641  :             if (state->wrap == 0) {

  000d7	41 8b 54 24 08	 mov	 edx, DWORD PTR [r12+8]
  000dc	85 d2		 test	 edx, edx
  000de	75 0d		 jne	 SHORT $LN487@inflate

; 642  :                 state->mode = TYPEDO;

  000e0	41 c7 04 24 0c
	00 00 00	 mov	 DWORD PTR [r12], 12

; 643  :                 break;

  000e8	e9 42 06 00 00	 jmp	 $LN490@inflate
$LN487@inflate:

; 644  :             }
; 645  :             NEEDBITS(16);

  000ed	83 fb 10	 cmp	 ebx, 16
  000f0	73 20		 jae	 SHORT $LN486@inflate
$LL484@inflate:
  000f2	85 f6		 test	 esi, esi
  000f4	0f 84 a9 14 00
	00		 je	 $LN885@inflate
  000fa	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  000fe	8b cb		 mov	 ecx, ebx
  00100	83 c3 08	 add	 ebx, 8
  00103	d3 e0		 shl	 eax, cl
  00105	ff ce		 dec	 esi
  00107	49 ff c6	 inc	 r14
  0010a	44 03 f8	 add	 r15d, eax
  0010d	83 fb 10	 cmp	 ebx, 16
  00110	72 e0		 jb	 SHORT $LL484@inflate
$LN486@inflate:

; 646  : #ifdef GUNZIP
; 647  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00112	f6 c2 02	 test	 dl, 2
  00115	74 48		 je	 SHORT $LN478@inflate
  00117	41 81 ff 1f 8b
	00 00		 cmp	 r15d, 35615		; 00008b1fH
  0011e	75 3f		 jne	 SHORT $LN478@inflate

; 648  :                 state->check = crc32(0L, Z_NULL, 0);

  00120	45 33 c0	 xor	 r8d, r8d
  00123	33 d2		 xor	 edx, edx
  00125	33 c9		 xor	 ecx, ecx
  00127	e8 00 00 00 00	 call	 crc32

; 649  :                 CRC2(state->check, hold);

  0012c	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00130	41 b8 02 00 00
	00		 mov	 r8d, 2
  00136	8b c8		 mov	 ecx, eax
  00138	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  0013d	66 44 89 7d b0	 mov	 WORD PTR hbuf$[rbp-128], r15w
  00142	e8 00 00 00 00	 call	 crc32

; 650  :                 INITBITS();

  00147	45 8b fd	 mov	 r15d, r13d
  0014a	41 8b dd	 mov	 ebx, r13d
  0014d	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax

; 651  :                 state->mode = FLAGS;

  00152	41 c7 04 24 01
	00 00 00	 mov	 DWORD PTR [r12], 1

; 652  :                 break;

  0015a	e9 c8 05 00 00	 jmp	 $LN926@inflate
$LN478@inflate:

; 653  :             }
; 654  :             state->flags = 0;           /* expect zlib header */
; 655  :             if (state->head != Z_NULL)

  0015f	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00164	45 89 6c 24 10	 mov	 DWORD PTR [r12+16], r13d
  00169	48 85 c0	 test	 rax, rax
  0016c	74 07		 je	 SHORT $LN471@inflate

; 656  :                 state->head->done = -1;

  0016e	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN471@inflate:

; 657  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 658  : #else
; 659  :             if (
; 660  : #endif
; 661  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  00175	41 f6 44 24 08
	01		 test	 BYTE PTR [r12+8], 1
  0017b	0f 84 c5 00 00
	00		 je	 $LN469@inflate
  00181	41 0f b6 cf	 movzx	 ecx, r15b
  00185	41 8b c7	 mov	 eax, r15d
  00188	c1 e8 08	 shr	 eax, 8
  0018b	c1 e1 08	 shl	 ecx, 8
  0018e	03 c8		 add	 ecx, eax
  00190	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  00195	f7 e1		 mul	 ecx
  00197	8b c1		 mov	 eax, ecx
  00199	2b c2		 sub	 eax, edx
  0019b	d1 e8		 shr	 eax, 1
  0019d	03 c2		 add	 eax, edx
  0019f	c1 e8 04	 shr	 eax, 4
  001a2	6b c0 1f	 imul	 eax, eax, 31
  001a5	3b c8		 cmp	 ecx, eax
  001a7	0f 85 99 00 00
	00		 jne	 $LN469@inflate

; 665  :             }
; 666  :             if (BITS(4) != Z_DEFLATED) {

  001ad	41 8b c7	 mov	 eax, r15d
  001b0	24 0f		 and	 al, 15
  001b2	3c 08		 cmp	 al, 8
  001b4	74 18		 je	 SHORT $LN467@inflate
$LN927@inflate:

; 667  :                 strm->msg = (char *)"unknown compression method";

  001b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  001bd	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 668  :                 state->mode = BAD;

  001c1	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 669  :                 break;

  001c9	e9 61 05 00 00	 jmp	 $LN490@inflate
$LN467@inflate:

; 670  :             }
; 671  :             DROPBITS(4);
; 672  :             len = BITS(4) + 8;
; 673  :             if (state->wbits == 0)

  001ce	41 8b 44 24 28	 mov	 eax, DWORD PTR [r12+40]
  001d3	41 c1 ef 04	 shr	 r15d, 4
  001d7	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001da	41 8b cf	 mov	 ecx, r15d
  001dd	83 e1 0f	 and	 ecx, 15
  001e0	83 c1 08	 add	 ecx, 8
  001e3	85 c0		 test	 eax, eax
  001e5	75 43		 jne	 SHORT $LN464@inflate

; 674  :                 state->wbits = len;

  001e7	41 89 4c 24 28	 mov	 DWORD PTR [r12+40], ecx
$LN462@inflate:

; 679  :             }
; 680  :             state->dmax = 1U << len;

  001ec	b8 01 00 00 00	 mov	 eax, 1

; 681  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 682  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001f1	45 33 c0	 xor	 r8d, r8d
  001f4	33 d2		 xor	 edx, edx
  001f6	d3 e0		 shl	 eax, cl
  001f8	33 c9		 xor	 ecx, ecx
  001fa	41 89 44 24 14	 mov	 DWORD PTR [r12+20], eax
  001ff	e8 00 00 00 00	 call	 adler32

; 683  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00204	41 c1 ef 08	 shr	 r15d, 8
  00208	41 f7 d7	 not	 r15d
  0020b	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  00210	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
  00213	41 83 e7 02	 and	 r15d, 2

; 684  :             INITBITS();

  00217	41 8b dd	 mov	 ebx, r13d
  0021a	41 83 cf 09	 or	 r15d, 9
  0021e	45 89 3c 24	 mov	 DWORD PTR [r12], r15d
  00222	45 8b fd	 mov	 r15d, r13d

; 685  :             break;

  00225	e9 fd 04 00 00	 jmp	 $LN926@inflate
$LN464@inflate:

; 675  :             else if (len > state->wbits) {

  0022a	3b c8		 cmp	 ecx, eax
  0022c	76 be		 jbe	 SHORT $LN462@inflate

; 676  :                 strm->msg = (char *)"invalid window size";

  0022e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  00235	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 677  :                 state->mode = BAD;

  00239	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 678  :                 break;

  00241	e9 e9 04 00 00	 jmp	 $LN490@inflate
$LN469@inflate:

; 662  :                 strm->msg = (char *)"incorrect header check";

  00246	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  0024d	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 663  :                 state->mode = BAD;

  00251	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 664  :                 break;

  00259	e9 d1 04 00 00	 jmp	 $LN490@inflate
$LN457@inflate:

; 686  : #ifdef GUNZIP
; 687  :         case FLAGS:
; 688  :             NEEDBITS(16);

  0025e	83 fb 10	 cmp	 ebx, 16
  00261	73 20		 jae	 SHORT $LN456@inflate
$LL454@inflate:
  00263	85 f6		 test	 esi, esi
  00265	0f 84 2f 13 00
	00		 je	 $LN884@inflate
  0026b	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0026f	8b cb		 mov	 ecx, ebx
  00271	83 c3 08	 add	 ebx, 8
  00274	d3 e0		 shl	 eax, cl
  00276	ff ce		 dec	 esi
  00278	49 ff c6	 inc	 r14
  0027b	44 03 f8	 add	 r15d, eax
  0027e	83 fb 10	 cmp	 ebx, 16
  00281	72 e0		 jb	 SHORT $LL454@inflate
$LN456@inflate:

; 689  :             state->flags = (int)(hold);

  00283	45 89 7c 24 10	 mov	 DWORD PTR [r12+16], r15d

; 690  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00288	41 80 ff 08	 cmp	 r15b, 8
  0028c	0f 85 24 ff ff
	ff		 jne	 $LN927@inflate

; 691  :                 strm->msg = (char *)"unknown compression method";
; 692  :                 state->mode = BAD;
; 693  :                 break;
; 694  :             }
; 695  :             if (state->flags & 0xe000) {

  00292	41 f7 c7 00 e0
	00 00		 test	 r15d, 57344		; 0000e000H
  00299	74 18		 je	 SHORT $LN447@inflate

; 696  :                 strm->msg = (char *)"unknown header flags set";

  0029b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  002a2	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  002a6	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  002ae	e9 7c 04 00 00	 jmp	 $LN490@inflate
$LN447@inflate:

; 697  :                 state->mode = BAD;
; 698  :                 break;
; 699  :             }
; 700  :             if (state->head != Z_NULL)

  002b3	49 8b 4c 24 20	 mov	 rcx, QWORD PTR [r12+32]
  002b8	48 85 c9	 test	 rcx, rcx
  002bb	74 0b		 je	 SHORT $LN446@inflate

; 701  :                 state->head->text = (int)((hold >> 8) & 1);

  002bd	41 8b c7	 mov	 eax, r15d
  002c0	c1 e8 08	 shr	 eax, 8
  002c3	83 e0 01	 and	 eax, 1
  002c6	89 01		 mov	 DWORD PTR [rcx], eax
$LN446@inflate:

; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  002c8	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  002d1	74 25		 je	 SHORT $LN442@inflate
  002d3	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  002d8	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  002dc	41 c1 ef 08	 shr	 r15d, 8
  002e0	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  002e4	41 b8 02 00 00
	00		 mov	 r8d, 2
  002ea	44 88 7d b1	 mov	 BYTE PTR hbuf$[rbp-127], r15b
  002ee	e8 00 00 00 00	 call	 crc32
  002f3	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN442@inflate:

; 703  :             INITBITS();

  002f8	45 8b fd	 mov	 r15d, r13d
  002fb	41 8b dd	 mov	 ebx, r13d

; 704  :             state->mode = TIME;

  002fe	41 c7 04 24 02
	00 00 00	 mov	 DWORD PTR [r12], 2

; 705  :         case TIME:
; 706  :             NEEDBITS(32);

  00306	eb 08		 jmp	 SHORT $LL434@inflate
$LN437@inflate:
  00308	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0030b	73 23		 jae	 SHORT $LN436@inflate
  0030d	0f 1f 00	 npad	 3
$LL434@inflate:
  00310	85 f6		 test	 esi, esi
  00312	0f 84 8b 12 00
	00		 je	 $LN885@inflate
  00318	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0031c	8b cb		 mov	 ecx, ebx
  0031e	83 c3 08	 add	 ebx, 8
  00321	d3 e0		 shl	 eax, cl
  00323	ff ce		 dec	 esi
  00325	49 ff c6	 inc	 r14
  00328	44 03 f8	 add	 r15d, eax
  0032b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0032e	72 e0		 jb	 SHORT $LL434@inflate
$LN436@inflate:

; 707  :             if (state->head != Z_NULL)

  00330	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00335	48 85 c0	 test	 rax, rax
  00338	74 04		 je	 SHORT $LN428@inflate

; 708  :                 state->head->time = hold;

  0033a	44 89 78 04	 mov	 DWORD PTR [rax+4], r15d
$LN428@inflate:

; 709  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0033e	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  00347	74 37		 je	 SHORT $LN424@inflate
  00349	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  0034e	41 8b c7	 mov	 eax, r15d
  00351	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  00355	c1 e8 08	 shr	 eax, 8
  00358	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  0035c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00362	88 45 b1	 mov	 BYTE PTR hbuf$[rbp-127], al
  00365	41 8b c7	 mov	 eax, r15d
  00368	41 c1 ef 18	 shr	 r15d, 24
  0036c	c1 e8 10	 shr	 eax, 16
  0036f	44 88 7d b3	 mov	 BYTE PTR hbuf$[rbp-125], r15b
  00373	88 45 b2	 mov	 BYTE PTR hbuf$[rbp-126], al
  00376	e8 00 00 00 00	 call	 crc32
  0037b	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN424@inflate:

; 710  :             INITBITS();

  00380	45 8b fd	 mov	 r15d, r13d
  00383	41 8b dd	 mov	 ebx, r13d

; 711  :             state->mode = OS;

  00386	41 c7 04 24 03
	00 00 00	 mov	 DWORD PTR [r12], 3

; 712  :         case OS:
; 713  :             NEEDBITS(16);

  0038e	eb 05		 jmp	 SHORT $LL416@inflate
$LN419@inflate:
  00390	83 fb 10	 cmp	 ebx, 16
  00393	73 20		 jae	 SHORT $LN418@inflate
$LL416@inflate:
  00395	85 f6		 test	 esi, esi
  00397	0f 84 06 12 00
	00		 je	 $LN885@inflate
  0039d	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  003a1	8b cb		 mov	 ecx, ebx
  003a3	83 c3 08	 add	 ebx, 8
  003a6	d3 e0		 shl	 eax, cl
  003a8	ff ce		 dec	 esi
  003aa	49 ff c6	 inc	 r14
  003ad	44 03 f8	 add	 r15d, eax
  003b0	83 fb 10	 cmp	 ebx, 16
  003b3	72 e0		 jb	 SHORT $LL416@inflate
$LN418@inflate:

; 714  :             if (state->head != Z_NULL) {

  003b5	49 8b 4c 24 20	 mov	 rcx, QWORD PTR [r12+32]
  003ba	48 85 c9	 test	 rcx, rcx
  003bd	74 15		 je	 SHORT $LN410@inflate

; 715  :                 state->head->xflags = (int)(hold & 0xff);

  003bf	41 0f b6 c7	 movzx	 eax, r15b
  003c3	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 716  :                 state->head->os = (int)(hold >> 8);

  003c6	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  003cb	41 8b cf	 mov	 ecx, r15d
  003ce	c1 e9 08	 shr	 ecx, 8
  003d1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN410@inflate:

; 717  :             }
; 718  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  003d4	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  003dd	74 25		 je	 SHORT $LN406@inflate
  003df	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  003e4	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  003e8	41 c1 ef 08	 shr	 r15d, 8
  003ec	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  003f0	41 b8 02 00 00
	00		 mov	 r8d, 2
  003f6	44 88 7d b1	 mov	 BYTE PTR hbuf$[rbp-127], r15b
  003fa	e8 00 00 00 00	 call	 crc32
  003ff	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN406@inflate:

; 719  :             INITBITS();

  00404	45 8b fd	 mov	 r15d, r13d
  00407	41 8b dd	 mov	 ebx, r13d

; 720  :             state->mode = EXLEN;

  0040a	41 c7 04 24 04
	00 00 00	 mov	 DWORD PTR [r12], 4
$LN402@inflate:

; 721  :         case EXLEN:
; 722  :             if (state->flags & 0x0400) {

  00412	41 f7 44 24 10
	00 04 00 00	 test	 DWORD PTR [r12+16], 1024 ; 00000400H
  0041b	74 70		 je	 SHORT $LN401@inflate

; 723  :                 NEEDBITS(16);

  0041d	83 fb 10	 cmp	 ebx, 16
  00420	73 20		 jae	 SHORT $LN399@inflate
$LL397@inflate:
  00422	85 f6		 test	 esi, esi
  00424	0f 84 79 11 00
	00		 je	 $LN885@inflate
  0042a	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0042e	8b cb		 mov	 ecx, ebx
  00430	83 c3 08	 add	 ebx, 8
  00433	d3 e0		 shl	 eax, cl
  00435	ff ce		 dec	 esi
  00437	49 ff c6	 inc	 r14
  0043a	44 03 f8	 add	 r15d, eax
  0043d	83 fb 10	 cmp	 ebx, 16
  00440	72 e0		 jb	 SHORT $LL397@inflate
$LN399@inflate:

; 724  :                 state->length = (unsigned)(hold);
; 725  :                 if (state->head != Z_NULL)

  00442	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00447	45 89 7c 24 48	 mov	 DWORD PTR [r12+72], r15d
  0044c	48 85 c0	 test	 rax, rax
  0044f	74 04		 je	 SHORT $LN391@inflate

; 726  :                     state->head->extra_len = (unsigned)hold;

  00451	44 89 78 18	 mov	 DWORD PTR [rax+24], r15d
$LN391@inflate:

; 727  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00455	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  0045e	74 25		 je	 SHORT $LN387@inflate
  00460	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  00465	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  00469	41 c1 ef 08	 shr	 r15d, 8
  0046d	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00471	41 b8 02 00 00
	00		 mov	 r8d, 2
  00477	44 88 7d b1	 mov	 BYTE PTR hbuf$[rbp-127], r15b
  0047b	e8 00 00 00 00	 call	 crc32
  00480	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN387@inflate:

; 728  :                 INITBITS();

  00485	45 8b fd	 mov	 r15d, r13d
  00488	41 8b dd	 mov	 ebx, r13d

; 729  :             }
; 730  :             else if (state->head != Z_NULL)

  0048b	eb 0e		 jmp	 SHORT $LN382@inflate
$LN401@inflate:
  0048d	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00492	48 85 c0	 test	 rax, rax
  00495	74 04		 je	 SHORT $LN382@inflate

; 731  :                 state->head->extra = Z_NULL;

  00497	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13
$LN382@inflate:

; 732  :             state->mode = EXTRA;

  0049b	41 c7 04 24 05
	00 00 00	 mov	 DWORD PTR [r12], 5
$LN381@inflate:

; 733  :         case EXTRA:
; 734  :             if (state->flags & 0x0400) {

  004a3	41 f7 44 24 10
	00 04 00 00	 test	 DWORD PTR [r12+16], 1024 ; 00000400H
  004ac	0f 84 80 00 00
	00		 je	 $LN375@inflate

; 735  :                 copy = state->length;

  004b2	41 8b 4c 24 48	 mov	 ecx, DWORD PTR [r12+72]

; 736  :                 if (copy > have) copy = have;

  004b7	3b ce		 cmp	 ecx, esi
  004b9	8b f9		 mov	 edi, ecx
  004bb	0f 47 fe	 cmova	 edi, esi

; 737  :                 if (copy) {

  004be	85 ff		 test	 edi, edi
  004c0	74 64		 je	 SHORT $LN378@inflate

; 738  :                     if (state->head != Z_NULL &&
; 739  :                         state->head->extra != Z_NULL) {

  004c2	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  004c7	48 85 c0	 test	 rax, rax
  004ca	74 2e		 je	 SHORT $LN377@inflate
  004cc	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  004d0	4d 85 c9	 test	 r9, r9
  004d3	74 25		 je	 SHORT $LN377@inflate

; 740  :                         len = state->head->extra_len - state->length;

  004d5	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  004d8	2b d1		 sub	 edx, ecx

; 741  :                         zmemcpy(state->head->extra + len, next,
; 742  :                                 len + copy > state->head->extra_max ?
; 743  :                                 state->head->extra_max - len : copy);

  004da	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  004dd	8d 04 17	 lea	 eax, DWORD PTR [rdi+rdx]
  004e0	3b c1		 cmp	 eax, ecx
  004e2	76 04		 jbe	 SHORT $LN502@inflate
  004e4	2b ca		 sub	 ecx, edx
  004e6	eb 02		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  004e8	8b cf		 mov	 ecx, edi
$LN503@inflate:
  004ea	44 8b c1	 mov	 r8d, ecx
  004ed	8b ca		 mov	 ecx, edx
  004ef	49 8b d6	 mov	 rdx, r14
  004f2	49 03 c9	 add	 rcx, r9
  004f5	e8 00 00 00 00	 call	 memcpy
$LN377@inflate:

; 744  :                     }
; 745  :                     if (state->flags & 0x0200)

  004fa	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  00503	74 15		 je	 SHORT $LN376@inflate

; 746  :                         state->check = crc32(state->check, next, copy);

  00505	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  0050a	44 8b c7	 mov	 r8d, edi
  0050d	49 8b d6	 mov	 rdx, r14
  00510	e8 00 00 00 00	 call	 crc32
  00515	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN376@inflate:

; 747  :                     have -= copy;
; 748  :                     next += copy;

  0051a	8b c7		 mov	 eax, edi
  0051c	2b f7		 sub	 esi, edi
  0051e	4c 03 f0	 add	 r14, rax

; 749  :                     state->length -= copy;

  00521	41 29 7c 24 48	 sub	 DWORD PTR [r12+72], edi
$LN378@inflate:

; 750  :                 }
; 751  :                 if (state->length) goto inf_leave;

  00526	41 83 7c 24 48
	00		 cmp	 DWORD PTR [r12+72], 0
  0052c	0f 85 71 10 00
	00		 jne	 $LN885@inflate
$LN375@inflate:

; 752  :             }
; 753  :             state->length = 0;

  00532	45 89 6c 24 48	 mov	 DWORD PTR [r12+72], r13d

; 754  :             state->mode = NAME;

  00537	41 c7 04 24 06
	00 00 00	 mov	 DWORD PTR [r12], 6
$LN374@inflate:

; 755  :         case NAME:
; 756  :             if (state->flags & 0x0800) {

  0053f	41 f7 44 24 10
	00 08 00 00	 test	 DWORD PTR [r12+16], 2048 ; 00000800H
  00548	0f 84 7f 00 00
	00		 je	 $LN373@inflate

; 757  :                 if (have == 0) goto inf_leave;

  0054e	85 f6		 test	 esi, esi
  00550	0f 84 4d 10 00
	00		 je	 $LN885@inflate

; 758  :                 copy = 0;

  00556	41 8b fd	 mov	 edi, r13d
  00559	0f 1f 80 00 00
	00 00		 npad	 7
$LL371@inflate:

; 759  :                 do {
; 760  :                     len = (unsigned)(next[copy++]);

  00560	8b c7		 mov	 eax, edi
  00562	ff c7		 inc	 edi
  00564	46 0f b6 2c 30	 movzx	 r13d, BYTE PTR [rax+r14]

; 761  :                     if (state->head != Z_NULL &&
; 762  :                             state->head->name != Z_NULL &&
; 763  :                             state->length < state->head->name_max)

  00569	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0056e	48 85 c0	 test	 rax, rax
  00571	74 1c		 je	 SHORT $LN370@inflate
  00573	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00577	48 85 d2	 test	 rdx, rdx
  0057a	74 13		 je	 SHORT $LN370@inflate
  0057c	41 8b 4c 24 48	 mov	 ecx, DWORD PTR [r12+72]
  00581	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  00584	73 09		 jae	 SHORT $LN370@inflate

; 764  :                         state->head->name[state->length++] = len;

  00586	44 88 2c 11	 mov	 BYTE PTR [rcx+rdx], r13b
  0058a	41 ff 44 24 48	 inc	 DWORD PTR [r12+72]
$LN370@inflate:

; 765  :                 } while (len && copy < have);

  0058f	45 85 ed	 test	 r13d, r13d
  00592	74 04		 je	 SHORT $LN367@inflate
  00594	3b fe		 cmp	 edi, esi
  00596	72 c8		 jb	 SHORT $LL371@inflate
$LN367@inflate:

; 766  :                 if (state->flags & 0x0200)

  00598	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  005a1	74 15		 je	 SHORT $LN366@inflate

; 767  :                     state->check = crc32(state->check, next, copy);

  005a3	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  005a8	44 8b c7	 mov	 r8d, edi
  005ab	49 8b d6	 mov	 rdx, r14
  005ae	e8 00 00 00 00	 call	 crc32
  005b3	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN366@inflate:

; 768  :                 have -= copy;
; 769  :                 next += copy;

  005b8	8b c7		 mov	 eax, edi
  005ba	2b f7		 sub	 esi, edi
  005bc	4c 03 f0	 add	 r14, rax

; 770  :                 if (len) goto inf_leave;

  005bf	45 85 ed	 test	 r13d, r13d
  005c2	0f 85 db 0f 00
	00		 jne	 $LN885@inflate

; 771  :             }
; 772  :             else if (state->head != Z_NULL)

  005c8	45 33 ed	 xor	 r13d, r13d
  005cb	eb 0e		 jmp	 SHORT $LN363@inflate
$LN373@inflate:
  005cd	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  005d2	48 85 c0	 test	 rax, rax
  005d5	74 04		 je	 SHORT $LN363@inflate

; 773  :                 state->head->name = Z_NULL;

  005d7	4c 89 68 20	 mov	 QWORD PTR [rax+32], r13
$LN363@inflate:

; 774  :             state->length = 0;

  005db	45 89 6c 24 48	 mov	 DWORD PTR [r12+72], r13d

; 775  :             state->mode = COMMENT;

  005e0	41 c7 04 24 07
	00 00 00	 mov	 DWORD PTR [r12], 7
$LN362@inflate:

; 776  :         case COMMENT:
; 777  :             if (state->flags & 0x1000) {

  005e8	41 f7 44 24 10
	00 10 00 00	 test	 DWORD PTR [r12+16], 4096 ; 00001000H
  005f1	0f 84 78 00 00
	00		 je	 $LN361@inflate

; 778  :                 if (have == 0) goto inf_leave;

  005f7	85 f6		 test	 esi, esi
  005f9	0f 84 a4 0f 00
	00		 je	 $LN885@inflate

; 779  :                 copy = 0;

  005ff	41 8b fd	 mov	 edi, r13d
$LL359@inflate:

; 780  :                 do {
; 781  :                     len = (unsigned)(next[copy++]);

  00602	8b c7		 mov	 eax, edi
  00604	ff c7		 inc	 edi
  00606	46 0f b6 2c 30	 movzx	 r13d, BYTE PTR [rax+r14]

; 782  :                     if (state->head != Z_NULL &&
; 783  :                             state->head->comment != Z_NULL &&
; 784  :                             state->length < state->head->comm_max)

  0060b	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00610	48 85 c0	 test	 rax, rax
  00613	74 1c		 je	 SHORT $LN358@inflate
  00615	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00619	48 85 d2	 test	 rdx, rdx
  0061c	74 13		 je	 SHORT $LN358@inflate
  0061e	41 8b 4c 24 48	 mov	 ecx, DWORD PTR [r12+72]
  00623	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00626	73 09		 jae	 SHORT $LN358@inflate

; 785  :                         state->head->comment[state->length++] = len;

  00628	44 88 2c 11	 mov	 BYTE PTR [rcx+rdx], r13b
  0062c	41 ff 44 24 48	 inc	 DWORD PTR [r12+72]
$LN358@inflate:

; 786  :                 } while (len && copy < have);

  00631	45 85 ed	 test	 r13d, r13d
  00634	74 04		 je	 SHORT $LN355@inflate
  00636	3b fe		 cmp	 edi, esi
  00638	72 c8		 jb	 SHORT $LL359@inflate
$LN355@inflate:

; 787  :                 if (state->flags & 0x0200)

  0063a	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  00643	74 15		 je	 SHORT $LN354@inflate

; 788  :                     state->check = crc32(state->check, next, copy);

  00645	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  0064a	44 8b c7	 mov	 r8d, edi
  0064d	49 8b d6	 mov	 rdx, r14
  00650	e8 00 00 00 00	 call	 crc32
  00655	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
$LN354@inflate:

; 789  :                 have -= copy;
; 790  :                 next += copy;

  0065a	8b c7		 mov	 eax, edi
  0065c	2b f7		 sub	 esi, edi
  0065e	4c 03 f0	 add	 r14, rax

; 791  :                 if (len) goto inf_leave;

  00661	45 85 ed	 test	 r13d, r13d
  00664	0f 85 39 0f 00
	00		 jne	 $LN885@inflate

; 792  :             }
; 793  :             else if (state->head != Z_NULL)

  0066a	45 33 ed	 xor	 r13d, r13d
  0066d	eb 0e		 jmp	 SHORT $LN351@inflate
$LN361@inflate:
  0066f	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00674	48 85 c0	 test	 rax, rax
  00677	74 04		 je	 SHORT $LN351@inflate

; 794  :                 state->head->comment = Z_NULL;

  00679	4c 89 68 30	 mov	 QWORD PTR [rax+48], r13
$LN351@inflate:
  0067d	48 8b 7d 20	 mov	 rdi, QWORD PTR strm$[rbp-128]
  00681	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00685	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]

; 795  :             state->mode = HCRC;

  00689	41 c7 04 24 08
	00 00 00	 mov	 DWORD PTR [r12], 8
$LN350@inflate:

; 796  :         case HCRC:
; 797  :             if (state->flags & 0x0200) {

  00691	41 f7 44 24 10
	00 02 00 00	 test	 DWORD PTR [r12+16], 512	; 00000200H
  0069a	74 4b		 je	 SHORT $LN336@inflate

; 798  :                 NEEDBITS(16);

  0069c	83 fb 10	 cmp	 ebx, 16
  0069f	73 20		 jae	 SHORT $LN347@inflate
$LL345@inflate:
  006a1	85 f6		 test	 esi, esi
  006a3	0f 84 fa 0e 00
	00		 je	 $LN885@inflate
  006a9	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  006ad	8b cb		 mov	 ecx, ebx
  006af	83 c3 08	 add	 ebx, 8
  006b2	d3 e0		 shl	 eax, cl
  006b4	ff ce		 dec	 esi
  006b6	49 ff c6	 inc	 r14
  006b9	44 03 f8	 add	 r15d, eax
  006bc	83 fb 10	 cmp	 ebx, 16
  006bf	72 e0		 jb	 SHORT $LL345@inflate
$LN347@inflate:

; 799  :                 if (hold != (state->check & 0xffff)) {

  006c1	41 0f b7 44 24
	18		 movzx	 eax, WORD PTR [r12+24]
  006c7	44 3b f8	 cmp	 r15d, eax
  006ca	74 15		 je	 SHORT $LN338@inflate

; 800  :                     strm->msg = (char *)"header crc mismatch";

  006cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  006d3	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  006d7	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  006df	eb 4e		 jmp	 SHORT $LN490@inflate
$LN338@inflate:

; 801  :                     state->mode = BAD;
; 802  :                     break;
; 803  :                 }
; 804  :                 INITBITS();

  006e1	45 8b fd	 mov	 r15d, r13d
  006e4	41 8b dd	 mov	 ebx, r13d
$LN336@inflate:

; 805  :             }
; 806  :             if (state->head != Z_NULL) {

  006e7	49 8b 4c 24 20	 mov	 rcx, QWORD PTR [r12+32]
  006ec	48 85 c9	 test	 rcx, rcx
  006ef	74 1a		 je	 SHORT $LN335@inflate

; 807  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006f1	41 8b 44 24 10	 mov	 eax, DWORD PTR [r12+16]
  006f6	c1 f8 09	 sar	 eax, 9
  006f9	83 e0 01	 and	 eax, 1
  006fc	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 808  :                 state->head->done = 1;

  006ff	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00704	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN335@inflate:

; 809  :             }
; 810  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0070b	45 33 c0	 xor	 r8d, r8d
  0070e	33 d2		 xor	 edx, edx
  00710	33 c9		 xor	 ecx, ecx
  00712	e8 00 00 00 00	 call	 crc32
  00717	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  0071c	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN933@inflate:

; 1060 :                 state->mode = TYPE;

  0071f	41 c7 04 24 0b
	00 00 00	 mov	 DWORD PTR [r12], 11
$LN926@inflate:

; 685  :             break;

  00727	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]
$LN851@inflate:
  0072b	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
$LN490@inflate:

; 635  :     in = have;
; 636  :     out = left;
; 637  :     ret = Z_OK;
; 638  :     for (;;)
; 639  :         switch (state->mode) {

  0072f	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  00733	83 f8 1e	 cmp	 eax, 30
  00736	0f 87 9e 0f 00
	00		 ja	 $LN12@inflate
  0073c	44 8b 55 b4	 mov	 r10d, DWORD PTR out$1$[rbp-128]
  00740	45 33 ed	 xor	 r13d, r13d
  00743	e9 69 f9 ff ff	 jmp	 $LN929@inflate
$LN333@inflate:

; 811  :             state->mode = TYPE;
; 812  :             break;
; 813  : #endif
; 814  :         case DICTID:
; 815  :             NEEDBITS(32);

  00748	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0074b	73 23		 jae	 SHORT $LN332@inflate
  0074d	0f 1f 00	 npad	 3
$LL330@inflate:
  00750	85 f6		 test	 esi, esi
  00752	0f 84 4b 0e 00
	00		 je	 $LN885@inflate
  00758	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0075c	8b cb		 mov	 ecx, ebx
  0075e	83 c3 08	 add	 ebx, 8
  00761	d3 e0		 shl	 eax, cl
  00763	ff ce		 dec	 esi
  00765	49 ff c6	 inc	 r14
  00768	44 03 f8	 add	 r15d, eax
  0076b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0076e	72 e0		 jb	 SHORT $LL330@inflate
$LN332@inflate:

; 816  :             strm->adler = state->check = ZSWAP32(hold);

  00770	41 8b cf	 mov	 ecx, r15d
  00773	41 8b c7	 mov	 eax, r15d

; 817  :             INITBITS();

  00776	41 8b dd	 mov	 ebx, r13d
  00779	c1 e0 10	 shl	 eax, 16
  0077c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00782	03 c8		 add	 ecx, eax
  00784	41 8b c7	 mov	 eax, r15d
  00787	41 c1 ef 18	 shr	 r15d, 24
  0078b	c1 e8 08	 shr	 eax, 8
  0078e	c1 e1 08	 shl	 ecx, 8
  00791	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00796	03 c1		 add	 eax, ecx
  00798	41 03 c7	 add	 eax, r15d
  0079b	45 8b fd	 mov	 r15d, r13d
  0079e	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  007a3	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 818  :             state->mode = DICT;

  007a6	41 c7 04 24 0a
	00 00 00	 mov	 DWORD PTR [r12], 10
$LN321@inflate:

; 819  :         case DICT:
; 820  :             if (state->havedict == 0) {

  007ae	41 83 7c 24 0c
	00		 cmp	 DWORD PTR [r12+12], 0
  007b4	0f 84 7a 0d 00
	00		 je	 $LN579@inflate

; 823  :             }
; 824  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007ba	45 33 c0	 xor	 r8d, r8d
  007bd	33 d2		 xor	 edx, edx
  007bf	33 c9		 xor	 ecx, ecx
  007c1	e8 00 00 00 00	 call	 adler32
  007c6	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  007ca	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]
  007ce	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  007d3	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 825  :             state->mode = TYPE;

  007d6	41 c7 04 24 0b
	00 00 00	 mov	 DWORD PTR [r12], 11
$LN316@inflate:
  007de	8b 45 28	 mov	 eax, DWORD PTR flush$[rbp-128]
  007e1	83 c0 fb	 add	 eax, -5			; fffffffbH
  007e4	83 f8 01	 cmp	 eax, 1
  007e7	0f 86 b6 0d 00
	00		 jbe	 $LN885@inflate
$LN315@inflate:

; 826  :         case TYPE:
; 827  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
; 828  :         case TYPEDO:
; 829  :             if (state->last) {

  007ed	41 83 7c 24 04
	00		 cmp	 DWORD PTR [r12+4], 0
  007f3	74 17		 je	 SHORT $LN308@inflate

; 830  :                 BYTEBITS();

  007f5	8b cb		 mov	 ecx, ebx

; 831  :                 state->mode = CHECK;

  007f7	41 c7 04 24 1a
	00 00 00	 mov	 DWORD PTR [r12], 26
  007ff	83 e1 07	 and	 ecx, 7
  00802	41 d3 ef	 shr	 r15d, cl
  00805	2b d9		 sub	 ebx, ecx

; 832  :                 break;

  00807	e9 23 ff ff ff	 jmp	 $LN490@inflate
$LN308@inflate:

; 833  :             }
; 834  :             NEEDBITS(3);

  0080c	83 fb 03	 cmp	 ebx, 3
  0080f	73 20		 jae	 SHORT $LN307@inflate
$LL305@inflate:
  00811	85 f6		 test	 esi, esi
  00813	0f 84 8a 0d 00
	00		 je	 $LN885@inflate
  00819	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0081d	8b cb		 mov	 ecx, ebx
  0081f	83 c3 08	 add	 ebx, 8
  00822	d3 e0		 shl	 eax, cl
  00824	ff ce		 dec	 esi
  00826	49 ff c6	 inc	 r14
  00829	44 03 f8	 add	 r15d, eax
  0082c	83 fb 03	 cmp	 ebx, 3
  0082f	72 e0		 jb	 SHORT $LL305@inflate
$LN307@inflate:

; 835  :             state->last = BITS(1);

  00831	41 8b c7	 mov	 eax, r15d

; 836  :             DROPBITS(1);

  00834	41 d1 ef	 shr	 r15d, 1
  00837	ff cb		 dec	 ebx
  00839	83 e0 01	 and	 eax, 1
  0083c	41 89 44 24 04	 mov	 DWORD PTR [r12+4], eax

; 837  :             switch (BITS(2)) {

  00841	41 8b c7	 mov	 eax, r15d
  00844	83 e0 03	 and	 eax, 3
  00847	74 63		 je	 SHORT $LN294@inflate
  00849	ff c8		 dec	 eax
  0084b	74 3b		 je	 SHORT $LN293@inflate
  0084d	ff c8		 dec	 eax
  0084f	74 23		 je	 SHORT $LN288@inflate
  00851	ff c8		 dec	 eax
  00853	75 5f		 jne	 SHORT $LN286@inflate

; 851  :                 }
; 852  :                 break;
; 853  :             case 2:                             /* dynamic block */
; 854  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 855  :                         state->last ? " (last)" : ""));
; 856  :                 state->mode = TABLE;
; 857  :                 break;
; 858  :             case 3:
; 859  :                 strm->msg = (char *)"invalid block type";

  00855	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 860  :                 state->mode = BAD;
; 861  :             }
; 862  :             DROPBITS(2);

  0085c	41 c1 ef 02	 shr	 r15d, 2
  00860	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00863	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00867	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 863  :             break;

  0086f	e9 bb fe ff ff	 jmp	 $LN490@inflate
$LN288@inflate:

; 860  :                 state->mode = BAD;
; 861  :             }
; 862  :             DROPBITS(2);

  00874	41 c1 ef 02	 shr	 r15d, 2
  00878	41 c7 04 24 10
	00 00 00	 mov	 DWORD PTR [r12], 16
  00880	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 863  :             break;

  00883	e9 a7 fe ff ff	 jmp	 $LN490@inflate
$LN293@inflate:

; 842  :                 break;
; 843  :             case 1:                             /* fixed block */
; 844  :                 fixedtables(state);

  00888	49 8b cc	 mov	 rcx, r12
  0088b	e8 00 00 00 00	 call	 fixedtables

; 845  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 846  :                         state->last ? " (last)" : ""));
; 847  :                 state->mode = LEN_;             /* decode codes */
; 848  :                 if (flush == Z_TREES) {

  00890	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
  00893	41 c7 04 24 13
	00 00 00	 mov	 DWORD PTR [r12], 19
  0089b	83 f9 06	 cmp	 ecx, 6
  0089e	75 14		 jne	 SHORT $LN286@inflate

; 849  :                     DROPBITS(2);

  008a0	41 c1 ef 02	 shr	 r15d, 2
  008a4	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 850  :                     goto inf_leave;

  008a7	e9 fa 0c 00 00	 jmp	 $LN930@inflate
$LN294@inflate:

; 838  :             case 0:                             /* stored block */
; 839  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 840  :                         state->last ? " (last)" : ""));
; 841  :                 state->mode = STORED;

  008ac	41 c7 04 24 0d
	00 00 00	 mov	 DWORD PTR [r12], 13
$LN286@inflate:

; 860  :                 state->mode = BAD;
; 861  :             }
; 862  :             DROPBITS(2);

  008b4	41 c1 ef 02	 shr	 r15d, 2
  008b8	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 863  :             break;

  008bb	e9 6f fe ff ff	 jmp	 $LN490@inflate
$LN282@inflate:

; 864  :         case STORED:
; 865  :             BYTEBITS();                         /* go to byte boundary */

  008c0	8b cb		 mov	 ecx, ebx
  008c2	83 e1 07	 and	 ecx, 7
  008c5	2b d9		 sub	 ebx, ecx
  008c7	41 d3 ef	 shr	 r15d, cl

; 866  :             NEEDBITS(32);

  008ca	83 fb 20	 cmp	 ebx, 32			; 00000020H
  008cd	73 21		 jae	 SHORT $LN278@inflate
  008cf	90		 npad	 1
$LL276@inflate:
  008d0	85 f6		 test	 esi, esi
  008d2	0f 84 cb 0c 00
	00		 je	 $LN885@inflate
  008d8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  008dc	8b cb		 mov	 ecx, ebx
  008de	83 c3 08	 add	 ebx, 8
  008e1	d3 e0		 shl	 eax, cl
  008e3	ff ce		 dec	 esi
  008e5	49 ff c6	 inc	 r14
  008e8	44 03 f8	 add	 r15d, eax
  008eb	83 fb 20	 cmp	 ebx, 32			; 00000020H
  008ee	72 e0		 jb	 SHORT $LL276@inflate
$LN278@inflate:

; 867  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  008f0	41 8b c7	 mov	 eax, r15d
  008f3	41 0f b7 cf	 movzx	 ecx, r15w
  008f7	f7 d0		 not	 eax
  008f9	c1 e8 10	 shr	 eax, 16
  008fc	3b c8		 cmp	 ecx, eax
  008fe	74 18		 je	 SHORT $LN270@inflate

; 868  :                 strm->msg = (char *)"invalid stored block lengths";

  00900	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00907	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  0090b	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  00913	e9 17 fe ff ff	 jmp	 $LN490@inflate
$LN270@inflate:

; 869  :                 state->mode = BAD;
; 870  :                 break;
; 871  :             }
; 872  :             state->length = (unsigned)hold & 0xffff;

  00918	41 89 4c 24 48	 mov	 DWORD PTR [r12+72], ecx

; 873  :             Tracev((stderr, "inflate:       stored length %u\n",
; 874  :                     state->length));
; 875  :             INITBITS();
; 876  :             state->mode = COPY_;
; 877  :             if (flush == Z_TREES) goto inf_leave;

  0091d	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
  00920	45 8b fd	 mov	 r15d, r13d
  00923	41 8b dd	 mov	 ebx, r13d
  00926	41 c7 04 24 0e
	00 00 00	 mov	 DWORD PTR [r12], 14
  0092e	83 f9 06	 cmp	 ecx, 6
  00931	0f 84 6f 0c 00
	00		 je	 $LN930@inflate
$LN266@inflate:

; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  00937	41 c7 04 24 0f
	00 00 00	 mov	 DWORD PTR [r12], 15
$LN264@inflate:

; 880  :         case COPY:
; 881  :             copy = state->length;

  0093f	45 8b 6c 24 48	 mov	 r13d, DWORD PTR [r12+72]

; 882  :             if (copy) {

  00944	45 85 ed	 test	 r13d, r13d
  00947	74 52		 je	 SHORT $LN263@inflate

; 883  :                 if (copy > have) copy = have;

  00949	44 3b ee	 cmp	 r13d, esi
  0094c	44 0f 47 ee	 cmova	 r13d, esi

; 884  :                 if (copy > left) copy = left;

  00950	45 3b eb	 cmp	 r13d, r11d
  00953	45 0f 47 eb	 cmova	 r13d, r11d

; 885  :                 if (copy == 0) goto inf_leave;

  00957	45 85 ed	 test	 r13d, r13d
  0095a	0f 84 43 0c 00
	00		 je	 $LN885@inflate

; 886  :                 zmemcpy(put, next, copy);

  00960	45 8b c5	 mov	 r8d, r13d
  00963	49 8b d6	 mov	 rdx, r14
  00966	49 8b c9	 mov	 rcx, r9
  00969	41 8b fd	 mov	 edi, r13d
  0096c	e8 00 00 00 00	 call	 memcpy

; 887  :                 have -= copy;
; 888  :                 next += copy;
; 889  :                 left -= copy;

  00971	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]

; 890  :                 put += copy;

  00975	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00979	45 2b dd	 sub	 r11d, r13d
  0097c	4c 03 f7	 add	 r14, rdi
  0097f	4c 03 cf	 add	 r9, rdi

; 891  :                 state->length -= copy;
; 892  :                 break;

  00982	48 8b 7d 20	 mov	 rdi, QWORD PTR strm$[rbp-128]
  00986	41 2b f5	 sub	 esi, r13d
  00989	45 29 6c 24 48	 sub	 DWORD PTR [r12+72], r13d
  0098e	44 89 5d 38	 mov	 DWORD PTR left$1$[rbp-128], r11d
  00992	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00996	e9 94 fd ff ff	 jmp	 $LN490@inflate
$LN263@inflate:

; 893  :             }
; 894  :             Tracev((stderr, "inflate:       stored end\n"));
; 895  :             state->mode = TYPE;

  0099b	41 c7 04 24 0b
	00 00 00	 mov	 DWORD PTR [r12], 11

; 896  :             break;

  009a3	e9 87 fd ff ff	 jmp	 $LN490@inflate
$LN258@inflate:

; 897  :         case TABLE:
; 898  :             NEEDBITS(14);

  009a8	83 fb 0e	 cmp	 ebx, 14
  009ab	73 23		 jae	 SHORT $LN257@inflate
  009ad	0f 1f 00	 npad	 3
$LL255@inflate:
  009b0	85 f6		 test	 esi, esi
  009b2	0f 84 eb 0b 00
	00		 je	 $LN885@inflate
  009b8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  009bc	8b cb		 mov	 ecx, ebx
  009be	83 c3 08	 add	 ebx, 8
  009c1	d3 e0		 shl	 eax, cl
  009c3	ff ce		 dec	 esi
  009c5	49 ff c6	 inc	 r14
  009c8	44 03 f8	 add	 r15d, eax
  009cb	83 fb 0e	 cmp	 ebx, 14
  009ce	72 e0		 jb	 SHORT $LL255@inflate
$LN257@inflate:

; 899  :             state->nlen = BITS(5) + 257;

  009d0	41 8b cf	 mov	 ecx, r15d

; 900  :             DROPBITS(5);

  009d3	41 c1 ef 05	 shr	 r15d, 5

; 901  :             state->ndist = BITS(5) + 1;
; 902  :             DROPBITS(5);
; 903  :             state->ncode = BITS(4) + 4;
; 904  :             DROPBITS(4);

  009d7	83 c3 f2	 add	 ebx, -14		; fffffff2H
  009da	41 8b d7	 mov	 edx, r15d
  009dd	41 c1 ef 05	 shr	 r15d, 5
  009e1	83 e1 1f	 and	 ecx, 31
  009e4	41 8b c7	 mov	 eax, r15d
  009e7	83 e2 1f	 and	 edx, 31
  009ea	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  009f0	83 e0 0f	 and	 eax, 15
  009f3	ff c2		 inc	 edx
  009f5	41 c1 ef 04	 shr	 r15d, 4
  009f9	83 c0 04	 add	 eax, 4
  009fc	41 89 4c 24 74	 mov	 DWORD PTR [r12+116], ecx
  00a01	41 89 54 24 78	 mov	 DWORD PTR [r12+120], edx
  00a06	41 89 44 24 70	 mov	 DWORD PTR [r12+112], eax

; 905  : #ifndef PKZIP_BUG_WORKAROUND
; 906  :             if (state->nlen > 286 || state->ndist > 30) {

  00a0b	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a11	0f 87 16 01 00
	00		 ja	 $LN239@inflate
  00a17	83 fa 1e	 cmp	 edx, 30
  00a1a	0f 87 0d 01 00
	00		 ja	 $LN239@inflate

; 908  :                 state->mode = BAD;
; 909  :                 break;
; 910  :             }
; 911  : #endif
; 912  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 913  :             state->have = 0;

  00a20	45 89 6c 24 7c	 mov	 DWORD PTR [r12+124], r13d

; 914  :             state->mode = LENLENS;

  00a25	41 c7 04 24 11
	00 00 00	 mov	 DWORD PTR [r12], 17
$LN525@inflate:

; 915  :         case LENLENS:
; 916  :             while (state->have < state->ncode) {

  00a2d	41 8b 44 24 70	 mov	 eax, DWORD PTR [r12+112]
  00a32	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00a39	41 39 44 24 7c	 cmp	 DWORD PTR [r12+124], eax
  00a3e	73 5b		 jae	 SHORT $LN527@inflate
$LL237@inflate:

; 917  :                 NEEDBITS(3);

  00a40	83 fb 03	 cmp	 ebx, 3
  00a43	73 20		 jae	 SHORT $LN234@inflate
$LL232@inflate:
  00a45	85 f6		 test	 esi, esi
  00a47	0f 84 56 0b 00
	00		 je	 $LN885@inflate
  00a4d	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00a51	8b cb		 mov	 ecx, ebx
  00a53	83 c3 08	 add	 ebx, 8
  00a56	d3 e0		 shl	 eax, cl
  00a58	ff ce		 dec	 esi
  00a5a	49 ff c6	 inc	 r14
  00a5d	44 03 f8	 add	 r15d, eax
  00a60	83 fb 03	 cmp	 ebx, 3
  00a63	72 e0		 jb	 SHORT $LL232@inflate
$LN234@inflate:

; 918  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a65	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  00a6a	41 0f b7 cf	 movzx	 ecx, r15w

; 919  :                 DROPBITS(3);

  00a6e	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00a71	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00a79	66 83 e1 07	 and	 cx, 7
  00a7d	41 c1 ef 03	 shr	 r15d, 3
  00a81	66 41 89 8c 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], cx
  00a8a	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]
  00a8f	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  00a94	41 3b 44 24 70	 cmp	 eax, DWORD PTR [r12+112]
  00a99	72 a5		 jb	 SHORT $LL237@inflate
$LN527@inflate:

; 920  :             }
; 921  :             while (state->have < 19)

  00a9b	41 83 7c 24 7c
	13		 cmp	 DWORD PTR [r12+124], 19
  00aa1	73 23		 jae	 SHORT $LN222@inflate
$LL223@inflate:

; 922  :                 state->lens[order[state->have++]] = 0;

  00aa3	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  00aa8	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00ab0	66 45 89 ac 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], r13w
  00ab9	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]
  00abe	41 83 7c 24 7c
	13		 cmp	 DWORD PTR [r12+124], 19
  00ac4	72 dd		 jb	 SHORT $LL223@inflate
$LN222@inflate:

; 923  :             state->next = state->codes;

  00ac6	49 8d 84 24 48
	05 00 00	 lea	 rax, QWORD PTR [r12+1352]
  00ace	4d 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR [r12+128]

; 924  :             state->lencode = (const code FAR *)(state->next);
; 925  :             state->lenbits = 7;
; 926  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 927  :                                 &(state->lenbits), state->work);

  00ad6	33 c9		 xor	 ecx, ecx
  00ad8	49 89 01	 mov	 QWORD PTR [r9], rax
  00adb	49 89 44 24 58	 mov	 QWORD PTR [r12+88], rax
  00ae0	49 8d 84 24 08
	03 00 00	 lea	 rax, QWORD PTR [r12+776]
  00ae8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00aed	41 c7 00 07 00
	00 00		 mov	 DWORD PTR [r8], 7
  00af4	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00af9	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00afd	49 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR [r12+136]
  00b05	e8 00 00 00 00	 call	 inflate_table

; 931  :                 break;

  00b0a	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]
  00b0e	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax
  00b11	85 c0		 test	 eax, eax
  00b13	74 30		 je	 SHORT $LN221@inflate

; 928  :             if (ret) {
; 929  :                 strm->msg = (char *)"invalid code lengths set";

  00b15	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  00b1c	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 930  :                 state->mode = BAD;

  00b20	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 931  :                 break;

  00b28	e9 fe fb ff ff	 jmp	 $LN851@inflate
$LN239@inflate:

; 907  :                 strm->msg = (char *)"too many length or distance symbols";

  00b2d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b34	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00b38	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  00b40	e9 ea fb ff ff	 jmp	 $LN490@inflate
$LN221@inflate:

; 932  :             }
; 933  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 934  :             state->have = 0;

  00b45	45 89 6c 24 7c	 mov	 DWORD PTR [r12+124], r13d

; 935  :             state->mode = CODELENS;

  00b4a	41 c7 04 24 12
	00 00 00	 mov	 DWORD PTR [r12], 18
  00b52	4d 8d 44 24 68	 lea	 r8, QWORD PTR [r12+104]
$LN528@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00b57	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  00b5c	45 8b 54 24 7c	 mov	 r10d, DWORD PTR [r12+124]
  00b61	41 03 44 24 74	 add	 eax, DWORD PTR [r12+116]
  00b66	44 3b d0	 cmp	 r10d, eax
  00b69	0f 83 e5 01 00
	00		 jae	 $LN218@inflate
  00b6f	90		 npad	 1
$LL219@inflate:

; 938  :                 for (;;) {
; 939  :                     here = state->lencode[BITS(state->lenbits)];

  00b70	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00b73	b8 01 00 00 00	 mov	 eax, 1
  00b78	d3 e0		 shl	 eax, cl
  00b7a	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b7d	41 8b c7	 mov	 eax, r15d
  00b80	48 23 c8	 and	 rcx, rax
  00b83	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00b88	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 940  :                     if ((unsigned)(here.bits) <= bits) break;

  00b8b	8b c8		 mov	 ecx, eax
  00b8d	89 45 b8	 mov	 DWORD PTR here$[rbp-128], eax
  00b90	c1 e9 08	 shr	 ecx, 8
  00b93	0f b6 c9	 movzx	 ecx, cl
  00b96	3b cb		 cmp	 ecx, ebx
  00b98	76 4b		 jbe	 SHORT $LN555@inflate
  00b9a	66 0f 1f 44 00
	00		 npad	 6
$LL217@inflate:

; 941  :                     PULLBYTE();

  00ba0	85 f6		 test	 esi, esi
  00ba2	0f 84 fb 09 00
	00		 je	 $LN885@inflate
  00ba8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00bac	8b cb		 mov	 ecx, ebx
  00bae	83 c3 08	 add	 ebx, 8
  00bb1	d3 e0		 shl	 eax, cl
  00bb3	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00bb6	ff ce		 dec	 esi
  00bb8	44 03 f8	 add	 r15d, eax
  00bbb	b8 01 00 00 00	 mov	 eax, 1
  00bc0	49 ff c6	 inc	 r14
  00bc3	d3 e0		 shl	 eax, cl
  00bc5	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bc8	41 8b c7	 mov	 eax, r15d
  00bcb	48 23 c8	 and	 rcx, rax
  00bce	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00bd3	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00bd6	8b c8		 mov	 ecx, eax
  00bd8	89 45 b8	 mov	 DWORD PTR here$[rbp-128], eax
  00bdb	c1 e9 08	 shr	 ecx, 8
  00bde	0f b6 c9	 movzx	 ecx, cl
  00be1	3b cb		 cmp	 ecx, ebx
  00be3	77 bb		 ja	 SHORT $LL217@inflate
$LN555@inflate:

; 942  :                 }
; 943  :                 if (here.val < 16) {

  00be5	8b d0		 mov	 edx, eax
  00be7	c1 ea 10	 shr	 edx, 16
  00bea	66 83 fa 10	 cmp	 dx, 16
  00bee	73 21		 jae	 SHORT $LN920@inflate

; 944  :                     DROPBITS(here.bits);

  00bf0	c1 e8 08	 shr	 eax, 8
  00bf3	0f b6 c8	 movzx	 ecx, al

; 945  :                     state->lens[state->have++] = here.val;

  00bf6	41 8b c2	 mov	 eax, r10d
  00bf9	66 41 89 94 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], dx
  00c02	41 d3 ef	 shr	 r15d, cl
  00c05	2b d9		 sub	 ebx, ecx
  00c07	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]

; 946  :                 }
; 947  :                 else {

  00c0c	e9 2b 01 00 00	 jmp	 $LN603@inflate
$LN920@inflate:

; 948  :                     if (here.val == 16) {

  00c11	75 60		 jne	 SHORT $LN205@inflate

; 949  :                         NEEDBITS(here.bits + 2);

  00c13	c1 e8 08	 shr	 eax, 8
  00c16	0f b6 d0	 movzx	 edx, al
  00c19	83 c2 02	 add	 edx, 2
  00c1c	3b da		 cmp	 ebx, edx
  00c1e	73 1f		 jae	 SHORT $LN203@inflate
$LL201@inflate:
  00c20	85 f6		 test	 esi, esi
  00c22	0f 84 7b 09 00
	00		 je	 $LN885@inflate
  00c28	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00c2c	8b cb		 mov	 ecx, ebx
  00c2e	83 c3 08	 add	 ebx, 8
  00c31	d3 e0		 shl	 eax, cl
  00c33	ff ce		 dec	 esi
  00c35	49 ff c6	 inc	 r14
  00c38	44 03 f8	 add	 r15d, eax
  00c3b	3b da		 cmp	 ebx, edx
  00c3d	72 e1		 jb	 SHORT $LL201@inflate
$LN203@inflate:

; 950  :                         DROPBITS(here.bits);

  00c3f	0f b6 4d b9	 movzx	 ecx, BYTE PTR here$[rbp-127]
  00c43	41 d3 ef	 shr	 r15d, cl
  00c46	2b d9		 sub	 ebx, ecx

; 951  :                         if (state->have == 0) {

  00c48	45 85 d2	 test	 r10d, r10d
  00c4b	0f 84 32 01 00
	00		 je	 $LN560@inflate

; 955  :                         }
; 956  :                         len = state->lens[state->have - 1];
; 957  :                         copy = 3 + BITS(2);

  00c51	41 8b d7	 mov	 edx, r15d
  00c54	41 8d 42 ff	 lea	 eax, DWORD PTR [r10-1]

; 958  :                         DROPBITS(2);

  00c58	41 c1 ef 02	 shr	 r15d, 2
  00c5c	45 0f b7 84 44
	88 00 00 00	 movzx	 r8d, WORD PTR [r12+rax*2+136]
  00c65	83 e2 03	 and	 edx, 3
  00c68	83 c2 03	 add	 edx, 3
  00c6b	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 959  :                     }
; 960  :                     else if (here.val == 17) {

  00c6e	e9 94 00 00 00	 jmp	 $LN156@inflate
$LN205@inflate:
  00c73	66 83 7d ba 11	 cmp	 WORD PTR here$[rbp-126], 17

; 961  :                         NEEDBITS(here.bits + 3);

  00c78	44 0f b6 4d b9	 movzx	 r9d, BYTE PTR here$[rbp-127]
  00c7d	75 41		 jne	 SHORT $LN170@inflate
  00c7f	41 8d 51 03	 lea	 edx, DWORD PTR [r9+3]
  00c83	3b da		 cmp	 ebx, edx
  00c85	73 1f		 jae	 SHORT $LN185@inflate
$LL183@inflate:
  00c87	85 f6		 test	 esi, esi
  00c89	0f 84 14 09 00
	00		 je	 $LN885@inflate
  00c8f	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00c93	8b cb		 mov	 ecx, ebx
  00c95	83 c3 08	 add	 ebx, 8
  00c98	d3 e0		 shl	 eax, cl
  00c9a	ff ce		 dec	 esi
  00c9c	49 ff c6	 inc	 r14
  00c9f	44 03 f8	 add	 r15d, eax
  00ca2	3b da		 cmp	 ebx, edx
  00ca4	72 e1		 jb	 SHORT $LL183@inflate
$LN185@inflate:

; 962  :                         DROPBITS(here.bits);

  00ca6	41 8b c9	 mov	 ecx, r9d

; 963  :                         len = 0;
; 964  :                         copy = 3 + BITS(3);
; 965  :                         DROPBITS(3);

  00ca9	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00cae	41 d3 ef	 shr	 r15d, cl
  00cb1	41 8b d7	 mov	 edx, r15d
  00cb4	83 e2 07	 and	 edx, 7
  00cb7	83 c2 03	 add	 edx, 3
  00cba	41 c1 ef 03	 shr	 r15d, 3

; 966  :                     }
; 967  :                     else {

  00cbe	eb 3f		 jmp	 SHORT $LN921@inflate
$LN170@inflate:

; 968  :                         NEEDBITS(here.bits + 7);

  00cc0	41 8d 51 07	 lea	 edx, DWORD PTR [r9+7]
  00cc4	3b da		 cmp	 ebx, edx
  00cc6	73 1f		 jae	 SHORT $LN169@inflate
$LL167@inflate:
  00cc8	85 f6		 test	 esi, esi
  00cca	0f 84 d3 08 00
	00		 je	 $LN885@inflate
  00cd0	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00cd4	8b cb		 mov	 ecx, ebx
  00cd6	83 c3 08	 add	 ebx, 8
  00cd9	d3 e0		 shl	 eax, cl
  00cdb	ff ce		 dec	 esi
  00cdd	49 ff c6	 inc	 r14
  00ce0	44 03 f8	 add	 r15d, eax
  00ce3	3b da		 cmp	 ebx, edx
  00ce5	72 e1		 jb	 SHORT $LL167@inflate
$LN169@inflate:

; 969  :                         DROPBITS(here.bits);

  00ce7	41 8b c9	 mov	 ecx, r9d

; 970  :                         len = 0;
; 971  :                         copy = 11 + BITS(7);
; 972  :                         DROPBITS(7);

  00cea	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00cef	41 d3 ef	 shr	 r15d, cl
  00cf2	41 8b d7	 mov	 edx, r15d
  00cf5	83 e2 7f	 and	 edx, 127		; 0000007fH
  00cf8	83 c2 0b	 add	 edx, 11
  00cfb	41 c1 ef 07	 shr	 r15d, 7
$LN921@inflate:
  00cff	41 2b c1	 sub	 eax, r9d
  00d02	45 8b c5	 mov	 r8d, r13d
  00d05	03 d8		 add	 ebx, eax
$LN156@inflate:

; 973  :                     }
; 974  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d07	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  00d0c	41 8d 0c 12	 lea	 ecx, DWORD PTR [r10+rdx]
  00d10	41 03 44 24 74	 add	 eax, DWORD PTR [r12+116]
  00d15	3b c8		 cmp	 ecx, eax
  00d17	77 6a		 ja	 SHORT $LN560@inflate

; 975  :                         strm->msg = (char *)"invalid bit length repeat";
; 976  :                         state->mode = BAD;
; 977  :                         break;
; 978  :                     }
; 979  :                     while (copy--)

  00d19	85 d2		 test	 edx, edx
  00d1b	74 1a		 je	 SHORT $LN850@inflate
  00d1d	0f 1f 00	 npad	 3
$LL154@inflate:

; 980  :                         state->lens[state->have++] = (unsigned short)len;

  00d20	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  00d25	66 45 89 84 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], r8w
  00d2e	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]
  00d33	ff ca		 dec	 edx
  00d35	75 e9		 jne	 SHORT $LL154@inflate
$LN850@inflate:
  00d37	4d 8d 44 24 68	 lea	 r8, QWORD PTR [r12+104]
$LN603@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00d3c	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  00d41	45 8b 54 24 7c	 mov	 r10d, DWORD PTR [r12+124]
  00d46	41 03 44 24 74	 add	 eax, DWORD PTR [r12+116]
  00d4b	44 3b d0	 cmp	 r10d, eax
  00d4e	0f 82 1c fe ff
	ff		 jb	 $LL219@inflate
$LN218@inflate:

; 981  :                 }
; 982  :             }
; 983  : 
; 984  :             /* handle error breaks in while */
; 985  :             if (state->mode == BAD) break;

  00d54	41 83 3c 24 1d	 cmp	 DWORD PTR [r12], 29
  00d59	0f 84 cc f9 ff
	ff		 je	 $LN851@inflate

; 986  : 
; 987  :             /* check for end-of-block code (better have one) */
; 988  :             if (state->lens[256] == 0) {

  00d5f	66 41 83 bc 24
	88 02 00 00 00	 cmp	 WORD PTR [r12+648], 0
  00d69	75 30		 jne	 SHORT $LN151@inflate

; 989  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00d6b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00d72	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 990  :                 state->mode = BAD;

  00d76	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 991  :                 break;

  00d7e	e9 a8 f9 ff ff	 jmp	 $LN851@inflate
$LN560@inflate:

; 952  :                             strm->msg = (char *)"invalid bit length repeat";

  00d83	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00d8a	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 953  :                             state->mode = BAD;

  00d8e	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 954  :                             break;

  00d96	e9 90 f9 ff ff	 jmp	 $LN851@inflate
$LN151@inflate:

; 992  :             }
; 993  : 
; 994  :             /* build code tables -- note: do not change the lenbits or distbits
; 995  :                values here (9 and 6) without reading the comments in inftrees.h
; 996  :                concerning the ENOUGH constants, which depend on those values */
; 997  :             state->next = state->codes;

  00d9b	49 8d 84 24 48
	05 00 00	 lea	 rax, QWORD PTR [r12+1352]

; 998  :             state->lencode = (const code FAR *)(state->next);
; 999  :             state->lenbits = 9;

  00da3	41 c7 00 09 00
	00 00		 mov	 DWORD PTR [r8], 9

; 1000 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1001 :                                 &(state->lenbits), state->work);

  00daa	4d 8d ac 24 08
	03 00 00	 lea	 r13, QWORD PTR [r12+776]
  00db2	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00db7	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00dbc	45 8b 44 24 74	 mov	 r8d, DWORD PTR [r12+116]
  00dc1	49 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR [r12+136]
  00dc9	4d 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR [r12+128]
  00dd1	b9 01 00 00 00	 mov	 ecx, 1
  00dd6	49 89 84 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rax
  00dde	49 89 44 24 58	 mov	 QWORD PTR [r12+88], rax
  00de3	e8 00 00 00 00	 call	 inflate_table
  00de8	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 1002 :             if (ret) {

  00deb	85 c0		 test	 eax, eax
  00ded	74 1c		 je	 SHORT $LN150@inflate

; 1003 :                 strm->msg = (char *)"invalid literal/lengths set";

  00def	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
$LN932@inflate:
  00df6	48 8b 7d 20	 mov	 rdi, QWORD PTR strm$[rbp-128]
  00dfa	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1004 :                 state->mode = BAD;

  00dfe	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 1005 :                 break;

  00e06	e9 1c f9 ff ff	 jmp	 $LN926@inflate
$LN150@inflate:

; 1006 :             }
; 1007 :             state->distcode = (const code FAR *)(state->next);

  00e0b	49 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR [r12+128]

; 1008 :             state->distbits = 6;
; 1009 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1010 :                             &(state->next), &(state->distbits), state->work);

  00e13	45 8b 44 24 78	 mov	 r8d, DWORD PTR [r12+120]
  00e18	49 8d 4c 24 6c	 lea	 rcx, QWORD PTR [r12+108]
  00e1d	49 89 44 24 60	 mov	 QWORD PTR [r12+96], rax
  00e22	41 8b 44 24 74	 mov	 eax, DWORD PTR [r12+116]
  00e27	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00e2d	48 83 c0 44	 add	 rax, 68			; 00000044H
  00e31	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00e36	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00e3b	4d 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR [r12+128]
  00e43	49 8d 14 44	 lea	 rdx, QWORD PTR [r12+rax*2]
  00e47	b9 02 00 00 00	 mov	 ecx, 2
  00e4c	e8 00 00 00 00	 call	 inflate_table
  00e51	44 8b e8	 mov	 r13d, eax
  00e54	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 1011 :             if (ret) {

  00e57	85 c0		 test	 eax, eax
  00e59	74 09		 je	 SHORT $LN149@inflate

; 1012 :                 strm->msg = (char *)"invalid distances set";

  00e5b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1013 :                 state->mode = BAD;
; 1014 :                 break;

  00e62	eb 92		 jmp	 SHORT $LN932@inflate
$LN149@inflate:

; 1015 :             }
; 1016 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1017 :             state->mode = LEN_;
; 1018 :             if (flush == Z_TREES) goto inf_leave;

  00e64	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
  00e67	41 c7 04 24 13
	00 00 00	 mov	 DWORD PTR [r12], 19
  00e6f	83 f9 06	 cmp	 ecx, 6
  00e72	0f 84 32 07 00
	00		 je	 $inf_leave$936
  00e78	48 8b 7d 20	 mov	 rdi, QWORD PTR strm$[rbp-128]
  00e7c	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00e80	44 8b 55 b4	 mov	 r10d, DWORD PTR out$1$[rbp-128]
  00e84	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]
  00e88	45 33 ed	 xor	 r13d, r13d
  00e8b	4d 8d 44 24 68	 lea	 r8, QWORD PTR [r12+104]
$LN148@inflate:

; 1019 :         case LEN_:
; 1020 :             state->mode = LEN;

  00e90	41 c7 04 24 14
	00 00 00	 mov	 DWORD PTR [r12], 20
$LN146@inflate:

; 1021 :         case LEN:
; 1022 :             if (have >= 6 && left >= 258) {

  00e98	83 fe 06	 cmp	 esi, 6
  00e9b	72 68		 jb	 SHORT $LN145@inflate
  00e9d	41 81 fb 02 01
	00 00		 cmp	 r11d, 258		; 00000102H
  00ea4	72 5f		 jb	 SHORT $LN145@inflate

; 1023 :                 RESTORE();

  00ea6	4c 89 4f 10	 mov	 QWORD PTR [rdi+16], r9
  00eaa	44 89 5f 18	 mov	 DWORD PTR [rdi+24], r11d
  00eae	4c 89 37	 mov	 QWORD PTR [rdi], r14
  00eb1	89 77 08	 mov	 DWORD PTR [rdi+8], esi

; 1024 :                 inflate_fast(strm, out);

  00eb4	41 8b d2	 mov	 edx, r10d
  00eb7	48 8b cf	 mov	 rcx, rdi
  00eba	45 89 7c 24 40	 mov	 DWORD PTR [r12+64], r15d
  00ebf	41 89 5c 24 44	 mov	 DWORD PTR [r12+68], ebx
  00ec4	e8 00 00 00 00	 call	 inflate_fast

; 1025 :                 LOAD();
; 1026 :                 if (state->mode == TYPE)

  00ec9	41 83 3c 24 0b	 cmp	 DWORD PTR [r12], 11
  00ece	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00ed2	44 8b 5f 18	 mov	 r11d, DWORD PTR [rdi+24]
  00ed6	4c 8b 37	 mov	 r14, QWORD PTR [rdi]
  00ed9	8b 77 08	 mov	 esi, DWORD PTR [rdi+8]
  00edc	45 8b 7c 24 40	 mov	 r15d, DWORD PTR [r12+64]
  00ee1	41 8b 5c 24 44	 mov	 ebx, DWORD PTR [r12+68]
  00ee6	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00eea	44 89 5d 38	 mov	 DWORD PTR left$1$[rbp-128], r11d
  00eee	0f 85 3b f8 ff
	ff		 jne	 $LN490@inflate

; 1027 :                     state->back = -1;

  00ef4	41 c7 84 24 dc
	1b 00 00 ff ff
	ff ff		 mov	 DWORD PTR [r12+7132], -1

; 1028 :                 break;

  00f00	e9 2a f8 ff ff	 jmp	 $LN490@inflate
$LN145@inflate:

; 1029 :             }
; 1030 :             state->back = 0;
; 1031 :             for (;;) {
; 1032 :                 here = state->lencode[BITS(state->lenbits)];

  00f05	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00f08	4d 8b 5c 24 58	 mov	 r11, QWORD PTR [r12+88]
  00f0d	b8 01 00 00 00	 mov	 eax, 1
  00f12	d3 e0		 shl	 eax, cl
  00f14	45 89 ac 24 dc
	1b 00 00	 mov	 DWORD PTR [r12+7132], r13d
  00f1c	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00f1f	41 8b c7	 mov	 eax, r15d
  00f22	48 23 c8	 and	 rcx, rax
  00f25	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1033 :                 if ((unsigned)(here.bits) <= bits) break;

  00f29	8b c8		 mov	 ecx, eax
  00f2b	c1 e9 08	 shr	 ecx, 8
  00f2e	0f b6 c9	 movzx	 ecx, cl
  00f31	3b cb		 cmp	 ecx, ebx
  00f33	76 42		 jbe	 SHORT $LN562@inflate
$LL137@inflate:

; 1034 :                 PULLBYTE();

  00f35	85 f6		 test	 esi, esi
  00f37	0f 84 66 06 00
	00		 je	 $LN885@inflate
  00f3d	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00f41	8b cb		 mov	 ecx, ebx
  00f43	83 c3 08	 add	 ebx, 8
  00f46	d3 e0		 shl	 eax, cl
  00f48	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00f4b	ff ce		 dec	 esi
  00f4d	44 03 f8	 add	 r15d, eax
  00f50	b8 01 00 00 00	 mov	 eax, 1
  00f55	49 ff c6	 inc	 r14
  00f58	d3 e0		 shl	 eax, cl
  00f5a	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00f5d	41 8b c7	 mov	 eax, r15d
  00f60	48 23 c8	 and	 rcx, rax
  00f63	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00f68	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00f6b	8b c8		 mov	 ecx, eax
  00f6d	c1 e9 08	 shr	 ecx, 8
  00f70	0f b6 c9	 movzx	 ecx, cl
  00f73	3b cb		 cmp	 ecx, ebx
  00f75	77 be		 ja	 SHORT $LL137@inflate
$LN562@inflate:

; 1035 :             }
; 1036 :             if (here.op && (here.op & 0xf0) == 0) {

  00f77	84 c0		 test	 al, al
  00f79	0f 84 cd 00 00
	00		 je	 $LN119@inflate
  00f7f	a8 f0		 test	 al, 240			; 000000f0H
  00f81	0f 85 c5 00 00
	00		 jne	 $LN119@inflate

; 1037 :                 last = here;
; 1038 :                 for (;;) {
; 1039 :                     here = state->lencode[last.val +
; 1040 :                             (BITS(last.bits + last.op) >> last.bits)];

  00f87	44 8b d0	 mov	 r10d, eax
  00f8a	0f b6 c8	 movzx	 ecx, al
  00f8d	89 45 b8	 mov	 DWORD PTR last$[rbp-128], eax
  00f90	41 c1 ea 08	 shr	 r10d, 8
  00f94	41 b9 01 00 00
	00		 mov	 r9d, 1
  00f9a	8b d0		 mov	 edx, eax
  00f9c	45 0f b6 c2	 movzx	 r8d, r10b
  00fa0	c1 e8 10	 shr	 eax, 16
  00fa3	41 03 c8	 add	 ecx, r8d
  00fa6	41 d3 e1	 shl	 r9d, cl
  00fa9	41 8b c8	 mov	 ecx, r8d
  00fac	41 ff c9	 dec	 r9d
  00faf	45 23 cf	 and	 r9d, r15d
  00fb2	41 d3 e9	 shr	 r9d, cl
  00fb5	44 03 c8	 add	 r9d, eax
  00fb8	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1041 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00fbc	44 0f b6 5d b9	 movzx	 r11d, BYTE PTR last$[rbp-127]
  00fc1	8b c8		 mov	 ecx, eax
  00fc3	c1 e9 08	 shr	 ecx, 8
  00fc6	44 0f b6 c1	 movzx	 r8d, cl
  00fca	41 0f b6 ca	 movzx	 ecx, r10b
  00fce	44 03 c1	 add	 r8d, ecx
  00fd1	44 3b c3	 cmp	 r8d, ebx
  00fd4	76 65		 jbe	 SHORT $LN122@inflate
  00fd6	44 0f b7 55 ba	 movzx	 r10d, WORD PTR last$[rbp-126]
  00fdb	0f 1f 44 00 00	 npad	 5
$LL129@inflate:

; 1042 :                     PULLBYTE();

  00fe0	85 f6		 test	 esi, esi
  00fe2	0f 84 bb 05 00
	00		 je	 $LN885@inflate
  00fe8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00fec	8b cb		 mov	 ecx, ebx
  00fee	45 0f b6 cb	 movzx	 r9d, r11b
  00ff2	d3 e0		 shl	 eax, cl
  00ff4	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ffa	0f b6 ca	 movzx	 ecx, dl
  00ffd	41 03 c9	 add	 ecx, r9d
  01000	44 03 f8	 add	 r15d, eax
  01003	41 0f b7 c2	 movzx	 eax, r10w
  01007	41 d3 e0	 shl	 r8d, cl
  0100a	41 8b c9	 mov	 ecx, r9d
  0100d	83 c3 08	 add	 ebx, 8
  01010	41 ff c8	 dec	 r8d
  01013	ff ce		 dec	 esi
  01015	49 ff c6	 inc	 r14
  01018	45 23 c7	 and	 r8d, r15d
  0101b	41 d3 e8	 shr	 r8d, cl
  0101e	44 03 c0	 add	 r8d, eax
  01021	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  01026	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0102a	8b c8		 mov	 ecx, eax
  0102c	c1 e9 08	 shr	 ecx, 8
  0102f	44 0f b6 c1	 movzx	 r8d, cl
  01033	45 03 c1	 add	 r8d, r9d
  01036	44 3b c3	 cmp	 r8d, ebx
  01039	77 a5		 ja	 SHORT $LL129@inflate
$LN122@inflate:

; 1043 :                 }
; 1044 :                 DROPBITS(last.bits);

  0103b	41 0f b6 cb	 movzx	 ecx, r11b
  0103f	41 d3 ef	 shr	 r15d, cl
  01042	2b d9		 sub	 ebx, ecx

; 1045 :                 state->back += last.bits;

  01044	41 89 8c 24 dc
	1b 00 00	 mov	 DWORD PTR [r12+7132], ecx
$LN119@inflate:

; 1046 :             }
; 1047 :             DROPBITS(here.bits);

  0104c	8b c8		 mov	 ecx, eax
  0104e	c1 e9 08	 shr	 ecx, 8
  01051	0f b6 c9	 movzx	 ecx, cl

; 1048 :             state->back += here.bits;

  01054	41 01 8c 24 dc
	1b 00 00	 add	 DWORD PTR [r12+7132], ecx
  0105c	41 d3 ef	 shr	 r15d, cl
  0105f	2b d9		 sub	 ebx, ecx

; 1049 :             state->length = (unsigned)here.val;

  01061	8b c8		 mov	 ecx, eax
  01063	c1 e9 10	 shr	 ecx, 16
  01066	41 89 4c 24 48	 mov	 DWORD PTR [r12+72], ecx

; 1050 :             if ((int)(here.op) == 0) {

  0106b	84 c0		 test	 al, al
  0106d	75 0d		 jne	 SHORT $LN116@inflate

; 1051 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1052 :                         "inflate:         literal '%c'\n" :
; 1053 :                         "inflate:         literal 0x%02x\n", here.val));
; 1054 :                 state->mode = LIT;

  0106f	41 c7 04 24 19
	00 00 00	 mov	 DWORD PTR [r12], 25

; 1055 :                 break;

  01077	e9 ab f6 ff ff	 jmp	 $LN926@inflate
$LN116@inflate:

; 1056 :             }
; 1057 :             if (here.op & 32) {

  0107c	a8 20		 test	 al, 32			; 00000020H
  0107e	74 11		 je	 SHORT $LN115@inflate

; 1058 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1059 :                 state->back = -1;

  01080	41 c7 84 24 dc
	1b 00 00 ff ff
	ff ff		 mov	 DWORD PTR [r12+7132], -1

; 1061 :                 break;

  0108c	e9 8e f6 ff ff	 jmp	 $LN933@inflate
$LN115@inflate:

; 1062 :             }
; 1063 :             if (here.op & 64) {

  01091	a8 40		 test	 al, 64			; 00000040H
  01093	74 18		 je	 SHORT $LN114@inflate

; 1064 :                 strm->msg = (char *)"invalid literal/length code";

  01095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  0109c	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  010a0	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  010a8	e9 7a f6 ff ff	 jmp	 $LN926@inflate
$LN114@inflate:

; 1065 :                 state->mode = BAD;
; 1066 :                 break;
; 1067 :             }
; 1068 :             state->extra = (unsigned)(here.op) & 15;

  010ad	0f b6 c8	 movzx	 ecx, al

; 1069 :             state->mode = LENEXT;

  010b0	41 c7 04 24 15
	00 00 00	 mov	 DWORD PTR [r12], 21
  010b8	83 e1 0f	 and	 ecx, 15
  010bb	41 89 4c 24 50	 mov	 DWORD PTR [r12+80], ecx
$LN113@inflate:

; 1070 :         case LENEXT:
; 1071 :             if (state->extra) {

  010c0	41 8b 54 24 50	 mov	 edx, DWORD PTR [r12+80]
  010c5	85 d2		 test	 edx, edx
  010c7	74 46		 je	 SHORT $LN112@inflate

; 1072 :                 NEEDBITS(state->extra);

  010c9	3b da		 cmp	 ebx, edx
  010cb	73 22		 jae	 SHORT $LN110@inflate
  010cd	0f 1f 00	 npad	 3
$LL108@inflate:
  010d0	85 f6		 test	 esi, esi
  010d2	0f 84 cb 04 00
	00		 je	 $LN885@inflate
  010d8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  010dc	8b cb		 mov	 ecx, ebx
  010de	83 c3 08	 add	 ebx, 8
  010e1	d3 e0		 shl	 eax, cl
  010e3	ff ce		 dec	 esi
  010e5	49 ff c6	 inc	 r14
  010e8	44 03 f8	 add	 r15d, eax
  010eb	3b da		 cmp	 ebx, edx
  010ed	72 e1		 jb	 SHORT $LL108@inflate
$LN110@inflate:

; 1073 :                 state->length += BITS(state->extra);

  010ef	8b ca		 mov	 ecx, edx
  010f1	b8 01 00 00 00	 mov	 eax, 1

; 1074 :                 DROPBITS(state->extra);

  010f6	2b da		 sub	 ebx, edx
  010f8	d3 e0		 shl	 eax, cl
  010fa	ff c8		 dec	 eax
  010fc	41 23 c7	 and	 eax, r15d
  010ff	41 d3 ef	 shr	 r15d, cl
  01102	41 01 44 24 48	 add	 DWORD PTR [r12+72], eax

; 1075 :                 state->back += state->extra;

  01107	41 01 94 24 dc
	1b 00 00	 add	 DWORD PTR [r12+7132], edx
$LN112@inflate:

; 1076 :             }
; 1077 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1078 :             state->was = state->length;

  0110f	41 8b 44 24 48	 mov	 eax, DWORD PTR [r12+72]

; 1079 :             state->mode = DIST;

  01114	41 c7 04 24 16
	00 00 00	 mov	 DWORD PTR [r12], 22
  0111c	49 8d 54 24 6c	 lea	 rdx, QWORD PTR [r12+108]
  01121	41 89 84 24 e0
	1b 00 00	 mov	 DWORD PTR [r12+7136], eax
$LN537@inflate:

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  01129	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  0112b	4d 8b 5c 24 60	 mov	 r11, QWORD PTR [r12+96]
  01130	b8 01 00 00 00	 mov	 eax, 1
  01135	d3 e0		 shl	 eax, cl
  01137	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0113a	41 8b c7	 mov	 eax, r15d
  0113d	48 23 c8	 and	 rcx, rax
  01140	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1083 :                 if ((unsigned)(here.bits) <= bits) break;

  01144	8b c8		 mov	 ecx, eax
  01146	c1 e9 08	 shr	 ecx, 8
  01149	0f b6 c9	 movzx	 ecx, cl
  0114c	3b cb		 cmp	 ecx, ebx
  0114e	76 41		 jbe	 SHORT $LN567@inflate
$LL98@inflate:

; 1084 :                 PULLBYTE();

  01150	85 f6		 test	 esi, esi
  01152	0f 84 4b 04 00
	00		 je	 $LN885@inflate
  01158	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0115c	8b cb		 mov	 ecx, ebx
  0115e	83 c3 08	 add	 ebx, 8
  01161	d3 e0		 shl	 eax, cl
  01163	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  01165	ff ce		 dec	 esi
  01167	44 03 f8	 add	 r15d, eax
  0116a	b8 01 00 00 00	 mov	 eax, 1
  0116f	49 ff c6	 inc	 r14
  01172	d3 e0		 shl	 eax, cl
  01174	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  01177	41 8b c7	 mov	 eax, r15d
  0117a	48 23 c8	 and	 rcx, rax
  0117d	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  01182	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01185	8b c8		 mov	 ecx, eax
  01187	c1 e9 08	 shr	 ecx, 8
  0118a	0f b6 c9	 movzx	 ecx, cl
  0118d	3b cb		 cmp	 ecx, ebx
  0118f	77 bf		 ja	 SHORT $LL98@inflate
$LN567@inflate:

; 1085 :             }
; 1086 :             if ((here.op & 0xf0) == 0) {

  01191	a8 f0		 test	 al, 240			; 000000f0H
  01193	0f 85 c3 00 00
	00		 jne	 $LN80@inflate

; 1087 :                 last = here;
; 1088 :                 for (;;) {
; 1089 :                     here = state->distcode[last.val +
; 1090 :                             (BITS(last.bits + last.op) >> last.bits)];

  01199	44 8b d0	 mov	 r10d, eax
  0119c	0f b6 c8	 movzx	 ecx, al
  0119f	89 45 b8	 mov	 DWORD PTR last$[rbp-128], eax
  011a2	41 c1 ea 08	 shr	 r10d, 8
  011a6	41 b9 01 00 00
	00		 mov	 r9d, 1
  011ac	8b d0		 mov	 edx, eax
  011ae	45 0f b6 c2	 movzx	 r8d, r10b
  011b2	c1 e8 10	 shr	 eax, 16
  011b5	41 03 c8	 add	 ecx, r8d
  011b8	41 d3 e1	 shl	 r9d, cl
  011bb	41 8b c8	 mov	 ecx, r8d
  011be	41 ff c9	 dec	 r9d
  011c1	45 23 cf	 and	 r9d, r15d
  011c4	41 d3 e9	 shr	 r9d, cl
  011c7	44 03 c8	 add	 r9d, eax
  011ca	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1091 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011ce	44 0f b6 5d b9	 movzx	 r11d, BYTE PTR last$[rbp-127]
  011d3	8b c8		 mov	 ecx, eax
  011d5	c1 e9 08	 shr	 ecx, 8
  011d8	44 0f b6 c1	 movzx	 r8d, cl
  011dc	41 0f b6 ca	 movzx	 ecx, r10b
  011e0	44 03 c1	 add	 r8d, ecx
  011e3	44 3b c3	 cmp	 r8d, ebx
  011e6	76 63		 jbe	 SHORT $LN83@inflate
  011e8	44 0f b7 55 ba	 movzx	 r10d, WORD PTR last$[rbp-126]
  011ed	0f 1f 00	 npad	 3
$LL90@inflate:

; 1092 :                     PULLBYTE();

  011f0	85 f6		 test	 esi, esi
  011f2	0f 84 ab 03 00
	00		 je	 $LN885@inflate
  011f8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  011fc	8b cb		 mov	 ecx, ebx
  011fe	45 0f b6 cb	 movzx	 r9d, r11b
  01202	d3 e0		 shl	 eax, cl
  01204	41 b8 01 00 00
	00		 mov	 r8d, 1
  0120a	0f b6 ca	 movzx	 ecx, dl
  0120d	41 03 c9	 add	 ecx, r9d
  01210	44 03 f8	 add	 r15d, eax
  01213	41 0f b7 c2	 movzx	 eax, r10w
  01217	41 d3 e0	 shl	 r8d, cl
  0121a	41 8b c9	 mov	 ecx, r9d
  0121d	83 c3 08	 add	 ebx, 8
  01220	41 ff c8	 dec	 r8d
  01223	ff ce		 dec	 esi
  01225	49 ff c6	 inc	 r14
  01228	45 23 c7	 and	 r8d, r15d
  0122b	41 d3 e8	 shr	 r8d, cl
  0122e	44 03 c0	 add	 r8d, eax
  01231	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  01236	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0123a	8b c8		 mov	 ecx, eax
  0123c	c1 e9 08	 shr	 ecx, 8
  0123f	44 0f b6 c1	 movzx	 r8d, cl
  01243	45 03 c1	 add	 r8d, r9d
  01246	44 3b c3	 cmp	 r8d, ebx
  01249	77 a5		 ja	 SHORT $LL90@inflate
$LN83@inflate:

; 1093 :                 }
; 1094 :                 DROPBITS(last.bits);

  0124b	41 0f b6 cb	 movzx	 ecx, r11b
  0124f	41 d3 ef	 shr	 r15d, cl
  01252	2b d9		 sub	 ebx, ecx

; 1095 :                 state->back += last.bits;

  01254	41 01 8c 24 dc
	1b 00 00	 add	 DWORD PTR [r12+7132], ecx
$LN80@inflate:

; 1096 :             }
; 1097 :             DROPBITS(here.bits);
; 1098 :             state->back += here.bits;
; 1099 :             if (here.op & 64) {
; 1100 :                 strm->msg = (char *)"invalid distance code";
; 1101 :                 state->mode = BAD;
; 1102 :                 break;

  0125c	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  01260	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]
  01264	8b c8		 mov	 ecx, eax
  01266	c1 e9 08	 shr	 ecx, 8
  01269	0f b6 c9	 movzx	 ecx, cl
  0126c	41 01 8c 24 dc
	1b 00 00	 add	 DWORD PTR [r12+7132], ecx
  01274	41 d3 ef	 shr	 r15d, cl
  01277	2b d9		 sub	 ebx, ecx
  01279	a8 40		 test	 al, 64			; 00000040H
  0127b	74 18		 je	 SHORT $LN77@inflate

; 667  :                 strm->msg = (char *)"unknown compression method";

  0127d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  01284	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 668  :                 state->mode = BAD;

  01288	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 669  :                 break;

  01290	e9 9a f4 ff ff	 jmp	 $LN490@inflate
$LN77@inflate:
  01295	44 8b 55 b4	 mov	 r10d, DWORD PTR out$1$[rbp-128]

; 1103 :             }
; 1104 :             state->offset = (unsigned)here.val;

  01299	8b c8		 mov	 ecx, eax

; 1105 :             state->extra = (unsigned)(here.op) & 15;
; 1106 :             state->mode = DISTEXT;

  0129b	41 c7 04 24 17
	00 00 00	 mov	 DWORD PTR [r12], 23
  012a3	c1 e9 10	 shr	 ecx, 16
  012a6	41 89 4c 24 4c	 mov	 DWORD PTR [r12+76], ecx
  012ab	0f b6 c8	 movzx	 ecx, al
  012ae	83 e1 0f	 and	 ecx, 15
  012b1	41 89 4c 24 50	 mov	 DWORD PTR [r12+80], ecx
$LN76@inflate:

; 1107 :         case DISTEXT:
; 1108 :             if (state->extra) {

  012b6	41 8b 54 24 50	 mov	 edx, DWORD PTR [r12+80]
  012bb	85 d2		 test	 edx, edx
  012bd	74 43		 je	 SHORT $LN75@inflate

; 1109 :                 NEEDBITS(state->extra);

  012bf	3b da		 cmp	 ebx, edx
  012c1	73 1f		 jae	 SHORT $LN73@inflate
$LL71@inflate:
  012c3	85 f6		 test	 esi, esi
  012c5	0f 84 d8 02 00
	00		 je	 $LN885@inflate
  012cb	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  012cf	8b cb		 mov	 ecx, ebx
  012d1	83 c3 08	 add	 ebx, 8
  012d4	d3 e0		 shl	 eax, cl
  012d6	ff ce		 dec	 esi
  012d8	49 ff c6	 inc	 r14
  012db	44 03 f8	 add	 r15d, eax
  012de	3b da		 cmp	 ebx, edx
  012e0	72 e1		 jb	 SHORT $LL71@inflate
$LN73@inflate:

; 1110 :                 state->offset += BITS(state->extra);

  012e2	8b ca		 mov	 ecx, edx
  012e4	b8 01 00 00 00	 mov	 eax, 1

; 1111 :                 DROPBITS(state->extra);

  012e9	2b da		 sub	 ebx, edx
  012eb	d3 e0		 shl	 eax, cl
  012ed	ff c8		 dec	 eax
  012ef	41 23 c7	 and	 eax, r15d
  012f2	41 d3 ef	 shr	 r15d, cl
  012f5	41 01 44 24 4c	 add	 DWORD PTR [r12+76], eax

; 1112 :                 state->back += state->extra;

  012fa	41 01 94 24 dc
	1b 00 00	 add	 DWORD PTR [r12+7132], edx
$LN75@inflate:

; 1113 :             }
; 1114 : #ifdef INFLATE_STRICT
; 1115 :             if (state->offset > state->dmax) {
; 1116 :                 strm->msg = (char *)"invalid distance too far back";
; 1117 :                 state->mode = BAD;
; 1118 :                 break;
; 1119 :             }
; 1120 : #endif
; 1121 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1122 :             state->mode = MATCH;

  01302	41 c7 04 24 18
	00 00 00	 mov	 DWORD PTR [r12], 24
$LN62@inflate:

; 1123 :         case MATCH:
; 1124 :             if (left == 0) goto inf_leave;

  0130a	45 85 db	 test	 r11d, r11d
  0130d	0f 84 90 02 00
	00		 je	 $LN885@inflate

; 1125 :             copy = out - left;
; 1126 :             if (state->offset > copy) {         /* copy from window */

  01313	41 8b 4c 24 4c	 mov	 ecx, DWORD PTR [r12+76]
  01318	41 8b c2	 mov	 eax, r10d
  0131b	41 2b c3	 sub	 eax, r11d
  0131e	3b c8		 cmp	 ecx, eax
  01320	76 54		 jbe	 SHORT $LN60@inflate

; 1127 :                 copy = state->offset - copy;

  01322	2b c8		 sub	 ecx, eax

; 1128 :                 if (copy > state->whave) {

  01324	41 3b 4c 24 30	 cmp	 ecx, DWORD PTR [r12+48]
  01329	76 23		 jbe	 SHORT $LN58@inflate

; 1129 :                     if (state->sane) {

  0132b	41 83 bc 24 d8
	1b 00 00 00	 cmp	 DWORD PTR [r12+7128], 0
  01334	74 18		 je	 SHORT $LN58@inflate

; 1130 :                         strm->msg = (char *)"invalid distance too far back";

  01336	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  0133d	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  01341	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  01349	e9 e1 f3 ff ff	 jmp	 $LN490@inflate
$LN58@inflate:

; 1131 :                         state->mode = BAD;
; 1132 :                         break;
; 1133 :                     }
; 1134 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1135 :                     Trace((stderr, "inflate.c too far\n"));
; 1136 :                     copy -= state->whave;
; 1137 :                     if (copy > state->length) copy = state->length;
; 1138 :                     if (copy > left) copy = left;
; 1139 :                     left -= copy;
; 1140 :                     state->length -= copy;
; 1141 :                     do {
; 1142 :                         *put++ = 0;
; 1143 :                     } while (--copy);
; 1144 :                     if (state->length == 0) state->mode = LEN;
; 1145 :                     break;
; 1146 : #endif
; 1147 :                 }
; 1148 :                 if (copy > state->wnext) {

  0134e	41 8b 44 24 34	 mov	 eax, DWORD PTR [r12+52]
  01353	3b c8		 cmp	 ecx, eax
  01355	76 0b		 jbe	 SHORT $LN57@inflate

; 1149 :                     copy -= state->wnext;
; 1150 :                     from = state->window + (state->wsize - copy);

  01357	41 8b 54 24 2c	 mov	 edx, DWORD PTR [r12+44]
  0135c	2b c8		 sub	 ecx, eax
  0135e	2b d1		 sub	 edx, ecx

; 1151 :                 }
; 1152 :                 else

  01360	eb 04		 jmp	 SHORT $LN922@inflate
$LN57@inflate:

; 1153 :                     from = state->window + (state->wnext - copy);

  01362	2b c1		 sub	 eax, ecx
  01364	8b d0		 mov	 edx, eax
$LN922@inflate:

; 1154 :                 if (copy > state->length) copy = state->length;

  01366	41 8b 44 24 48	 mov	 eax, DWORD PTR [r12+72]
  0136b	49 03 54 24 38	 add	 rdx, QWORD PTR [r12+56]
  01370	3b c8		 cmp	 ecx, eax
  01372	76 0f		 jbe	 SHORT $LN54@inflate

; 1155 :             }
; 1156 :             else {                              /* copy from output */

  01374	eb 0b		 jmp	 SHORT $LN923@inflate
$LN60@inflate:

; 1157 :                 from = put - state->offset;
; 1158 :                 copy = state->length;

  01376	41 8b 44 24 48	 mov	 eax, DWORD PTR [r12+72]
  0137b	49 8b d1	 mov	 rdx, r9
  0137e	48 2b d1	 sub	 rdx, rcx
$LN923@inflate:
  01381	8b c8		 mov	 ecx, eax
$LN54@inflate:

; 1159 :             }
; 1160 :             if (copy > left) copy = left;

  01383	41 3b cb	 cmp	 ecx, r11d
  01386	41 0f 47 cb	 cmova	 ecx, r11d

; 1161 :             left -= copy;

  0138a	44 2b d9	 sub	 r11d, ecx

; 1162 :             state->length -= copy;

  0138d	2b c1		 sub	 eax, ecx

; 1165 :             } while (--copy);

  0138f	49 2b d1	 sub	 rdx, r9
  01392	44 89 5d 38	 mov	 DWORD PTR left$1$[rbp-128], r11d
  01396	41 89 44 24 48	 mov	 DWORD PTR [r12+72], eax
  0139b	0f 1f 44 00 00	 npad	 5
$LL52@inflate:

; 1163 :             do {
; 1164 :                 *put++ = *from++;

  013a0	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  013a5	49 ff c1	 inc	 r9
  013a8	41 88 41 ff	 mov	 BYTE PTR [r9-1], al

; 1165 :             } while (--copy);

  013ac	ff c9		 dec	 ecx
  013ae	75 f0		 jne	 SHORT $LL52@inflate

; 1166 :             if (state->length == 0) state->mode = LEN;

  013b0	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  013b4	41 39 4c 24 48	 cmp	 DWORD PTR [r12+72], ecx
  013b9	0f 85 70 f3 ff
	ff		 jne	 $LN490@inflate
  013bf	41 c7 04 24 14
	00 00 00	 mov	 DWORD PTR [r12], 20

; 1167 :             break;

  013c7	e9 63 f3 ff ff	 jmp	 $LN490@inflate
$LN48@inflate:

; 1168 :         case LIT:
; 1169 :             if (left == 0) goto inf_leave;

  013cc	45 85 db	 test	 r11d, r11d
  013cf	0f 84 ce 01 00
	00		 je	 $LN885@inflate

; 1170 :             *put++ = (unsigned char)(state->length);

  013d5	41 0f b6 44 24
	48		 movzx	 eax, BYTE PTR [r12+72]
  013db	49 ff c1	 inc	 r9

; 1171 :             left--;

  013de	41 ff cb	 dec	 r11d
  013e1	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  013e5	44 89 5d 38	 mov	 DWORD PTR left$1$[rbp-128], r11d
  013e9	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9

; 1172 :             state->mode = LEN;

  013ed	41 c7 04 24 14
	00 00 00	 mov	 DWORD PTR [r12], 20

; 1173 :             break;

  013f5	e9 35 f3 ff ff	 jmp	 $LN490@inflate
$LN46@inflate:

; 1174 :         case CHECK:
; 1175 :             if (state->wrap) {

  013fa	41 83 7c 24 08
	00		 cmp	 DWORD PTR [r12+8], 0
  01400	0f 84 ca 00 00
	00		 je	 $LN31@inflate

; 1176 :                 NEEDBITS(32);

  01406	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01409	73 25		 jae	 SHORT $LN43@inflate
  0140b	0f 1f 44 00 00	 npad	 5
$LL41@inflate:
  01410	85 f6		 test	 esi, esi
  01412	0f 84 8b 01 00
	00		 je	 $LN885@inflate
  01418	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0141c	8b cb		 mov	 ecx, ebx
  0141e	83 c3 08	 add	 ebx, 8
  01421	d3 e0		 shl	 eax, cl
  01423	ff ce		 dec	 esi
  01425	49 ff c6	 inc	 r14
  01428	44 03 f8	 add	 r15d, eax
  0142b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0142e	72 e0		 jb	 SHORT $LL41@inflate
$LN43@inflate:

; 1177 :                 out -= left;

  01430	45 2b d3	 sub	 r10d, r11d

; 1178 :                 strm->total_out += out;

  01433	44 01 57 1c	 add	 DWORD PTR [rdi+28], r10d

; 1179 :                 state->total += out;

  01437	45 01 54 24 1c	 add	 DWORD PTR [r12+28], r10d

; 1180 :                 if (out)

  0143c	45 85 d2	 test	 r10d, r10d
  0143f	74 35		 je	 SHORT $LN35@inflate

; 1181 :                     strm->adler = state->check =
; 1182 :                         UPDATE(state->check, put - out, out);

  01441	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  01446	41 8b c2	 mov	 eax, r10d
  01449	49 8b d1	 mov	 rdx, r9
  0144c	48 2b d0	 sub	 rdx, rax
  0144f	41 83 7c 24 10
	00		 cmp	 DWORD PTR [r12+16], 0
  01455	45 8b c2	 mov	 r8d, r10d
  01458	74 07		 je	 SHORT $LN504@inflate
  0145a	e8 00 00 00 00	 call	 crc32
  0145f	eb 05		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  01461	e8 00 00 00 00	 call	 adler32
$LN505@inflate:
  01466	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0146a	44 8b 5d 38	 mov	 r11d, DWORD PTR left$1$[rbp-128]
  0146e	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  01473	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN35@inflate:

; 1183 :                 out = left;
; 1184 :                 if ((
; 1185 : #ifdef GUNZIP
; 1186 :                      state->flags ? hold :
; 1187 : #endif
; 1188 :                      ZSWAP32(hold)) != state->check) {

  01476	41 83 7c 24 10
	00		 cmp	 DWORD PTR [r12+16], 0
  0147c	44 89 5d b4	 mov	 DWORD PTR out$1$[rbp-128], r11d
  01480	41 8b cf	 mov	 ecx, r15d
  01483	75 26		 jne	 SHORT $LN507@inflate
  01485	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0148b	41 8b c7	 mov	 eax, r15d
  0148e	c1 e0 10	 shl	 eax, 16
  01491	03 c8		 add	 ecx, eax
  01493	41 8b c7	 mov	 eax, r15d
  01496	c1 e8 08	 shr	 eax, 8
  01499	c1 e1 08	 shl	 ecx, 8
  0149c	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014a1	03 c8		 add	 ecx, eax
  014a3	41 8b c7	 mov	 eax, r15d
  014a6	c1 e8 18	 shr	 eax, 24
  014a9	03 c8		 add	 ecx, eax
$LN507@inflate:
  014ab	41 3b 4c 24 18	 cmp	 ecx, DWORD PTR [r12+24]
  014b0	74 18		 je	 SHORT $LN33@inflate

; 1189 :                     strm->msg = (char *)"incorrect data check";

  014b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  014b9	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  014bd	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  014c5	e9 65 f2 ff ff	 jmp	 $LN490@inflate
$LN33@inflate:

; 1190 :                     state->mode = BAD;
; 1191 :                     break;
; 1192 :                 }
; 1193 :                 INITBITS();

  014ca	45 8b fd	 mov	 r15d, r13d
  014cd	41 8b dd	 mov	 ebx, r13d
$LN31@inflate:

; 1194 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1195 :             }
; 1196 : #ifdef GUNZIP
; 1197 :             state->mode = LENGTH;

  014d0	41 c7 04 24 1b
	00 00 00	 mov	 DWORD PTR [r12], 27
$LN30@inflate:

; 1198 :         case LENGTH:
; 1199 :             if (state->wrap && state->flags) {

  014d8	41 83 7c 24 08
	00		 cmp	 DWORD PTR [r12+8], 0
  014de	0f 84 98 00 00
	00		 je	 $LN16@inflate
  014e4	41 83 7c 24 10
	00		 cmp	 DWORD PTR [r12+16], 0
  014ea	0f 84 8c 00 00
	00		 je	 $LN16@inflate

; 1200 :                 NEEDBITS(32);

  014f0	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014f3	73 20		 jae	 SHORT $LN27@inflate
$LL25@inflate:
  014f5	85 f6		 test	 esi, esi
  014f7	0f 84 a6 00 00
	00		 je	 $LN885@inflate
  014fd	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  01501	8b cb		 mov	 ecx, ebx
  01503	83 c3 08	 add	 ebx, 8
  01506	d3 e0		 shl	 eax, cl
  01508	ff ce		 dec	 esi
  0150a	49 ff c6	 inc	 r14
  0150d	44 03 f8	 add	 r15d, eax
  01510	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01513	72 e0		 jb	 SHORT $LL25@inflate
$LN27@inflate:

; 1201 :                 if (hold != (state->total & 0xffffffffUL)) {

  01515	45 3b 7c 24 1c	 cmp	 r15d, DWORD PTR [r12+28]
  0151a	74 5a		 je	 SHORT $LN18@inflate

; 1202 :                     strm->msg = (char *)"incorrect length check";

  0151c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  01523	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  01527	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  0152f	e9 fb f1 ff ff	 jmp	 $LN490@inflate
$LN579@inflate:

; 821  :                 RESTORE();

  01534	4c 89 4f 10	 mov	 QWORD PTR [rdi+16], r9
  01538	44 89 5f 18	 mov	 DWORD PTR [rdi+24], r11d
  0153c	4c 89 37	 mov	 QWORD PTR [rdi], r14
  0153f	89 77 08	 mov	 DWORD PTR [rdi+8], esi

; 822  :                 return Z_NEED_DICT;

  01542	b8 02 00 00 00	 mov	 eax, 2
  01547	45 89 7c 24 40	 mov	 DWORD PTR [r12+64], r15d
  0154c	41 89 5c 24 44	 mov	 DWORD PTR [r12+68], ebx
$LN919@inflate:
  01551	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  01556	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  0155b	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  01560	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  01565	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 1252 : }

  0156a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  01571	41 5c		 pop	 r12
  01573	5f		 pop	 rdi
  01574	5d		 pop	 rbp
  01575	c3		 ret	 0
$LN18@inflate:

; 1203 :                     state->mode = BAD;
; 1204 :                     break;
; 1205 :                 }
; 1206 :                 INITBITS();

  01576	45 8b fd	 mov	 r15d, r13d
  01579	41 8b dd	 mov	 ebx, r13d
$LN16@inflate:

; 1207 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1208 :             }
; 1209 : #endif
; 1210 :             state->mode = DONE;

  0157c	41 c7 04 24 1c
	00 00 00	 mov	 DWORD PTR [r12], 28
$LN15@inflate:

; 1211 :         case DONE:
; 1212 :             ret = Z_STREAM_END;
; 1213 :             goto inf_leave;

  01584	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
  01587	41 bd 01 00 00
	00		 mov	 r13d, 1
  0158d	eb 1b		 jmp	 SHORT $inf_leave$936
$LN14@inflate:
  0158f	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]

; 1214 :         case BAD:
; 1215 :             ret = Z_DATA_ERROR;

  01592	41 bd fd ff ff
	ff		 mov	 r13d, -3
  01598	eb 10		 jmp	 SHORT $inf_leave$936
$LN884@inflate:
  0159a	44 8b 6d 30	 mov	 r13d, DWORD PTR ret$1$[rbp-128]
  0159e	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
  015a1	eb 07		 jmp	 SHORT $inf_leave$936
$LN885@inflate:
  015a3	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
$LN930@inflate:
  015a6	44 8b 6d 30	 mov	 r13d, DWORD PTR ret$1$[rbp-128]
$inf_leave$936:

; 1222 :         }
; 1223 : 
; 1224 :     /*
; 1225 :        Return from inflate(), updating the total counts and the check value.
; 1226 :        If there was no progress during the inflate() call, return a buffer
; 1227 :        error.  Call updatewindow() to create and/or update the window state.
; 1228 :        Note: a memory error from inflate() is non-recoverable.
; 1229 :      */
; 1230 :   inf_leave:
; 1231 :     RESTORE();

  015aa	48 8b 7d 20	 mov	 rdi, QWORD PTR strm$[rbp-128]
  015ae	48 8b 45 c0	 mov	 rax, QWORD PTR put$1$[rbp-128]
  015b2	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  015b6	8b 45 38	 mov	 eax, DWORD PTR left$1$[rbp-128]
  015b9	4c 89 37	 mov	 QWORD PTR [rdi], r14
  015bc	89 47 18	 mov	 DWORD PTR [rdi+24], eax
  015bf	89 77 08	 mov	 DWORD PTR [rdi+8], esi

; 1232 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1233 :             (state->mode < CHECK || flush != Z_FINISH)))

  015c2	41 83 7c 24 2c
	00		 cmp	 DWORD PTR [r12+44], 0
  015c8	41 89 5c 24 44	 mov	 DWORD PTR [r12+68], ebx
  015cd	8b 5d b4	 mov	 ebx, DWORD PTR out$1$[rbp-128]
  015d0	45 89 7c 24 40	 mov	 DWORD PTR [r12+64], r15d
  015d5	75 18		 jne	 SHORT $LN6@inflate
  015d7	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  015da	74 3c		 je	 SHORT $LN5@inflate
  015dc	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  015e0	83 f8 1d	 cmp	 eax, 29
  015e3	7d 33		 jge	 SHORT $LN5@inflate
  015e5	83 f8 1a	 cmp	 eax, 26
  015e8	7c 05		 jl	 SHORT $LN6@inflate
  015ea	83 f9 04	 cmp	 ecx, 4
  015ed	74 29		 je	 SHORT $LN5@inflate
$LN6@inflate:

; 1234 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  015ef	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  015f3	44 8b c3	 mov	 r8d, ebx
  015f6	48 8b cf	 mov	 rcx, rdi
  015f9	44 2b 47 18	 sub	 r8d, DWORD PTR [rdi+24]
  015fd	e8 00 00 00 00	 call	 updatewindow
  01602	85 c0		 test	 eax, eax
  01604	74 12		 je	 SHORT $LN5@inflate

; 1235 :             state->mode = MEM;

  01606	41 c7 04 24 1e
	00 00 00	 mov	 DWORD PTR [r12], 30
$LN13@inflate:

; 1236 :             return Z_MEM_ERROR;

  0160e	b8 fc ff ff ff	 mov	 eax, -4
  01613	e9 39 ff ff ff	 jmp	 $LN919@inflate
$LN5@inflate:

; 1237 :         }
; 1238 :     in -= strm->avail_in;
; 1239 :     out -= strm->avail_out;

  01618	2b 5f 18	 sub	 ebx, DWORD PTR [rdi+24]
  0161b	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  0161f	44 2b 57 08	 sub	 r10d, DWORD PTR [rdi+8]

; 1240 :     strm->total_in += in;
; 1241 :     strm->total_out += out;

  01623	01 5f 1c	 add	 DWORD PTR [rdi+28], ebx
  01626	44 01 57 0c	 add	 DWORD PTR [rdi+12], r10d

; 1242 :     state->total += out;

  0162a	41 01 5c 24 1c	 add	 DWORD PTR [r12+28], ebx

; 1243 :     if (state->wrap && out)

  0162f	41 83 7c 24 08
	00		 cmp	 DWORD PTR [r12+8], 0
  01635	44 89 55 bc	 mov	 DWORD PTR in$1$[rbp-128], r10d
  01639	74 35		 je	 SHORT $LN4@inflate
  0163b	85 db		 test	 ebx, ebx
  0163d	74 31		 je	 SHORT $LN4@inflate

; 1244 :         strm->adler = state->check =
; 1245 :             UPDATE(state->check, strm->next_out - out, out);

  0163f	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  01643	41 8b 4c 24 18	 mov	 ecx, DWORD PTR [r12+24]
  01648	8b c3		 mov	 eax, ebx
  0164a	48 2b d0	 sub	 rdx, rax
  0164d	41 83 7c 24 10
	00		 cmp	 DWORD PTR [r12+16], 0
  01653	44 8b c3	 mov	 r8d, ebx
  01656	74 07		 je	 SHORT $LN508@inflate
  01658	e8 00 00 00 00	 call	 crc32
  0165d	eb 05		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  0165f	e8 00 00 00 00	 call	 adler32
$LN509@inflate:
  01664	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  01668	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  0166d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN4@inflate:

; 1246 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1247 :                       (state->mode == TYPE ? 128 : 0) +
; 1248 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  01670	41 8b 14 24	 mov	 edx, DWORD PTR [r12]
  01674	83 fa 13	 cmp	 edx, 19
  01677	74 0d		 je	 SHORT $LN510@inflate
  01679	83 fa 0e	 cmp	 edx, 14
  0167c	74 08		 je	 SHORT $LN510@inflate
  0167e	45 33 c9	 xor	 r9d, r9d
  01681	45 8b c1	 mov	 r8d, r9d
  01684	eb 09		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  01686	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0168c	45 33 c9	 xor	 r9d, r9d
$LN511@inflate:
  0168f	41 8b 44 24 04	 mov	 eax, DWORD PTR [r12+4]
  01694	f7 d8		 neg	 eax
  01696	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0169b	1b c9		 sbb	 ecx, ecx
  0169d	83 e1 40	 and	 ecx, 64			; 00000040H
  016a0	83 fa 0b	 cmp	 edx, 11
  016a3	44 0f 44 c8	 cmove	 r9d, eax
  016a7	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  016ab	44 03 c8	 add	 r9d, eax
  016ae	45 03 4c 24 44	 add	 r9d, DWORD PTR [r12+68]
  016b3	44 89 4f 48	 mov	 DWORD PTR [rdi+72], r9d

; 1249 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  016b7	45 85 d2	 test	 r10d, r10d
  016ba	75 04		 jne	 SHORT $LN1@inflate
  016bc	85 db		 test	 ebx, ebx
  016be	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  016c0	83 7d 28 04	 cmp	 DWORD PTR flush$[rbp-128], 4
  016c4	75 0c		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  016c6	b8 fb ff ff ff	 mov	 eax, -5
  016cb	45 85 ed	 test	 r13d, r13d
  016ce	44 0f 44 e8	 cmove	 r13d, eax
$LN3@inflate:

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;

  016d2	41 8b c5	 mov	 eax, r13d
  016d5	e9 77 fe ff ff	 jmp	 $LN919@inflate
$LN12@inflate:

; 1216 :             goto inf_leave;
; 1217 :         case MEM:
; 1218 :             return Z_MEM_ERROR;
; 1219 :         case SYNC:
; 1220 :         default:
; 1221 :             return Z_STREAM_ERROR;

  016da	b8 fe ff ff ff	 mov	 eax, -2
  016df	e9 6d fe ff ff	 jmp	 $LN919@inflate
$LN498@inflate:

; 630  :         return Z_STREAM_ERROR;

  016e4	b8 fe ff ff ff	 mov	 eax, -2

; 1252 : }

  016e9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  016f0	41 5c		 pop	 r12
  016f2	5f		 pop	 rdi
  016f3	5d		 pop	 rbp
  016f4	c3		 ret	 0
  016f5	0f 1f 00	 npad	 3
$LN793@inflate:
  016f8	00 00 00 00	 DD	 $LN489@inflate
  016fc	00 00 00 00	 DD	 $LN457@inflate
  01700	00 00 00 00	 DD	 $LN437@inflate
  01704	00 00 00 00	 DD	 $LN419@inflate
  01708	00 00 00 00	 DD	 $LN402@inflate
  0170c	00 00 00 00	 DD	 $LN381@inflate
  01710	00 00 00 00	 DD	 $LN374@inflate
  01714	00 00 00 00	 DD	 $LN362@inflate
  01718	00 00 00 00	 DD	 $LN350@inflate
  0171c	00 00 00 00	 DD	 $LN333@inflate
  01720	00 00 00 00	 DD	 $LN321@inflate
  01724	00 00 00 00	 DD	 $LN316@inflate
  01728	00 00 00 00	 DD	 $LN315@inflate
  0172c	00 00 00 00	 DD	 $LN282@inflate
  01730	00 00 00 00	 DD	 $LN266@inflate
  01734	00 00 00 00	 DD	 $LN264@inflate
  01738	00 00 00 00	 DD	 $LN258@inflate
  0173c	00 00 00 00	 DD	 $LN525@inflate
  01740	00 00 00 00	 DD	 $LN528@inflate
  01744	00 00 00 00	 DD	 $LN148@inflate
  01748	00 00 00 00	 DD	 $LN146@inflate
  0174c	00 00 00 00	 DD	 $LN113@inflate
  01750	00 00 00 00	 DD	 $LN537@inflate
  01754	00 00 00 00	 DD	 $LN76@inflate
  01758	00 00 00 00	 DD	 $LN62@inflate
  0175c	00 00 00 00	 DD	 $LN48@inflate
  01760	00 00 00 00	 DD	 $LN46@inflate
  01764	00 00 00 00	 DD	 $LN30@inflate
  01768	00 00 00 00	 DD	 $LN15@inflate
  0176c	00 00 00 00	 DD	 $LN14@inflate
  01770	00 00 00 00	 DD	 $LN13@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 8
inflateReset PROC					; COMDAT

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 17		 je	 SHORT $LN1@inflateRes
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 0e		 je	 SHORT $LN1@inflateRes

; 135  :     state = (struct inflate_state FAR *)strm->state;
; 136  :     state->wsize = 0;

  0000e	33 d2		 xor	 edx, edx
  00010	48 89 50 2c	 mov	 QWORD PTR [rax+44], rdx

; 137  :     state->whave = 0;
; 138  :     state->wnext = 0;

  00014	89 50 34	 mov	 DWORD PTR [rax+52], edx

; 139  :     return inflateResetKeep(strm);

  00017	e9 00 00 00 00	 jmp	 inflateResetKeep
$LN1@inflateRes:

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001c	b8 fe ff ff ff	 mov	 eax, -2

; 140  : }

  00021	c3		 ret	 0
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 185  : {

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 186  :     int ret;
; 187  :     struct inflate_state FAR *state;
; 188  : 
; 189  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 190  :         stream_size != (int)(sizeof(z_stream)))

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 b9 00 00
	00		 je	 $LN6@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 af 00 00
	00		 jne	 $LN6@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 a5 00 00
	00		 jne	 $LN6@inflateIni

; 192  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN5@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 220  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN5@inflateIni:
  0003f	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 193  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00044	33 ed		 xor	 ebp, ebp
  00046	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004b	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp

; 194  :     if (strm->zalloc == (alloc_func)0) {

  0004f	48 39 69 30	 cmp	 QWORD PTR [rcx+48], rbp
  00053	75 0f		 jne	 SHORT $LN4@inflateIni

; 195  : #ifdef Z_SOLO
; 196  :         return Z_STREAM_ERROR;
; 197  : #else
; 198  :         strm->zalloc = zcalloc;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 199  :         strm->opaque = (voidpf)0;

  0005c	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00060	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN4@inflateIni:

; 200  : #endif
; 201  :     }
; 202  :     if (strm->zfree == (free_func)0)

  00064	48 39 69 38	 cmp	 QWORD PTR [rcx+56], rbp
  00068	75 0b		 jne	 SHORT $LN3@inflateIni

; 203  : #ifdef Z_SOLO
; 204  :         return Z_STREAM_ERROR;
; 205  : #else
; 206  :         strm->zfree = zcfree;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00071	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@inflateIni:

; 207  : #endif
; 208  :     state = (struct inflate_state FAR *)
; 209  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00075	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00079	ba 01 00 00 00	 mov	 edx, 1
  0007e	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00084	ff 53 30	 call	 QWORD PTR [rbx+48]
  00087	48 8b f8	 mov	 rdi, rax

; 210  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0008a	48 85 c0	 test	 rax, rax
  0008d	75 18		 jne	 SHORT $LN2@inflateIni
  0008f	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN11@inflateIni:
  00092	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00097	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 220  : }

  0009c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
$LN2@inflateIni:

; 211  :     Tracev((stderr, "inflate: allocated\n"));
; 212  :     strm->state = (struct internal_state FAR *)state;

  000a7	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 213  :     state->window = Z_NULL;
; 214  :     ret = inflateReset2(strm, windowBits);

  000ab	8b d6		 mov	 edx, esi
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000b4	e8 00 00 00 00	 call	 inflateReset2
  000b9	8b f0		 mov	 esi, eax

; 215  :     if (ret != Z_OK) {

  000bb	85 c0		 test	 eax, eax
  000bd	74 0e		 je	 SHORT $LN1@inflateIni

; 216  :         ZFREE(strm, state);

  000bf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c3	48 8b d7	 mov	 rdx, rdi
  000c6	ff 53 38	 call	 QWORD PTR [rbx+56]

; 217  :         strm->state = Z_NULL;

  000c9	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN1@inflateIni:

; 218  :     }
; 219  :     return ret;

  000cd	8b c6		 mov	 eax, esi
  000cf	eb c1		 jmp	 SHORT $LN11@inflateIni
$LN6@inflateIni:

; 191  :         return Z_VERSION_ERROR;

  000d1	b8 fa ff ff ff	 mov	 eax, -6

; 220  : }

  000d6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5e		 pop	 rsi
  000e0	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 8
inflateResetKeep PROC					; COMDAT

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 6c		 je	 SHORT $LN2@inflateRes
  00005	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 63		 je	 SHORT $LN2@inflateRes

; 110  :     state = (struct inflate_state FAR *)strm->state;
; 111  :     strm->total_in = strm->total_out = state->total = 0;

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00015	44 89 41 1c	 mov	 DWORD PTR [rcx+28], r8d
  00019	44 89 41 0c	 mov	 DWORD PTR [rcx+12], r8d

; 112  :     strm->msg = Z_NULL;

  0001d	4c 89 41 20	 mov	 QWORD PTR [rcx+32], r8

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00021	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  00024	85 c0		 test	 eax, eax
  00026	74 06		 je	 SHORT $LN1@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  00028	83 e0 01	 and	 eax, 1
  0002b	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN1@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->dmax = 32768U;
; 119  :     state->head = Z_NULL;
; 120  :     state->hold = 0;
; 121  :     state->bits = 0;
; 122  :     state->lencode = state->distcode = state->next = state->codes;

  0002e	48 8d 82 48 05
	00 00		 lea	 rax, QWORD PTR [rdx+1352]
  00035	4c 89 02	 mov	 QWORD PTR [rdx], r8
  00038	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d
  0003c	48 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rax
  00043	48 89 42 60	 mov	 QWORD PTR [rdx+96], rax
  00047	48 89 42 58	 mov	 QWORD PTR [rdx+88], rax

; 123  :     state->sane = 1;
; 124  :     state->back = -1;
; 125  :     Tracev((stderr, "inflate: reset\n"));
; 126  :     return Z_OK;

  0004b	33 c0		 xor	 eax, eax
  0004d	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [rdx+20], 32768 ; 00008000H
  00054	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8
  00058	4c 89 42 40	 mov	 QWORD PTR [rdx+64], r8
  0005c	c7 82 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+7128], 1
  00066	c7 82 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rdx+7132], -1

; 127  : }

  00070	c3		 ret	 0
$LN2@inflateRes:

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00071	b8 fe ff ff ff	 mov	 eax, -2

; 127  : }

  00076	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 145  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b da		 mov	 ebx, edx
  00011	48 8b e9	 mov	 rbp, rcx

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00014	48 85 c9	 test	 rcx, rcx
  00017	74 7a		 je	 SHORT $LN7@inflateRes
  00019	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001d	48 85 ff	 test	 rdi, rdi
  00020	74 71		 je	 SHORT $LN7@inflateRes

; 151  :     state = (struct inflate_state FAR *)strm->state;
; 152  : 
; 153  :     /* extract wrap request from windowBits parameter */
; 154  :     if (windowBits < 0) {

  00022	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00027	85 d2		 test	 edx, edx
  00029	79 06		 jns	 SHORT $LN6@inflateRes

; 155  :         wrap = 0;

  0002b	33 f6		 xor	 esi, esi

; 156  :         windowBits = -windowBits;

  0002d	f7 db		 neg	 ebx

; 157  :     }
; 158  :     else {

  0002f	eb 0f		 jmp	 SHORT $LN4@inflateRes
$LN6@inflateRes:

; 159  :         wrap = (windowBits >> 4) + 1;

  00031	8b f2		 mov	 esi, edx
  00033	c1 fe 04	 sar	 esi, 4
  00036	ff c6		 inc	 esi

; 160  : #ifdef GUNZIP
; 161  :         if (windowBits < 48)

  00038	83 fa 30	 cmp	 edx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN4@inflateRes

; 162  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN4@inflateRes:
  00040	85 db		 test	 ebx, ebx
  00042	74 22		 je	 SHORT $LN3@inflateRes
  00044	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  00047	83 f8 07	 cmp	 eax, 7
  0004a	76 1a		 jbe	 SHORT $LN3@inflateRes

; 163  : #endif
; 164  :     }
; 165  : 
; 166  :     /* set number of window bits, free window if different */
; 167  :     if (windowBits && (windowBits < 8 || windowBits > 15))
; 168  :         return Z_STREAM_ERROR;

  0004c	b8 fe ff ff ff	 mov	 eax, -2
$LN12@inflateRes:
  00051	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 178  : }

  00056	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN3@inflateRes:

; 169  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00066	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0006a	48 85 d2	 test	 rdx, rdx
  0006d	74 14		 je	 SHORT $LN1@inflateRes
  0006f	39 5f 28	 cmp	 DWORD PTR [rdi+40], ebx
  00072	74 0f		 je	 SHORT $LN1@inflateRes

; 170  :         ZFREE(strm, state->window);

  00074	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00078	ff 55 38	 call	 QWORD PTR [rbp+56]

; 171  :         state->window = Z_NULL;

  0007b	48 c7 47 38 00
	00 00 00	 mov	 QWORD PTR [rdi+56], 0
$LN1@inflateRes:

; 172  :     }
; 173  : 
; 174  :     /* update state and reset the rest of it */
; 175  :     state->wrap = wrap;
; 176  :     state->wbits = (unsigned)windowBits;
; 177  :     return inflateReset(strm);

  00083	48 8b cd	 mov	 rcx, rbp
  00086	89 77 08	 mov	 DWORD PTR [rdi+8], esi
  00089	89 5f 28	 mov	 DWORD PTR [rdi+40], ebx
  0008c	e8 00 00 00 00	 call	 inflateReset
  00091	eb be		 jmp	 SHORT $LN12@inflateRes
$LN7@inflateRes:

; 178  : }

  00093	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00098	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009d	b8 fe ff ff ff	 mov	 eax, -2
  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 227  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
inflatePrime PROC					; COMDAT

; 234  : {

  00000	45 8b d8	 mov	 r11d, r8d

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 45		 je	 SHORT $LN4@inflatePri
  00008	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 3c		 je	 SHORT $LN4@inflatePri

; 238  :     state = (struct inflate_state FAR *)strm->state;
; 239  :     if (bits < 0) {

  00011	85 d2		 test	 edx, edx
  00013	79 07		 jns	 SHORT $LN3@inflatePri

; 240  :         state->hold = 0;

  00015	33 c0		 xor	 eax, eax
  00017	49 89 41 40	 mov	 QWORD PTR [r9+64], rax

; 249  : }

  0001b	c3		 ret	 0
$LN3@inflatePri:

; 241  :         state->bits = 0;
; 242  :         return Z_OK;
; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0001c	83 fa 10	 cmp	 edx, 16
  0001f	7f 2c		 jg	 SHORT $LN4@inflatePri
  00021	45 8b 41 44	 mov	 r8d, DWORD PTR [r9+68]
  00025	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  00029	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  0002d	77 1e		 ja	 SHORT $LN4@inflatePri

; 245  :     value &= (1L << bits) - 1;

  0002f	8b ca		 mov	 ecx, edx
  00031	b8 01 00 00 00	 mov	 eax, 1

; 246  :     state->hold += value << state->bits;
; 247  :     state->bits += bits;

  00036	45 89 51 44	 mov	 DWORD PTR [r9+68], r10d
  0003a	d3 e0		 shl	 eax, cl
  0003c	41 8b c8	 mov	 ecx, r8d
  0003f	ff c8		 dec	 eax
  00041	41 23 c3	 and	 eax, r11d
  00044	d3 e0		 shl	 eax, cl
  00046	41 01 41 40	 add	 DWORD PTR [r9+64], eax

; 248  :     return Z_OK;

  0004a	33 c0		 xor	 eax, eax

; 249  : }

  0004c	c3		 ret	 0
$LN4@inflatePri:

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0004d	b8 fe ff ff ff	 mov	 eax, -2

; 249  : }

  00052	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 264  : #ifdef BUILDFIXED
; 265  :     static int virgin = 1;
; 266  :     static code *lenfix, *distfix;
; 267  :     static code fixed[544];
; 268  : 
; 269  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 270  :     if (virgin) {
; 271  :         unsigned sym, bits;
; 272  :         static code *next;
; 273  : 
; 274  :         /* literal/length table */
; 275  :         sym = 0;
; 276  :         while (sym < 144) state->lens[sym++] = 8;
; 277  :         while (sym < 256) state->lens[sym++] = 9;
; 278  :         while (sym < 280) state->lens[sym++] = 7;
; 279  :         while (sym < 288) state->lens[sym++] = 8;
; 280  :         next = fixed;
; 281  :         lenfix = next;
; 282  :         bits = 9;
; 283  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 284  : 
; 285  :         /* distance table */
; 286  :         sym = 0;
; 287  :         while (sym < 32) state->lens[sym++] = 5;
; 288  :         distfix = next;
; 289  :         bits = 5;
; 290  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 291  : 
; 292  :         /* do this just once */
; 293  :         virgin = 0;
; 294  :     }
; 295  : #else /* !BUILDFIXED */
; 296  : #   include "inffixed.h"
; 297  : #endif /* BUILDFIXED */
; 298  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 299  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 300  :     state->distcode = distfix;
; 301  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 302  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
end$ = 56
copy$ = 64
updatewindow PROC					; COMDAT

; 383  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 384  :     struct inflate_state FAR *state;
; 385  :     unsigned dist;
; 386  : 
; 387  :     state = (struct inflate_state FAR *)strm->state;

  00014	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00018	41 8b e8	 mov	 ebp, r8d
  0001b	48 8b f2	 mov	 rsi, rdx

; 388  : 
; 389  :     /* if it hasn't been done already, allocate space for the window */
; 390  :     if (state->window == Z_NULL) {

  0001e	48 83 7b 38 00	 cmp	 QWORD PTR [rbx+56], 0
  00023	48 8b c1	 mov	 rax, rcx
  00026	bf 01 00 00 00	 mov	 edi, 1
  0002b	75 21		 jne	 SHORT $LN9@updatewind

; 391  :         state->window = (unsigned char FAR *)
; 392  :                         ZALLOC(strm, 1U << state->wbits,
; 393  :                                sizeof(unsigned char));

  0002d	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00030	8b d7		 mov	 edx, edi
  00032	44 8b c7	 mov	 r8d, edi
  00035	d3 e2		 shl	 edx, cl
  00037	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0003b	ff 50 30	 call	 QWORD PTR [rax+48]
  0003e	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 394  :         if (state->window == Z_NULL) return 1;

  00042	48 85 c0	 test	 rax, rax
  00045	75 07		 jne	 SHORT $LN9@updatewind
  00047	8b c7		 mov	 eax, edi
  00049	e9 9b 00 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
  0004e	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14

; 395  :     }
; 396  : 
; 397  :     /* if window not in use yet, initialize */
; 398  :     if (state->wsize == 0) {

  00053	45 33 f6	 xor	 r14d, r14d
  00056	44 39 73 2c	 cmp	 DWORD PTR [rbx+44], r14d
  0005a	75 0c		 jne	 SHORT $LN8@updatewind

; 399  :         state->wsize = 1U << state->wbits;

  0005c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 400  :         state->wnext = 0;
; 401  :         state->whave = 0;

  0005f	4c 89 73 30	 mov	 QWORD PTR [rbx+48], r14
  00063	d3 e7		 shl	 edi, cl
  00065	89 7b 2c	 mov	 DWORD PTR [rbx+44], edi
$LN8@updatewind:

; 402  :     }
; 403  : 
; 404  :     /* copy state->wsize or less output bytes into the circular window */
; 405  :     if (copy >= state->wsize) {

  00068	8b 7b 2c	 mov	 edi, DWORD PTR [rbx+44]
  0006b	3b ef		 cmp	 ebp, edi
  0006d	72 1b		 jb	 SHORT $LN7@updatewind

; 406  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0006f	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00073	48 2b f7	 sub	 rsi, rdi
  00076	44 8b c7	 mov	 r8d, edi
  00079	48 8b d6	 mov	 rdx, rsi
  0007c	e8 00 00 00 00	 call	 memcpy

; 407  :         state->wnext = 0;
; 408  :         state->whave = state->wsize;

  00081	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00084	44 89 73 34	 mov	 DWORD PTR [rbx+52], r14d

; 409  :     }
; 410  :     else {

  00088	eb 55		 jmp	 SHORT $LN13@updatewind
$LN7@updatewind:

; 411  :         dist = state->wsize - state->wnext;

  0008a	2b 7b 34	 sub	 edi, DWORD PTR [rbx+52]

; 412  :         if (dist > copy) dist = copy;
; 413  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0008d	8b 4b 34	 mov	 ecx, DWORD PTR [rbx+52]
  00090	48 8b d6	 mov	 rdx, rsi
  00093	3b fd		 cmp	 edi, ebp
  00095	0f 47 fd	 cmova	 edi, ebp
  00098	48 03 4b 38	 add	 rcx, QWORD PTR [rbx+56]
  0009c	48 2b d5	 sub	 rdx, rbp
  0009f	44 8b c7	 mov	 r8d, edi
  000a2	e8 00 00 00 00	 call	 memcpy

; 414  :         copy -= dist;

  000a7	2b ef		 sub	 ebp, edi

; 415  :         if (copy) {

  000a9	74 1a		 je	 SHORT $LN4@updatewind

; 416  :             zmemcpy(state->window, end - copy, copy);

  000ab	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000af	44 8b c5	 mov	 r8d, ebp
  000b2	49 2b f0	 sub	 rsi, r8
  000b5	48 8b d6	 mov	 rdx, rsi
  000b8	e8 00 00 00 00	 call	 memcpy

; 417  :             state->wnext = copy;
; 418  :             state->whave = state->wsize;

  000bd	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000c0	89 6b 34	 mov	 DWORD PTR [rbx+52], ebp

; 419  :         }
; 420  :         else {

  000c3	eb 1a		 jmp	 SHORT $LN13@updatewind
$LN4@updatewind:

; 421  :             state->wnext += dist;

  000c5	01 7b 34	 add	 DWORD PTR [rbx+52], edi

; 422  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c8	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000cb	3b 43 2c	 cmp	 eax, DWORD PTR [rbx+44]
  000ce	41 0f 44 c6	 cmove	 eax, r14d
  000d2	89 43 34	 mov	 DWORD PTR [rbx+52], eax

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  000d5	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  000d8	3b 43 2c	 cmp	 eax, DWORD PTR [rbx+44]
  000db	73 05		 jae	 SHORT $LN1@updatewind
  000dd	03 c7		 add	 eax, edi
$LN13@updatewind:
  000df	89 43 30	 mov	 DWORD PTR [rbx+48], eax
$LN1@updatewind:
  000e2	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000e7	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 427  : }

  000e9	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ee	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1272 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00015	48 85 c9	 test	 rcx, rcx
  00018	74 5b		 je	 SHORT $LN3@inflateGet
  0001a	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  0001e	48 85 db	 test	 rbx, rbx
  00021	74 52		 je	 SHORT $LN3@inflateGet

; 1277 :     state = (struct inflate_state FAR *)strm->state;
; 1278 : 
; 1279 :     /* copy dictionary */
; 1280 :     if (state->whave && dictionary != Z_NULL) {

  00023	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  00026	85 c0		 test	 eax, eax
  00028	74 2f		 je	 SHORT $LN2@inflateGet
  0002a	48 85 d2	 test	 rdx, rdx
  0002d	74 2a		 je	 SHORT $LN2@inflateGet

; 1281 :         zmemcpy(dictionary, state->window + state->wnext,
; 1282 :                 state->whave - state->wnext);

  0002f	8b 53 34	 mov	 edx, DWORD PTR [rbx+52]
  00032	48 8b ce	 mov	 rcx, rsi
  00035	2b c2		 sub	 eax, edx
  00037	48 03 53 38	 add	 rdx, QWORD PTR [rbx+56]
  0003b	44 8b c0	 mov	 r8d, eax
  0003e	e8 00 00 00 00	 call	 memcpy

; 1283 :         zmemcpy(dictionary + state->whave - state->wnext,
; 1284 :                 state->window, state->wnext);

  00043	44 8b 43 34	 mov	 r8d, DWORD PTR [rbx+52]
  00047	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  0004a	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  0004e	49 2b c8	 sub	 rcx, r8
  00051	48 03 ce	 add	 rcx, rsi
  00054	e8 00 00 00 00	 call	 memcpy
$LN2@inflateGet:

; 1285 :     }
; 1286 :     if (dictLength != Z_NULL)

  00059	48 85 ff	 test	 rdi, rdi
  0005c	74 05		 je	 SHORT $LN1@inflateGet

; 1287 :         *dictLength = state->whave;

  0005e	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  00061	89 07		 mov	 DWORD PTR [rdi], eax
$LN1@inflateGet:

; 1288 :     return Z_OK;

  00063	33 c0		 xor	 eax, eax

; 1289 : }

  00065	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
$LN3@inflateGet:
  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007f	b8 fe ff ff ff	 mov	 eax, -2
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1295 : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f0	 mov	 esi, r8d
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001d	48 85 c9	 test	 rcx, rcx
  00020	74 14		 je	 SHORT $LN5@inflateSet
  00022	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00026	48 85 db	 test	 rbx, rbx
  00029	74 0b		 je	 SHORT $LN5@inflateSet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if (state->wrap != 0 && state->mode != DICT)

  0002b	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0
  0002f	74 1f		 je	 SHORT $LN4@inflateSet
  00031	83 3b 0a	 cmp	 DWORD PTR [rbx], 10
  00034	74 1f		 je	 SHORT $LN9@inflateSet
$LN5@inflateSet:

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2
$LN7@inflateSet:

; 1324 : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00045	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN4@inflateSet:

; 1304 :         return Z_STREAM_ERROR;
; 1305 : 
; 1306 :     /* check for correct dictionary identifier */
; 1307 :     if (state->mode == DICT) {

  00050	83 3b 0a	 cmp	 DWORD PTR [rbx], 10
  00053	75 25		 jne	 SHORT $LN2@inflateSet
$LN9@inflateSet:

; 1308 :         dictid = adler32(0L, Z_NULL, 0);

  00055	45 33 c0	 xor	 r8d, r8d
  00058	33 d2		 xor	 edx, edx
  0005a	33 c9		 xor	 ecx, ecx
  0005c	e8 00 00 00 00	 call	 adler32

; 1309 :         dictid = adler32(dictid, dictionary, dictLength);

  00061	44 8b c6	 mov	 r8d, esi
  00064	48 8b d5	 mov	 rdx, rbp
  00067	8b c8		 mov	 ecx, eax
  00069	e8 00 00 00 00	 call	 adler32

; 1310 :         if (dictid != state->check)

  0006e	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  00071	74 07		 je	 SHORT $LN2@inflateSet

; 1311 :             return Z_DATA_ERROR;

  00073	b8 fd ff ff ff	 mov	 eax, -3
  00078	eb c1		 jmp	 SHORT $LN7@inflateSet
$LN2@inflateSet:

; 1312 :     }
; 1313 : 
; 1314 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1315 :        existing dictionary if appropriate */
; 1316 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0007a	48 8d 14 2e	 lea	 rdx, QWORD PTR [rsi+rbp]
  0007e	44 8b c6	 mov	 r8d, esi
  00081	48 8b cf	 mov	 rcx, rdi
  00084	e8 00 00 00 00	 call	 updatewindow

; 1317 :     if (ret) {

  00089	85 c0		 test	 eax, eax
  0008b	74 0d		 je	 SHORT $LN1@inflateSet

; 1318 :         state->mode = MEM;

  0008d	c7 03 1e 00 00
	00		 mov	 DWORD PTR [rbx], 30

; 1319 :         return Z_MEM_ERROR;

  00093	b8 fc ff ff ff	 mov	 eax, -4
  00098	eb a1		 jmp	 SHORT $LN7@inflateSet
$LN1@inflateSet:

; 1320 :     }
; 1321 :     state->havedict = 1;

  0009a	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1

; 1322 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1323 :     return Z_OK;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 96		 jmp	 SHORT $LN7@inflateSet
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
inflateGetHeader PROC					; COMDAT

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN2@inflateGet
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN2@inflateGet

; 1334 :     state = (struct inflate_state FAR *)strm->state;
; 1335 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0000e	f6 40 08 02	 test	 BYTE PTR [rax+8], 2
  00012	74 0e		 je	 SHORT $LN2@inflateGet

; 1336 : 
; 1337 :     /* save header structure */
; 1338 :     state->head = head;

  00014	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx

; 1339 :     head->done = 0;

  00018	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1340 :     return Z_OK;

  0001f	33 c0		 xor	 eax, eax

; 1341 : }

  00021	c3		 ret	 0
$LN2@inflateGet:

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1341 : }

  00027	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1358 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1359 :     unsigned got;
; 1360 :     unsigned next;
; 1361 : 
; 1362 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1363 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d8	 mov	 r11d, r8d
  0000c	4c 8b d1	 mov	 r10, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1364 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 46		 je	 SHORT $LN13@syncsearch
$LL6@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 35		 jae	 SHORT $LN14@syncsearch

; 1365 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1366 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 12		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1367 :         else if (buf[next])

  00034	45 84 c0	 test	 r8b, r8b
  00037	74 04		 je	 SHORT $LN2@syncsearch

; 1368 :             got = 0;

  00039	8b c3		 mov	 eax, ebx

; 1369 :         else

  0003b	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1370 :             got = 4 - got;

  0003d	b9 04 00 00 00	 mov	 ecx, 4
  00042	2b c8		 sub	 ecx, eax
  00044	8b c1		 mov	 eax, ecx
$LN1@syncsearch:

; 1371 :         next++;

  00046	41 ff c1	 inc	 r9d
  00049	48 ff c2	 inc	 rdx
  0004c	45 3b cb	 cmp	 r9d, r11d
  0004f	72 c6		 jb	 SHORT $LL6@syncsearch
$LN14@syncsearch:

; 1372 :     }
; 1373 :     *have = got;

  00051	41 89 02	 mov	 DWORD PTR [r10], eax

; 1374 :     return next;

  00054	41 8b c1	 mov	 eax, r9d

; 1375 : }

  00057	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005c	c3		 ret	 0
$LN13@syncsearch:
  0005d	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00062	89 01		 mov	 DWORD PTR [rcx], eax
  00064	41 8b c1	 mov	 eax, r9d
  00067	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
buf$ = 48
strm$ = 48
inflateSync PROC					; COMDAT

; 1379 : {

$LN17:
  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 e6 00 00
	00		 je	 $LN6@inflateSyn
  00016	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001a	48 85 ff	 test	 rdi, rdi
  0001d	0f 84 d9 00 00
	00		 je	 $LN6@inflateSyn

; 1387 :     state = (struct inflate_state FAR *)strm->state;
; 1388 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00023	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00027	75 16		 jne	 SHORT $LN5@inflateSyn
  00029	83 7f 44 08	 cmp	 DWORD PTR [rdi+68], 8
  0002d	73 10		 jae	 SHORT $LN5@inflateSyn
  0002f	b8 fb ff ff ff	 mov	 eax, -5

; 1418 : }

  00034	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@inflateSyn:

; 1389 : 
; 1390 :     /* if first time, start search in bit buffer */
; 1391 :     if (state->mode != SYNC) {

  0003f	83 3f 1f	 cmp	 DWORD PTR [rdi], 31
  00042	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00047	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0004c	74 55		 je	 SHORT $LN4@inflateSyn

; 1392 :         state->mode = SYNC;
; 1393 :         state->hold <<= state->bits & 7;

  0004e	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]

; 1394 :         state->bits -= state->bits & 7;
; 1395 :         len = 0;

  00051	45 33 c0	 xor	 r8d, r8d
  00054	c7 07 1f 00 00
	00		 mov	 DWORD PTR [rdi], 31
  0005a	8b ca		 mov	 ecx, edx
  0005c	83 e1 07	 and	 ecx, 7
  0005f	d3 67 40	 shl	 DWORD PTR [rdi+64], cl
  00062	2b d1		 sub	 edx, ecx
  00064	89 57 44	 mov	 DWORD PTR [rdi+68], edx

; 1396 :         while (state->bits >= 8) {

  00067	83 fa 08	 cmp	 edx, 8
  0006a	72 23		 jb	 SHORT $LN2@inflateSyn
  0006c	44 8b 4f 40	 mov	 r9d, DWORD PTR [rdi+64]
$LL3@inflateSyn:

; 1397 :             buf[len++] = (unsigned char)(state->hold);

  00070	0f b6 47 40	 movzx	 eax, BYTE PTR [rdi+64]

; 1398 :             state->hold >>= 8;

  00074	41 c1 e9 08	 shr	 r9d, 8

; 1399 :             state->bits -= 8;

  00078	83 c2 f8	 add	 edx, -8			; fffffff8H
  0007b	42 88 44 04 30	 mov	 BYTE PTR buf$[rsp+r8], al
  00080	41 ff c0	 inc	 r8d
  00083	44 89 4f 40	 mov	 DWORD PTR [rdi+64], r9d
  00087	83 fa 08	 cmp	 edx, 8
  0008a	73 e4		 jae	 SHORT $LL3@inflateSyn
  0008c	89 57 44	 mov	 DWORD PTR [rdi+68], edx
$LN2@inflateSyn:

; 1400 :         }
; 1401 :         state->have = 0;

  0008f	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]

; 1402 :         syncsearch(&(state->have), buf, len);

  00093	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  0009e	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn:

; 1403 :     }
; 1404 : 
; 1405 :     /* search available input */
; 1406 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000a3	44 8b 46 08	 mov	 r8d, DWORD PTR [rsi+8]
  000a7	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000aa	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]
  000ae	e8 00 00 00 00	 call	 syncsearch

; 1407 :     strm->avail_in -= len;
; 1408 :     strm->next_in += len;
; 1409 :     strm->total_in += len;

  000b3	01 46 0c	 add	 DWORD PTR [rsi+12], eax
  000b6	29 46 08	 sub	 DWORD PTR [rsi+8], eax
  000b9	8b 6e 0c	 mov	 ebp, DWORD PTR [rsi+12]
  000bc	8b c8		 mov	 ecx, eax
  000be	48 01 0e	 add	 QWORD PTR [rsi], rcx

; 1410 : 
; 1411 :     /* return no joy or set up to restart inflate() on a new block */
; 1412 :     if (state->have != 4) return Z_DATA_ERROR;

  000c1	83 7f 7c 04	 cmp	 DWORD PTR [rdi+124], 4
  000c5	74 1a		 je	 SHORT $LN1@inflateSyn
  000c7	b8 fd ff ff ff	 mov	 eax, -3
$LN15@inflateSyn:
  000cc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1418 : }

  000d6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
$LN1@inflateSyn:

; 1413 :     in = strm->total_in;  out = strm->total_out;

  000e1	8b 5e 1c	 mov	 ebx, DWORD PTR [rsi+28]

; 1414 :     inflateReset(strm);

  000e4	48 8b ce	 mov	 rcx, rsi
  000e7	e8 00 00 00 00	 call	 inflateReset

; 1415 :     strm->total_in = in;  strm->total_out = out;

  000ec	89 6e 0c	 mov	 DWORD PTR [rsi+12], ebp
  000ef	89 5e 1c	 mov	 DWORD PTR [rsi+28], ebx

; 1416 :     state->mode = TYPE;

  000f2	c7 07 0b 00 00
	00		 mov	 DWORD PTR [rdi], 11

; 1417 :     return Z_OK;

  000f8	33 c0		 xor	 eax, eax
  000fa	eb d0		 jmp	 SHORT $LN15@inflateSyn
$LN6@inflateSyn:

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000fc	b8 fe ff ff ff	 mov	 eax, -2

; 1418 : }

  00101	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00106	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010a	5f		 pop	 rdi
  0010b	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 8
inflateSyncPoint PROC					; COMDAT

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN1@inflateSyn
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN1@inflateSyn

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  0000e	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00011	75 0c		 jne	 SHORT $LN5@inflateSyn
  00013	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00017	75 06		 jne	 SHORT $LN5@inflateSyn
  00019	b8 01 00 00 00	 mov	 eax, 1

; 1436 : }

  0001e	c3		 ret	 0
$LN5@inflateSyn:

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  0001f	33 c0		 xor	 eax, eax

; 1436 : }

  00021	c3		 ret	 0
$LN1@inflateSyn:

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1436 : }

  00027	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1441 : {

$LN15:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00008	48 8b da	 mov	 rbx, rdx
  0000b	48 8b e9	 mov	 rbp, rcx

; 1442 :     struct inflate_state FAR *state;
; 1443 :     struct inflate_state FAR *copy;
; 1444 :     unsigned char FAR *window;
; 1445 :     unsigned wsize;
; 1446 : 
; 1447 :     /* check input */
; 1448 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1449 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	0f 84 16 02 00
	00		 je	 $LN6@inflateCop
  00017	48 85 d2	 test	 rdx, rdx
  0001a	0f 84 0d 02 00
	00		 je	 $LN6@inflateCop
  00020	48 8b 7a 28	 mov	 rdi, QWORD PTR [rdx+40]
  00024	48 85 ff	 test	 rdi, rdi
  00027	0f 84 00 02 00
	00		 je	 $LN6@inflateCop
  0002d	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00031	48 85 c0	 test	 rax, rax
  00034	0f 84 f3 01 00
	00		 je	 $LN6@inflateCop
  0003a	48 83 7a 38 00	 cmp	 QWORD PTR [rdx+56], 0
  0003f	0f 84 e8 01 00
	00		 je	 $LN6@inflateCop

; 1451 :     state = (struct inflate_state FAR *)source->state;
; 1452 : 
; 1453 :     /* allocate space */
; 1454 :     copy = (struct inflate_state FAR *)
; 1455 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00045	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00049	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0004e	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  00053	41 bf 01 00 00
	00		 mov	 r15d, 1
  00059	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  0005f	41 8b d7	 mov	 edx, r15d
  00062	ff d0		 call	 rax
  00064	48 8b f0	 mov	 rsi, rax

; 1456 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00067	48 85 c0	 test	 rax, rax
  0006a	75 05		 jne	 SHORT $LN5@inflateCop
  0006c	8d 46 fc	 lea	 eax, QWORD PTR [rsi-4]
  0006f	eb 3b		 jmp	 SHORT $LN12@inflateCop
$LN5@inflateCop:
  00071	4c 89 74 24 48	 mov	 QWORD PTR [rsp+72], r14

; 1457 :     window = Z_NULL;

  00076	45 33 f6	 xor	 r14d, r14d

; 1458 :     if (state->window != Z_NULL) {

  00079	4c 39 77 38	 cmp	 QWORD PTR [rdi+56], r14
  0007d	74 3f		 je	 SHORT $LN3@inflateCop

; 1459 :         window = (unsigned char FAR *)
; 1460 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007f	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]
  00082	41 8b d7	 mov	 edx, r15d
  00085	45 8b c7	 mov	 r8d, r15d
  00088	d3 e2		 shl	 edx, cl
  0008a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0008e	ff 53 30	 call	 QWORD PTR [rbx+48]
  00091	4c 8b f0	 mov	 r14, rax

; 1461 :         if (window == Z_NULL) {

  00094	48 85 c0	 test	 rax, rax
  00097	75 25		 jne	 SHORT $LN3@inflateCop

; 1462 :             ZFREE(source, copy);

  00099	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1463 :             return Z_MEM_ERROR;

  000a3	41 8d 46 fc	 lea	 eax, QWORD PTR [r14-4]
$LN13@inflateCop:
  000a7	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
$LN12@inflateCop:
  000ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b1	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 1483 : }

  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	5d		 pop	 rbp
  000bc	5b		 pop	 rbx
  000bd	c3		 ret	 0
$LN3@inflateCop:

; 1464 :         }
; 1465 :     }
; 1466 : 
; 1467 :     /* copy state */
; 1468 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000be	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]

; 1469 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000c1	48 8b ce	 mov	 rcx, rsi
  000c4	48 8b c7	 mov	 rax, rdi
  000c7	ba 37 00 00 00	 mov	 edx, 55			; 00000037H
  000cc	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  000d0	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  000d4	0f 11 4d 10	 movups	 XMMWORD PTR [rbp+16], xmm1
  000d8	0f 10 43 20	 movups	 xmm0, XMMWORD PTR [rbx+32]
  000dc	0f 11 45 20	 movups	 XMMWORD PTR [rbp+32], xmm0
  000e0	0f 10 4b 30	 movups	 xmm1, XMMWORD PTR [rbx+48]
  000e4	0f 11 4d 30	 movups	 XMMWORD PTR [rbp+48], xmm1
  000e8	0f 10 43 40	 movups	 xmm0, XMMWORD PTR [rbx+64]
  000ec	0f 11 45 40	 movups	 XMMWORD PTR [rbp+64], xmm0
  000f0	f2 0f 10 4b 50	 movsdx	 xmm1, QWORD PTR [rbx+80]
  000f5	f2 0f 11 4d 50	 movsdx	 QWORD PTR [rbp+80], xmm1
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL10@inflateCop:
  00100	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00103	48 8d 89 80 00
	00 00		 lea	 rcx, QWORD PTR [rcx+128]
  0010a	48 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [rax+128]
  00111	0f 11 41 80	 movups	 XMMWORD PTR [rcx-128], xmm0
  00115	0f 10 48 90	 movups	 xmm1, XMMWORD PTR [rax-112]
  00119	0f 11 49 90	 movups	 XMMWORD PTR [rcx-112], xmm1
  0011d	0f 10 40 a0	 movups	 xmm0, XMMWORD PTR [rax-96]
  00121	0f 11 41 a0	 movups	 XMMWORD PTR [rcx-96], xmm0
  00125	0f 10 48 b0	 movups	 xmm1, XMMWORD PTR [rax-80]
  00129	0f 11 49 b0	 movups	 XMMWORD PTR [rcx-80], xmm1
  0012d	0f 10 40 c0	 movups	 xmm0, XMMWORD PTR [rax-64]
  00131	0f 11 41 c0	 movups	 XMMWORD PTR [rcx-64], xmm0
  00135	0f 10 48 d0	 movups	 xmm1, XMMWORD PTR [rax-48]
  00139	0f 11 49 d0	 movups	 XMMWORD PTR [rcx-48], xmm1
  0013d	0f 10 40 e0	 movups	 xmm0, XMMWORD PTR [rax-32]
  00141	0f 11 41 e0	 movups	 XMMWORD PTR [rcx-32], xmm0
  00145	0f 10 48 f0	 movups	 xmm1, XMMWORD PTR [rax-16]
  00149	0f 11 49 f0	 movups	 XMMWORD PTR [rcx-16], xmm1
  0014d	48 ff ca	 dec	 rdx
  00150	75 ae		 jne	 SHORT $LL10@inflateCop
  00152	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00155	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00158	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0015c	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1
  00160	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  00164	0f 11 41 20	 movups	 XMMWORD PTR [rcx+32], xmm0
  00168	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  0016c	0f 11 49 30	 movups	 XMMWORD PTR [rcx+48], xmm1
  00170	0f 10 40 40	 movups	 xmm0, XMMWORD PTR [rax+64]
  00174	0f 11 41 40	 movups	 XMMWORD PTR [rcx+64], xmm0
  00178	0f 10 48 50	 movups	 xmm1, XMMWORD PTR [rax+80]
  0017c	0f 11 49 50	 movups	 XMMWORD PTR [rcx+80], xmm1
  00180	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00184	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1470 :     if (state->lencode >= state->codes &&
; 1471 :         state->lencode <= state->codes + ENOUGH - 1) {

  00188	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0018c	48 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [rdi+1352]
  00193	48 3b c8	 cmp	 rcx, rax
  00196	72 47		 jb	 SHORT $LN2@inflateCop
  00198	48 8d 87 d4 1b
	00 00		 lea	 rax, QWORD PTR [rdi+7124]
  0019f	48 3b c8	 cmp	 rcx, rax
  001a2	77 3b		 ja	 SHORT $LN2@inflateCop

; 1472 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  001a4	48 2b cf	 sub	 rcx, rdi
  001a7	48 8d 81 b8 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1352]
  001ae	48 c1 f8 02	 sar	 rax, 2
  001b2	48 05 52 01 00
	00		 add	 rax, 338		; 00000152H
  001b8	48 8d 04 86	 lea	 rax, QWORD PTR [rsi+rax*4]
  001bc	48 89 46 58	 mov	 QWORD PTR [rsi+88], rax

; 1473 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  001c0	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  001c4	48 2b c7	 sub	 rax, rdi
  001c7	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  001cd	48 c1 f8 02	 sar	 rax, 2
  001d1	48 05 52 01 00
	00		 add	 rax, 338		; 00000152H
  001d7	48 8d 04 86	 lea	 rax, QWORD PTR [rsi+rax*4]
  001db	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
$LN2@inflateCop:

; 1474 :     }
; 1475 :     copy->next = copy->codes + (state->next - state->codes);

  001df	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  001e6	48 2b c7	 sub	 rax, rdi
  001e9	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  001ef	48 c1 f8 02	 sar	 rax, 2
  001f3	48 05 52 01 00
	00		 add	 rax, 338		; 00000152H
  001f9	48 8d 04 86	 lea	 rax, QWORD PTR [rsi+rax*4]
  001fd	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 1476 :     if (window != Z_NULL) {

  00204	4d 85 f6	 test	 r14, r14
  00207	74 15		 je	 SHORT $LN1@inflateCop

; 1477 :         wsize = 1U << state->wbits;

  00209	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]

; 1478 :         zmemcpy(window, state->window, wsize);

  0020c	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00210	41 d3 e7	 shl	 r15d, cl
  00213	49 8b ce	 mov	 rcx, r14
  00216	45 8b c7	 mov	 r8d, r15d
  00219	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1479 :     }
; 1480 :     copy->window = window;

  0021e	4c 89 76 38	 mov	 QWORD PTR [rsi+56], r14

; 1481 :     dest->state = (struct internal_state FAR *)copy;
; 1482 :     return Z_OK;

  00222	33 c0		 xor	 eax, eax
  00224	48 89 75 28	 mov	 QWORD PTR [rbp+40], rsi
  00228	e9 7a fe ff ff	 jmp	 $LN13@inflateCop
$LN6@inflateCop:

; 1450 :         return Z_STREAM_ERROR;

  0022d	b8 fe ff ff ff	 mov	 eax, -2

; 1483 : }

  00232	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00236	5f		 pop	 rdi
  00237	5d		 pop	 rbp
  00238	5b		 pop	 rbx
  00239	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 8
subvert$ = 16
inflateUndermine PROC					; COMDAT

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 19		 je	 SHORT $LN1@inflateUnd
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 10		 je	 SHORT $LN1@inflateUnd

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     state->sane = !subvert;
; 1494 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1495 :     return Z_OK;
; 1496 : #else
; 1497 :     state->sane = 1;

  0000e	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 1498 :     return Z_DATA_ERROR;

  00018	b8 fd ff ff ff	 mov	 eax, -3

; 1499 : #endif
; 1500 : }

  0001d	c3		 ret	 0
$LN1@inflateUnd:

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001e	b8 fe ff ff ff	 mov	 eax, -2

; 1499 : #endif
; 1500 : }

  00023	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 8
inflateMark PROC					; COMDAT

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN1@inflateMar
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 3e		 je	 SHORT $LN1@inflateMar

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  0000e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00010	83 f9 0f	 cmp	 ecx, 15
  00013	75 0f		 jne	 SHORT $LN7@inflateMar
  00015	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00018	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  0001e	c1 e0 10	 shl	 eax, 16
  00021	03 c1		 add	 eax, ecx

; 1512 : }

  00023	c3		 ret	 0
$LN7@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  00024	83 f9 18	 cmp	 ecx, 24
  00027	75 15		 jne	 SHORT $LN5@inflateMar
  00029	8b 88 e0 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7136]
  0002f	2b 48 48	 sub	 ecx, DWORD PTR [rax+72]
  00032	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00038	c1 e0 10	 shl	 eax, 16
  0003b	03 c1		 add	 eax, ecx

; 1512 : }

  0003d	c3		 ret	 0
$LN5@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  0003e	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00044	33 c9		 xor	 ecx, ecx
  00046	c1 e0 10	 shl	 eax, 16
  00049	03 c1		 add	 eax, ecx

; 1512 : }

  0004b	c3		 ret	 0
$LN1@inflateMar:

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  0004c	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1512 : }

  00051	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
END
