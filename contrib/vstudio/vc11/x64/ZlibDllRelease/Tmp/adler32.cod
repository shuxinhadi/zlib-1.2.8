; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	adler32_combine
PUBLIC	adler32
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+200
	DD	imagerel $unwind$adler32_combine_
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 020501H
	DD	013405H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\adler32.c
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32	PROC						; COMDAT

; 70   :     unsigned long sum2;
; 71   :     unsigned n;
; 72   : 
; 73   :     /* split Adler-32 into component sums */
; 74   :     sum2 = (adler >> 16) & 0xffff;

  00000	44 8b c9	 mov	 r9d, ecx
  00003	4c 8b d2	 mov	 r10, rdx

; 75   :     adler &= 0xffff;

  00006	0f b7 c9	 movzx	 ecx, cx
  00009	41 c1 e9 10	 shr	 r9d, 16

; 76   : 
; 77   :     /* in case user likes doing a byte at a time, keep it fast */
; 78   :     if (len == 1) {

  0000d	41 83 f8 01	 cmp	 r8d, 1
  00011	75 35		 jne	 SHORT $LN18@adler32

; 79   :         adler += buf[0];

  00013	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00016	03 c8		 add	 ecx, eax

; 80   :         if (adler >= BASE)

  00018	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  0001e	72 06		 jb	 SHORT $LN17@adler32

; 81   :             adler -= BASE;

  00020	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH
$LN17@adler32:

; 82   :         sum2 += adler;

  00026	44 03 c9	 add	 r9d, ecx

; 83   :         if (sum2 >= BASE)

  00029	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00030	0f 82 92 02 00
	00		 jb	 $LN5@adler32

; 84   :             sum2 -= BASE;

  00036	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  0003d	41 c1 e1 10	 shl	 r9d, 16
  00041	44 0b c9	 or	 r9d, ecx
  00044	41 8b c1	 mov	 eax, r9d

; 133  : }

  00047	c3		 ret	 0
$LN18@adler32:

; 85   :         return adler | (sum2 << 16);
; 86   :     }
; 87   : 
; 88   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 89   :     if (buf == Z_NULL)

  00048	48 85 d2	 test	 rdx, rdx
  0004b	75 04		 jne	 SHORT $LN15@adler32

; 90   :         return 1L;

  0004d	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 133  : }

  00050	c3		 ret	 0
$LN15@adler32:

; 91   : 
; 92   :     /* in case short lengths are provided, keep it somewhat fast */
; 93   :     if (len < 16) {

  00051	41 83 f8 10	 cmp	 r8d, 16
  00055	73 40		 jae	 SHORT $LN22@adler32

; 94   :         while (len--) {

  00057	45 85 c0	 test	 r8d, r8d
  0005a	74 16		 je	 SHORT $LN26@adler32
  0005c	0f 1f 40 00	 npad	 4
$LL13@adler32:

; 95   :             adler += *buf++;

  00060	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00064	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00068	03 c8		 add	 ecx, eax

; 96   :             sum2 += adler;

  0006a	44 03 c9	 add	 r9d, ecx
  0006d	41 ff c8	 dec	 r8d
  00070	75 ee		 jne	 SHORT $LL13@adler32
$LN26@adler32:

; 97   :         }
; 98   :         if (adler >= BASE)

  00072	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00078	72 06		 jb	 SHORT $LN11@adler32

; 99   :             adler -= BASE;

  0007a	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH
$LN11@adler32:

; 100  :         MOD28(sum2);            /* only added so many BASE's */

  00080	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00085	41 f7 e1	 mul	 r9d
  00088	c1 ea 0f	 shr	 edx, 15

; 101  :         return adler | (sum2 << 16);

  0008b	6b c2 0f	 imul	 eax, edx, 15
  0008e	41 03 c1	 add	 eax, r9d
  00091	c1 e0 10	 shl	 eax, 16
  00094	0b c1		 or	 eax, ecx

; 133  : }

  00096	c3		 ret	 0
$LN22@adler32:

; 102  :     }
; 103  : 
; 104  :     /* do length NMAX blocks -- requires just one modulo operation */
; 105  :     while (len >= NMAX) {

  00097	41 81 f8 b0 15
	00 00		 cmp	 r8d, 5552		; 000015b0H
  0009e	0f 82 06 01 00
	00		 jb	 $LN9@adler32
  000a4	b8 af a9 6e 5e	 mov	 eax, 1584310703		; 5e6ea9afH
  000a9	41 f7 e0	 mul	 r8d
  000ac	c1 ea 0b	 shr	 edx, 11
  000af	44 8b da	 mov	 r11d, edx
  000b2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL10@adler32:

; 106  :         len -= NMAX;

  000c0	41 81 c0 50 ea
	ff ff		 add	 r8d, -5552		; ffffea50H

; 107  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000c7	ba 5b 01 00 00	 mov	 edx, 347		; 0000015bH
  000cc	0f 1f 40 00	 npad	 4
$LL8@adler32:

; 108  :         do {
; 109  :             DO16(buf);          /* 16 sums unrolled */

  000d0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]

; 110  :             buf += 16;

  000d4	49 83 c2 10	 add	 r10, 16
  000d8	03 c8		 add	 ecx, eax
  000da	41 0f b6 42 f1	 movzx	 eax, BYTE PTR [r10-15]
  000df	44 03 c9	 add	 r9d, ecx
  000e2	03 c8		 add	 ecx, eax
  000e4	41 0f b6 42 f2	 movzx	 eax, BYTE PTR [r10-14]
  000e9	44 03 c9	 add	 r9d, ecx
  000ec	03 c8		 add	 ecx, eax
  000ee	41 0f b6 42 f3	 movzx	 eax, BYTE PTR [r10-13]
  000f3	44 03 c9	 add	 r9d, ecx
  000f6	03 c8		 add	 ecx, eax
  000f8	41 0f b6 42 f4	 movzx	 eax, BYTE PTR [r10-12]
  000fd	44 03 c9	 add	 r9d, ecx
  00100	03 c8		 add	 ecx, eax
  00102	41 0f b6 42 f5	 movzx	 eax, BYTE PTR [r10-11]
  00107	44 03 c9	 add	 r9d, ecx
  0010a	03 c8		 add	 ecx, eax
  0010c	41 0f b6 42 f6	 movzx	 eax, BYTE PTR [r10-10]
  00111	44 03 c9	 add	 r9d, ecx
  00114	03 c8		 add	 ecx, eax
  00116	41 0f b6 42 f7	 movzx	 eax, BYTE PTR [r10-9]
  0011b	44 03 c9	 add	 r9d, ecx
  0011e	03 c8		 add	 ecx, eax
  00120	41 0f b6 42 f8	 movzx	 eax, BYTE PTR [r10-8]
  00125	44 03 c9	 add	 r9d, ecx
  00128	03 c8		 add	 ecx, eax
  0012a	41 0f b6 42 f9	 movzx	 eax, BYTE PTR [r10-7]
  0012f	44 03 c9	 add	 r9d, ecx
  00132	03 c8		 add	 ecx, eax
  00134	41 0f b6 42 fa	 movzx	 eax, BYTE PTR [r10-6]
  00139	44 03 c9	 add	 r9d, ecx
  0013c	03 c8		 add	 ecx, eax
  0013e	41 0f b6 42 fb	 movzx	 eax, BYTE PTR [r10-5]
  00143	44 03 c9	 add	 r9d, ecx
  00146	03 c8		 add	 ecx, eax
  00148	41 0f b6 42 fc	 movzx	 eax, BYTE PTR [r10-4]
  0014d	44 03 c9	 add	 r9d, ecx
  00150	03 c8		 add	 ecx, eax
  00152	41 0f b6 42 fd	 movzx	 eax, BYTE PTR [r10-3]
  00157	44 03 c9	 add	 r9d, ecx
  0015a	03 c8		 add	 ecx, eax
  0015c	41 0f b6 42 fe	 movzx	 eax, BYTE PTR [r10-2]
  00161	44 03 c9	 add	 r9d, ecx
  00164	03 c8		 add	 ecx, eax
  00166	41 0f b6 42 ff	 movzx	 eax, BYTE PTR [r10-1]
  0016b	44 03 c9	 add	 r9d, ecx
  0016e	03 c8		 add	 ecx, eax
  00170	44 03 c9	 add	 r9d, ecx

; 111  :         } while (--n);

  00173	ff ca		 dec	 edx
  00175	0f 85 55 ff ff
	ff		 jne	 $LL8@adler32

; 112  :         MOD(adler);

  0017b	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00180	f7 e1		 mul	 ecx
  00182	c1 ea 0f	 shr	 edx, 15
  00185	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  0018b	03 c8		 add	 ecx, eax

; 113  :         MOD(sum2);

  0018d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00192	41 f7 e1	 mul	 r9d
  00195	c1 ea 0f	 shr	 edx, 15
  00198	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  0019e	44 03 c8	 add	 r9d, eax
  001a1	49 ff cb	 dec	 r11
  001a4	0f 85 16 ff ff
	ff		 jne	 $LL10@adler32
$LN9@adler32:

; 114  :     }
; 115  : 
; 116  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 117  :     if (len) {                  /* avoid modulos if none remaining */

  001aa	45 85 c0	 test	 r8d, r8d
  001ad	0f 84 15 01 00
	00		 je	 $LN5@adler32

; 118  :         while (len >= 16) {

  001b3	41 83 f8 10	 cmp	 r8d, 16
  001b7	0f 82 c3 00 00
	00		 jb	 $LN25@adler32
  001bd	41 8b d0	 mov	 edx, r8d
  001c0	48 c1 ea 04	 shr	 rdx, 4
  001c4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@adler32:

; 119  :             len -= 16;
; 120  :             DO16(buf);

  001d0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001d4	41 83 c0 f0	 add	 r8d, -16		; fffffff0H

; 121  :             buf += 16;

  001d8	49 83 c2 10	 add	 r10, 16
  001dc	03 c8		 add	 ecx, eax
  001de	41 0f b6 42 f1	 movzx	 eax, BYTE PTR [r10-15]
  001e3	44 03 c9	 add	 r9d, ecx
  001e6	03 c8		 add	 ecx, eax
  001e8	41 0f b6 42 f2	 movzx	 eax, BYTE PTR [r10-14]
  001ed	44 03 c9	 add	 r9d, ecx
  001f0	03 c8		 add	 ecx, eax
  001f2	41 0f b6 42 f3	 movzx	 eax, BYTE PTR [r10-13]
  001f7	44 03 c9	 add	 r9d, ecx
  001fa	03 c8		 add	 ecx, eax
  001fc	41 0f b6 42 f4	 movzx	 eax, BYTE PTR [r10-12]
  00201	44 03 c9	 add	 r9d, ecx
  00204	03 c8		 add	 ecx, eax
  00206	41 0f b6 42 f5	 movzx	 eax, BYTE PTR [r10-11]
  0020b	44 03 c9	 add	 r9d, ecx
  0020e	03 c8		 add	 ecx, eax
  00210	41 0f b6 42 f6	 movzx	 eax, BYTE PTR [r10-10]
  00215	44 03 c9	 add	 r9d, ecx
  00218	03 c8		 add	 ecx, eax
  0021a	41 0f b6 42 f7	 movzx	 eax, BYTE PTR [r10-9]
  0021f	44 03 c9	 add	 r9d, ecx
  00222	03 c8		 add	 ecx, eax
  00224	41 0f b6 42 f8	 movzx	 eax, BYTE PTR [r10-8]
  00229	44 03 c9	 add	 r9d, ecx
  0022c	03 c8		 add	 ecx, eax
  0022e	41 0f b6 42 f9	 movzx	 eax, BYTE PTR [r10-7]
  00233	44 03 c9	 add	 r9d, ecx
  00236	03 c8		 add	 ecx, eax
  00238	41 0f b6 42 fa	 movzx	 eax, BYTE PTR [r10-6]
  0023d	44 03 c9	 add	 r9d, ecx
  00240	03 c8		 add	 ecx, eax
  00242	41 0f b6 42 fb	 movzx	 eax, BYTE PTR [r10-5]
  00247	44 03 c9	 add	 r9d, ecx
  0024a	03 c8		 add	 ecx, eax
  0024c	41 0f b6 42 fc	 movzx	 eax, BYTE PTR [r10-4]
  00251	44 03 c9	 add	 r9d, ecx
  00254	03 c8		 add	 ecx, eax
  00256	41 0f b6 42 fd	 movzx	 eax, BYTE PTR [r10-3]
  0025b	44 03 c9	 add	 r9d, ecx
  0025e	03 c8		 add	 ecx, eax
  00260	41 0f b6 42 fe	 movzx	 eax, BYTE PTR [r10-2]
  00265	44 03 c9	 add	 r9d, ecx
  00268	03 c8		 add	 ecx, eax
  0026a	41 0f b6 42 ff	 movzx	 eax, BYTE PTR [r10-1]
  0026f	44 03 c9	 add	 r9d, ecx
  00272	03 c8		 add	 ecx, eax
  00274	44 03 c9	 add	 r9d, ecx
  00277	48 ff ca	 dec	 rdx
  0027a	0f 85 50 ff ff
	ff		 jne	 $LL4@adler32
$LN25@adler32:

; 122  :         }
; 123  :         while (len--) {

  00280	45 85 c0	 test	 r8d, r8d
  00283	74 1d		 je	 SHORT $LN30@adler32
  00285	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@adler32:

; 124  :             adler += *buf++;

  00290	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00294	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00298	03 c8		 add	 ecx, eax

; 125  :             sum2 += adler;

  0029a	44 03 c9	 add	 r9d, ecx
  0029d	41 ff c8	 dec	 r8d
  002a0	75 ee		 jne	 SHORT $LL2@adler32
$LN30@adler32:

; 126  :         }
; 127  :         MOD(adler);

  002a2	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002a7	f7 e1		 mul	 ecx
  002a9	c1 ea 0f	 shr	 edx, 15
  002ac	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  002b2	03 c8		 add	 ecx, eax

; 128  :         MOD(sum2);

  002b4	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002b9	41 f7 e1	 mul	 r9d
  002bc	c1 ea 0f	 shr	 edx, 15
  002bf	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  002c5	44 03 c8	 add	 r9d, eax
$LN5@adler32:

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  002c8	41 c1 e1 10	 shl	 r9d, 16
  002cc	44 0b c9	 or	 r9d, ecx
  002cf	41 8b c1	 mov	 eax, r9d

; 133  : }

  002d2	c3		 ret	 0
adler32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\adler32.c
;	COMDAT adler32_combine_
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine_ PROC					; COMDAT

; 140  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4d 8b d0	 mov	 r10, r8
  00008	8b da		 mov	 ebx, edx
  0000a	44 8b d9	 mov	 r11d, ecx

; 141  :     unsigned long sum1;
; 142  :     unsigned long sum2;
; 143  :     unsigned rem;
; 144  : 
; 145  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 146  :     if (len2 < 0)

  0000d	4d 85 c0	 test	 r8, r8
  00010	79 09		 jns	 SHORT $LN5@adler32_co

; 147  :         return 0xffffffffUL;

  00012	83 c8 ff	 or	 eax, -1			; ffffffffH

; 161  :     return sum1 | (sum2 << 16);
; 162  : }

  00015	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0001a	c3		 ret	 0
$LN5@adler32_co:

; 148  : 
; 149  :     /* the derivation of this formula is left as an exercise for the reader */
; 150  :     MOD63(len2);                /* assumes len2 >= 0 */
; 151  :     rem = (unsigned)len2;
; 152  :     sum1 = adler1 & 0xffff;
; 153  :     sum2 = rem * sum1;
; 154  :     MOD(sum2);
; 155  :     sum1 += (adler2 & 0xffff) + BASE - 1;
; 156  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  0001b	41 c1 eb 10	 shr	 r11d, 16
  0001f	0f b7 c9	 movzx	 ecx, cx
  00022	48 b8 e7 e2 97
	86 70 80 07 80	 mov	 rax, -9221260491235007769 ; 800780708697e2e7H
  0002c	44 0f b7 cb	 movzx	 r9d, bx
  00030	c1 eb 10	 shr	 ebx, 16
  00033	49 f7 ea	 imul	 r10
  00036	49 03 d0	 add	 rdx, r8
  00039	41 81 c1 f0 ff
	00 00		 add	 r9d, 65520		; 0000fff0H
  00040	48 c1 fa 0f	 sar	 rdx, 15
  00044	44 8b c1	 mov	 r8d, ecx
  00047	44 03 c9	 add	 r9d, ecx
  0004a	48 8b c2	 mov	 rax, rdx
  0004d	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00051	48 03 d0	 add	 rdx, rax
  00054	69 c2 f1 ff 00
	00		 imul	 eax, edx, 65521		; 0000fff1H
  0005a	44 2b d0	 sub	 r10d, eax
  0005d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00062	45 0f af c2	 imul	 r8d, r10d
  00066	41 f7 e0	 mul	 r8d
  00069	c1 ea 0f	 shr	 edx, 15
  0006c	69 c2 f1 ff 00
	00		 imul	 eax, edx, 65521		; 0000fff1H
  00072	44 2b d8	 sub	 r11d, eax
  00075	42 8d 04 1b	 lea	 eax, DWORD PTR [rbx+r11]
  00079	41 2b c2	 sub	 eax, r10d
  0007c	05 f1 ff 00 00	 add	 eax, 65521		; 0000fff1H
  00081	41 03 c0	 add	 eax, r8d

; 157  :     if (sum1 >= BASE) sum1 -= BASE;

  00084	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  0008b	72 17		 jb	 SHORT $LN3@adler32_co
  0008d	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH

; 158  :     if (sum1 >= BASE) sum1 -= BASE;

  00094	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  0009b	72 07		 jb	 SHORT $LN3@adler32_co
  0009d	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH
$LN3@adler32_co:

; 159  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  000a4	3d e2 ff 01 00	 cmp	 eax, 131042		; 0001ffe2H
  000a9	72 05		 jb	 SHORT $LN2@adler32_co
  000ab	05 1e 00 fe ff	 add	 eax, -131042		; fffe001eH
$LN2@adler32_co:

; 160  :     if (sum2 >= BASE) sum2 -= BASE;

  000b0	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  000b5	72 05		 jb	 SHORT $LN1@adler32_co
  000b7	05 0f 00 ff ff	 add	 eax, -65521		; ffff000fH
$LN1@adler32_co:

; 161  :     return sum1 | (sum2 << 16);
; 162  : }

  000bc	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000c1	c1 e0 10	 shl	 eax, 16
  000c4	41 0b c1	 or	 eax, r9d
  000c7	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\adler32.c
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine PROC					; COMDAT

; 170  :     return adler32_combine_(adler1, adler2, len2);

  00000	4d 63 c0	 movsxd	 r8, r8d
  00003	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine ENDP
_TEXT	ENDS
END
