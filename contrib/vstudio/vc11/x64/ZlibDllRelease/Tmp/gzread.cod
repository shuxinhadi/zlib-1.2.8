; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp__close:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_memchr:PROC
EXTRN	__imp_strerror:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
PUBLIC	gzdirect
PUBLIC	gzgets
PUBLIC	gzungetc
PUBLIC	gzgetc_
PUBLIC	gzgetc
PUBLIC	gzread
PUBLIC	gzclose_r
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN6
	DD	imagerel $LN6+56
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzgets DD imagerel $LN32+107
	DD	imagerel $LN32+304
	DD	imagerel $chain$3$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzgets DD imagerel $LN32+304
	DD	imagerel $LN32+308
	DD	imagerel $chain$5$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gzgets DD imagerel $LN32+308
	DD	imagerel $LN32+320
	DD	imagerel $chain$6$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN19
	DD	imagerel $LN19+267
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN10
	DD	imagerel $LN10+107
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN41
	DD	imagerel $LN41+91
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzread DD imagerel $LN41+91
	DD	imagerel $LN41+139
	DD	imagerel $chain$0$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzread DD imagerel $LN41+139
	DD	imagerel $LN41+419
	DD	imagerel $chain$5$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+119
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_fetch DD imagerel gz_fetch
	DD	imagerel gz_fetch+165
	DD	imagerel $unwind$gz_fetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+270
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_look DD imagerel gz_look
	DD	imagerel gz_look+40
	DD	imagerel $unwind$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_look DD imagerel gz_look+40
	DD	imagerel gz_look+87
	DD	imagerel $chain$0$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_look DD imagerel gz_look+87
	DD	imagerel gz_look+451
	DD	imagerel $chain$1$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+144
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+149
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$gzclose_r
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 063001H
	DD	077430H
	DD	06342bH
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_look DD 021H
	DD	imagerel gz_look
	DD	imagerel gz_look+40
	DD	imagerel $unwind$gz_look
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_look DD 020521H
	DD	063405H
	DD	imagerel gz_look
	DD	imagerel gz_look+40
	DD	imagerel $unwind$gz_look
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_look DD 081501H
	DD	097415H
	DD	086415H
	DD	075415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_fetch DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzread DD 081221H
	DD	0c7412H
	DD	04f40aH
	DD	0b6405H
	DD	05c400H
	DD	imagerel $LN41
	DD	imagerel $LN41+91
	DD	imagerel $unwind$gzread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzread DD 020521H
	DD	05c405H
	DD	imagerel $LN41
	DD	imagerel $LN41+91
	DD	imagerel $unwind$gzread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 040901H
	DD	0e0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gzgets DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzgets DD 080021H
	DD	0bc400H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzgets DD 081421H
	DD	0bc414H
	DD	0a740fH
	DD	09540aH
	DD	083405H
	DD	imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 040a01H
	DD	0f006320aH
	DD	06002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzclose_r
_TEXT	SEGMENT
file$ = 48
gzclose_r PROC						; COMDAT

; 569  : {

$LN8:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 570  :     int ret, err;
; 571  :     gz_statep state;
; 572  : 
; 573  :     /* get internal structure */
; 574  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0b		 jne	 SHORT $LN3@gzclose_r
$LN6@gzclose_r:

; 575  :         return Z_STREAM_ERROR;

  0000e	b8 fe ff ff ff	 mov	 eax, -2

; 594  : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5e		 pop	 rsi
  00018	c3		 ret	 0
$LN3@gzclose_r:

; 576  :     state = (gz_statep)file;
; 577  : 
; 578  :     /* check that we're reading */
; 579  :     if (state->mode != GZ_READ)

  00019	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00020	75 ec		 jne	 SHORT $LN6@gzclose_r

; 580  :         return Z_STREAM_ERROR;
; 581  : 
; 582  :     /* free memory and close file */
; 583  :     if (state->size) {

  00022	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00026	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002b	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00030	74 1d		 je	 SHORT $LN1@gzclose_r

; 584  :         inflateEnd(&(state->strm));

  00032	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00036	e8 00 00 00 00	 call	 inflateEnd

; 585  :         free(state->out);

  0003b	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 586  :         free(state->in);

  00045	48 8b 4e 30	 mov	 rcx, QWORD PTR [rsi+48]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@gzclose_r:

; 587  :     }
; 588  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  0004f	b8 fb ff ff ff	 mov	 eax, -5
  00054	33 ff		 xor	 edi, edi

; 589  :     gz_error(state, Z_OK, NULL);

  00056	48 8b ce	 mov	 rcx, rsi
  00059	39 46 6c	 cmp	 DWORD PTR [rsi+108], eax
  0005c	0f 44 f8	 cmove	 edi, eax
  0005f	45 33 c0	 xor	 r8d, r8d
  00062	33 d2		 xor	 edx, edx
  00064	e8 00 00 00 00	 call	 gz_error

; 590  :     free(state->path);

  00069	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 591  :     ret = close(state->fd);

  00073	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close

; 592  :     free(state);

  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	8b d8		 mov	 ebx, eax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 593  :     return ret ? Z_ERRNO : err;

  00087	83 c8 ff	 or	 eax, -1
  0008a	85 db		 test	 ebx, ebx
  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	0f 45 f8	 cmovne	 edi, eax
  00094	8b c7		 mov	 eax, edi
  00096	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 594  : }

  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5e		 pop	 rsi
  000a0	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gz_load
_TEXT	SEGMENT
state$ = 48
buf$ = 56
len$ = 64
have$ = 72
gz_load	PROC						; COMDAT

; 25   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b d9	 mov	 rbx, r9
  00017	41 8b f8	 mov	 edi, r8d
  0001a	48 8b ea	 mov	 rbp, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 26   :     int ret;
; 27   : 
; 28   :     *have = 0;

  00020	41 c7 01 00 00
	00 00		 mov	 DWORD PTR [r9], 0
  00027	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@gz_load:

; 29   :     do {
; 30   :         ret = read(state->fd, buf + *have, len - *have);

  00030	8b 13		 mov	 edx, DWORD PTR [rbx]
  00032	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00035	44 8b c7	 mov	 r8d, edi
  00038	44 2b c2	 sub	 r8d, edx
  0003b	48 03 d5	 add	 rdx, rbp
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__read

; 31   :         if (ret <= 0)

  00044	85 c0		 test	 eax, eax
  00046	7e 08		 jle	 SHORT $LN13@gz_load

; 32   :             break;
; 33   :         *have += ret;

  00048	01 03		 add	 DWORD PTR [rbx], eax

; 34   :     } while (*have < len);

  0004a	39 3b		 cmp	 DWORD PTR [rbx], edi
  0004c	72 e2		 jb	 SHORT $LL6@gz_load

; 35   :     if (ret < 0) {

  0004e	85 c0		 test	 eax, eax
$LN13@gz_load:
  00050	79 21		 jns	 SHORT $LN2@gz_load

; 36   :         gz_error(state, Z_ERRNO, zstrerror());

  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00058	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00060	83 ca ff	 or	 edx, -1
  00063	48 8b ce	 mov	 rcx, rsi
  00066	4c 8b c0	 mov	 r8, rax
  00069	e8 00 00 00 00	 call	 gz_error

; 37   :         return -1;

  0006e	83 c8 ff	 or	 eax, -1
  00071	eb 0d		 jmp	 SHORT $LN7@gz_load
$LN2@gz_load:

; 38   :     }
; 39   :     if (ret == 0)

  00073	85 c0		 test	 eax, eax
  00075	75 07		 jne	 SHORT $LN1@gz_load

; 40   :         state->eof = 1;

  00077	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [rsi+80], 1
$LN1@gz_load:

; 41   :     return 0;

  0007e	33 c0		 xor	 eax, eax
$LN7@gz_load:

; 42   : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
gz_load	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gz_avail
_TEXT	SEGMENT
got$ = 48
state$ = 48
gz_avail PROC						; COMDAT

; 53   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 54   :     unsigned got;
; 55   :     z_streamp strm = &(state->strm);
; 56   : 
; 57   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00006	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	85 c0		 test	 eax, eax
  0000e	74 0e		 je	 SHORT $LN7@gz_avail
  00010	83 f8 fb	 cmp	 eax, -5
  00013	74 09		 je	 SHORT $LN7@gz_avail
$LN13@gz_avail:

; 58   :         return -1;

  00015	83 c8 ff	 or	 eax, -1

; 75   : }

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN7@gz_avail:

; 59   :     if (state->eof == 0) {

  0001e	83 79 50 00	 cmp	 DWORD PTR [rcx+80], 0
  00022	75 64		 jne	 SHORT $LN6@gz_avail

; 60   :         if (strm->avail_in) {       /* copy what's there to the start */

  00024	44 8b 81 80 00
	00 00		 mov	 r8d, DWORD PTR [rcx+128]
  0002b	45 85 c0	 test	 r8d, r8d
  0002e	74 23		 je	 SHORT $LN2@gz_avail

; 61   :             unsigned char *p = state->in;

  00030	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]

; 62   :             unsigned const char *q = strm->next_in;

  00034	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@gz_avail:

; 63   :             unsigned n = strm->avail_in;
; 64   :             do {
; 65   :                 *p++ = *q++;

  00040	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00043	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00047	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  0004b	88 41 ff	 mov	 BYTE PTR [rcx-1], al

; 66   :             } while (--n);

  0004e	41 ff c8	 dec	 r8d
  00051	75 ed		 jne	 SHORT $LL4@gz_avail
$LN2@gz_avail:

; 67   :         }
; 68   :         if (gz_load(state, state->in + strm->avail_in,
; 69   :                     state->size - strm->avail_in, &got) == -1)

  00053	8b 93 80 00 00
	00		 mov	 edx, DWORD PTR [rbx+128]
  00059	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0005d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR got$[rsp]
  00062	44 2b c2	 sub	 r8d, edx
  00065	48 03 53 30	 add	 rdx, QWORD PTR [rbx+48]
  00069	48 8b cb	 mov	 rcx, rbx
  0006c	e8 00 00 00 00	 call	 gz_load
  00071	83 f8 ff	 cmp	 eax, -1
  00074	74 9f		 je	 SHORT $LN13@gz_avail

; 70   :             return -1;
; 71   :         strm->avail_in += got;

  00076	8b 44 24 30	 mov	 eax, DWORD PTR got$[rsp]
  0007a	01 83 80 00 00
	00		 add	 DWORD PTR [rbx+128], eax

; 72   :         strm->next_in = state->in;

  00080	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00084	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN6@gz_avail:

; 73   :     }
; 74   :     return 0;

  00088	33 c0		 xor	 eax, eax

; 75   : }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5b		 pop	 rbx
  0008f	c3		 ret	 0
gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gz_look
_TEXT	SEGMENT
state$ = 48
gz_look	PROC						; COMDAT

; 88   : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 89   :     z_streamp strm = &(state->strm);
; 90   : 
; 91   :     /* allocate read buffers and inflate memory */
; 92   :     if (state->size == 0) {

  00015	45 33 f6	 xor	 r14d, r14d
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 39 71 28	 cmp	 DWORD PTR [rcx+40], r14d
  0001f	0f 85 e6 00 00
	00		 jne	 $LN7@gz_look

; 93   :         /* allocate buffers */
; 94   :         state->in = (unsigned char *)malloc(state->want);

  00025	8b 69 2c	 mov	 ebp, DWORD PTR [rcx+44]
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002d	8b cd		 mov	 ecx, ebp
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 95   :         state->out = (unsigned char *)malloc(state->want << 1);

  00035	8d 0c 6d 00 00
	00 00		 lea	 ecx, DWORD PTR [rbp*2]
  0003c	48 8b d8	 mov	 rbx, rax
  0003f	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 96   :         if (state->in == NULL || state->out == NULL) {

  00049	48 85 db	 test	 rbx, rbx
  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
  00055	74 7b		 je	 SHORT $LN10@gz_look
  00057	48 85 c0	 test	 rax, rax
  0005a	0f 84 80 00 00
	00		 je	 $LN9@gz_look

; 103  :         }
; 104  :         state->size = state->want;
; 105  : 
; 106  :         /* allocate inflate memory */
; 107  :         state->strm.zalloc = Z_NULL;
; 108  :         state->strm.zfree = Z_NULL;
; 109  :         state->strm.opaque = Z_NULL;
; 110  :         state->strm.avail_in = 0;
; 111  :         state->strm.next_in = Z_NULL;
; 112  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  00060	45 8d 4e 58	 lea	 r9d, QWORD PTR [r14+88]
  00064	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05IAIEPMAK@1?42?48?$AA@
  0006b	41 8d 56 1f	 lea	 edx, QWORD PTR [r14+31]
  0006f	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00073	89 6f 28	 mov	 DWORD PTR [rdi+40], ebp
  00076	4c 89 b7 a8 00
	00 00		 mov	 QWORD PTR [rdi+168], r14
  0007d	4c 89 b7 b0 00
	00 00		 mov	 QWORD PTR [rdi+176], r14
  00084	4c 89 b7 b8 00
	00 00		 mov	 QWORD PTR [rdi+184], r14
  0008b	44 89 b7 80 00
	00 00		 mov	 DWORD PTR [rdi+128], r14d
  00092	4c 89 77 78	 mov	 QWORD PTR [rdi+120], r14
  00096	e8 00 00 00 00	 call	 inflateInit2_
  0009b	85 c0		 test	 eax, eax
  0009d	74 6c		 je	 SHORT $LN7@gz_look

; 113  :             free(state->out);

  0009f	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 114  :             free(state->in);

  000a9	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 115  :             state->size = 0;
; 116  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000ba	41 8d 56 fc	 lea	 edx, QWORD PTR [r14-4]
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	44 89 77 28	 mov	 DWORD PTR [rdi+40], r14d
  000c5	e8 00 00 00 00	 call	 gz_error

; 117  :             return -1;

  000ca	83 c8 ff	 or	 eax, -1
  000cd	e9 db 00 00 00	 jmp	 $LN13@gz_look
$LN10@gz_look:

; 97   :             if (state->out != NULL)

  000d2	48 85 c0	 test	 rax, rax
  000d5	74 09		 je	 SHORT $LN9@gz_look

; 98   :                 free(state->out);

  000d7	48 8b c8	 mov	 rcx, rax
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@gz_look:

; 99   :             if (state->in != NULL)

  000e0	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  000e4	48 85 c9	 test	 rcx, rcx
  000e7	74 06		 je	 SHORT $LN8@gz_look

; 100  :                 free(state->in);

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gz_look:

; 101  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000f6	ba fc ff ff ff	 mov	 edx, -4
  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	e8 00 00 00 00	 call	 gz_error
$LN16@gz_look:

; 102  :             return -1;

  00103	83 c8 ff	 or	 eax, -1
  00106	e9 a2 00 00 00	 jmp	 $LN13@gz_look
$LN7@gz_look:

; 118  :         }
; 119  :     }
; 120  : 
; 121  :     /* get at least the magic bytes in the input buffer */
; 122  :     if (strm->avail_in < 2) {

  0010b	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  00111	83 f8 02	 cmp	 eax, 2
  00114	73 17		 jae	 SHORT $LN4@gz_look

; 123  :         if (gz_avail(state) == -1)

  00116	48 8b cf	 mov	 rcx, rdi
  00119	e8 00 00 00 00	 call	 gz_avail
  0011e	83 f8 ff	 cmp	 eax, -1
  00121	74 e0		 je	 SHORT $LN16@gz_look

; 124  :             return -1;
; 125  :         if (strm->avail_in == 0)

  00123	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  00129	85 c0		 test	 eax, eax
  0012b	74 7e		 je	 SHORT $LN15@gz_look
$LN4@gz_look:

; 126  :             return 0;
; 127  :     }
; 128  : 
; 129  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 130  :        a logical dilemma here when considering the case of a partially written
; 131  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 132  :        whether this is a single-byte file, or just a partially written gzip
; 133  :        file -- for here we assume that if a gzip file is being written, then
; 134  :        the header will be written in a single operation, so that reading a
; 135  :        single byte is sufficient indication that it is not a gzip file) */
; 136  :     if (strm->avail_in > 1 &&
; 137  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  0012d	83 f8 01	 cmp	 eax, 1
  00130	76 25		 jbe	 SHORT $LN3@gz_look
  00132	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]
  00136	80 38 1f	 cmp	 BYTE PTR [rax], 31
  00139	75 1c		 jne	 SHORT $LN3@gz_look
  0013b	80 78 01 8b	 cmp	 BYTE PTR [rax+1], 139	; 0000008bH
  0013f	75 16		 jne	 SHORT $LN3@gz_look

; 138  :         inflateReset(strm);

  00141	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00145	e8 00 00 00 00	 call	 inflateReset

; 139  :         state->how = GZIP;

  0014a	c7 47 44 02 00
	00 00		 mov	 DWORD PTR [rdi+68], 2

; 140  :         state->direct = 0;

  00151	44 89 77 40	 mov	 DWORD PTR [rdi+64], r14d

; 141  :         return 0;

  00155	eb 54		 jmp	 SHORT $LN15@gz_look
$LN3@gz_look:

; 142  :     }
; 143  : 
; 144  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 145  :        garbage.  Ignore the trailing garbage and finish. */
; 146  :     if (state->direct == 0) {

  00157	44 39 77 40	 cmp	 DWORD PTR [rdi+64], r14d
  0015b	75 13		 jne	 SHORT $LN2@gz_look

; 147  :         strm->avail_in = 0;

  0015d	44 89 b7 80 00
	00 00		 mov	 DWORD PTR [rdi+128], r14d

; 148  :         state->eof = 1;

  00164	c7 47 50 01 00
	00 00		 mov	 DWORD PTR [rdi+80], 1

; 149  :         state->x.have = 0;

  0016b	44 89 37	 mov	 DWORD PTR [rdi], r14d

; 150  :         return 0;

  0016e	eb 3b		 jmp	 SHORT $LN15@gz_look
$LN2@gz_look:

; 151  :     }
; 152  : 
; 153  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 154  :        the output buffer is larger than the input buffer, which also assures
; 155  :        space for gzungetc() */
; 156  :     state->x.next = state->out;

  00170	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00174	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx

; 157  :     if (strm->avail_in) {

  00178	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  0017e	85 c0		 test	 eax, eax
  00180	74 1b		 je	 SHORT $LN1@gz_look

; 158  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  00182	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  00186	44 8b c0	 mov	 r8d, eax
  00189	e8 00 00 00 00	 call	 memcpy

; 159  :         state->x.have = strm->avail_in;

  0018e	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  00194	89 07		 mov	 DWORD PTR [rdi], eax

; 160  :         strm->avail_in = 0;

  00196	44 89 b7 80 00
	00 00		 mov	 DWORD PTR [rdi+128], r14d
$LN1@gz_look:

; 161  :     }
; 162  :     state->how = COPY;

  0019d	c7 47 44 01 00
	00 00		 mov	 DWORD PTR [rdi+68], 1

; 163  :     state->direct = 1;

  001a4	c7 47 40 01 00
	00 00		 mov	 DWORD PTR [rdi+64], 1
$LN15@gz_look:

; 164  :     return 0;

  001ab	33 c0		 xor	 eax, eax
$LN13@gz_look:

; 165  : }

  001ad	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  001b2	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001b7	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c0	41 5e		 pop	 r14
  001c2	c3		 ret	 0
gz_look	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gz_decomp
_TEXT	SEGMENT
state$ = 48
gz_decomp PROC						; COMDAT

; 174  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 175  :     int ret = Z_OK;
; 176  :     unsigned had;
; 177  :     z_streamp strm = &(state->strm);
; 178  : 
; 179  :     /* fill output buffer up to end of deflate stream */
; 180  :     had = strm->avail_out;

  00014	8b a9 90 00 00
	00		 mov	 ebp, DWORD PTR [rcx+144]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	33 db		 xor	 ebx, ebx
  0001f	90		 npad	 1
$LL11@gz_decomp:

; 181  :     do {
; 182  :         /* get more input for inflate() */
; 183  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00020	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  00027	75 1a		 jne	 SHORT $LN24@gz_decomp
  00029	48 8b ce	 mov	 rcx, rsi
  0002c	e8 00 00 00 00	 call	 gz_avail
  00031	83 f8 ff	 cmp	 eax, -1
  00034	0f 84 bc 00 00
	00		 je	 $LN17@gz_decomp

; 184  :             return -1;
; 185  :         if (strm->avail_in == 0) {

  0003a	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  00041	74 39		 je	 SHORT $LN18@gz_decomp
$LN24@gz_decomp:

; 187  :             break;
; 188  :         }
; 189  : 
; 190  :         /* decompress and handle errors */
; 191  :         ret = inflate(strm, Z_NO_FLUSH);

  00043	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  00047	33 d2		 xor	 edx, edx
  00049	e8 00 00 00 00	 call	 inflate
  0004e	8b d8		 mov	 ebx, eax

; 192  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00050	83 f8 fe	 cmp	 eax, -2
  00053	0f 84 89 00 00
	00		 je	 $LN5@gz_decomp
  00059	83 f8 02	 cmp	 eax, 2
  0005c	0f 84 80 00 00
	00		 je	 $LN5@gz_decomp

; 196  :         }
; 197  :         if (ret == Z_MEM_ERROR) {

  00062	83 f8 fc	 cmp	 eax, -4
  00065	74 6d		 je	 SHORT $LN20@gz_decomp

; 200  :         }
; 201  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  00067	83 f8 fd	 cmp	 eax, -3
  0006a	74 4c		 je	 SHORT $LN21@gz_decomp

; 205  :         }
; 206  :     } while (strm->avail_out && ret != Z_STREAM_END);

  0006c	83 be 90 00 00
	00 00		 cmp	 DWORD PTR [rsi+144], 0
  00073	74 1b		 je	 SHORT $LN9@gz_decomp
  00075	83 f8 01	 cmp	 eax, 1
  00078	75 a6		 jne	 SHORT $LL11@gz_decomp
  0007a	eb 14		 jmp	 SHORT $LN9@gz_decomp
$LN18@gz_decomp:

; 186  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  0007c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  00083	ba fb ff ff ff	 mov	 edx, -5
  00088	48 8b ce	 mov	 rcx, rsi
  0008b	e8 00 00 00 00	 call	 gz_error
$LN9@gz_decomp:

; 207  : 
; 208  :     /* update available output */
; 209  :     state->x.have = had - strm->avail_out;

  00090	2b ae 90 00 00
	00		 sub	 ebp, DWORD PTR [rsi+144]
  00096	8b cd		 mov	 ecx, ebp
  00098	89 0e		 mov	 DWORD PTR [rsi], ecx

; 210  :     state->x.next = strm->next_out - state->x.have;

  0009a	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  000a1	48 2b c1	 sub	 rax, rcx
  000a4	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 211  : 
; 212  :     /* if the gzip stream completed successfully, look for another */
; 213  :     if (ret == Z_STREAM_END)

  000a8	83 fb 01	 cmp	 ebx, 1
  000ab	75 07		 jne	 SHORT $LN1@gz_decomp

; 214  :         state->how = LOOK;

  000ad	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [rsi+68], 0
$LN1@gz_decomp:

; 215  : 
; 216  :     /* good decompression */
; 217  :     return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 41		 jmp	 SHORT $LN12@gz_decomp
$LN21@gz_decomp:

; 202  :             gz_error(state, Z_DATA_ERROR,
; 203  :                      strm->msg == NULL ? "compressed data error" : strm->msg);

  000b8	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  000c6	ba fd ff ff ff	 mov	 edx, -3
  000cb	48 85 c0	 test	 rax, rax
  000ce	4c 0f 45 c0	 cmovne	 r8, rax

; 204  :             return -1;

  000d2	eb 1a		 jmp	 SHORT $LN25@gz_decomp
$LN20@gz_decomp:

; 198  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000db	ba fc ff ff ff	 mov	 edx, -4

; 199  :             return -1;

  000e0	eb 0c		 jmp	 SHORT $LN25@gz_decomp
$LN5@gz_decomp:

; 193  :             gz_error(state, Z_STREAM_ERROR,
; 194  :                      "internal error: inflate stream corrupt");

  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  000e9	ba fe ff ff ff	 mov	 edx, -2
$LN25@gz_decomp:
  000ee	48 8b ce	 mov	 rcx, rsi
  000f1	e8 00 00 00 00	 call	 gz_error
$LN17@gz_decomp:

; 195  :             return -1;

  000f6	83 c8 ff	 or	 eax, -1
$LN12@gz_decomp:

; 218  : }

  000f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fe	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00103	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00108	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gz_fetch
_TEXT	SEGMENT
state$ = 48
gz_fetch PROC						; COMDAT

; 228  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@gz_fetch:

; 229  :     z_streamp strm = &(state->strm);
; 230  : 
; 231  :     do {
; 232  :         switch(state->how) {

  00010	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  00013	85 c9		 test	 ecx, ecx
  00015	74 34		 je	 SHORT $LN8@gz_fetch
  00017	ff c9		 dec	 ecx
  00019	74 5f		 je	 SHORT $LN5@gz_fetch
  0001b	ff c9		 dec	 ecx
  0001d	75 3f		 jne	 SHORT $LN12@gz_fetch

; 245  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 246  :             strm->avail_out = state->size << 1;

  0001f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 247  :             strm->next_out = state->out;
; 248  :             if (gz_decomp(state) == -1)

  00022	48 8b cb	 mov	 rcx, rbx
  00025	03 c0		 add	 eax, eax
  00027	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax
  0002d	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00031	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
  00038	e8 00 00 00 00	 call	 gz_decomp
  0003d	83 f8 ff	 cmp	 eax, -1
  00040	75 1c		 jne	 SHORT $LN12@gz_fetch
$LN19@gz_fetch:

; 235  :                 return -1;

  00042	83 c8 ff	 or	 eax, -1

; 252  :     return 0;
; 253  : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN8@gz_fetch:

; 233  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 234  :             if (gz_look(state) == -1)

  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 gz_look
  00053	83 f8 ff	 cmp	 eax, -1
  00056	74 ea		 je	 SHORT $LN19@gz_fetch

; 236  :             if (state->how == LOOK)

  00058	83 7b 44 00	 cmp	 DWORD PTR [rbx+68], 0
  0005c	74 3f		 je	 SHORT $LN20@gz_fetch
$LN12@gz_fetch:

; 249  :                 return -1;
; 250  :         }
; 251  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  0005e	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00061	75 3a		 jne	 SHORT $LN20@gz_fetch
  00063	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  00067	74 a7		 je	 SHORT $LL13@gz_fetch
  00069	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00070	75 9e		 jne	 SHORT $LL13@gz_fetch

; 244  :             return 0;

  00072	33 c0		 xor	 eax, eax

; 252  :     return 0;
; 253  : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5b		 pop	 rbx
  00079	c3		 ret	 0
$LN5@gz_fetch:

; 237  :                 return 0;
; 238  :             break;
; 239  :         case COPY:      /* -> COPY */
; 240  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 241  :                     == -1)

  0007a	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0007e	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  00082	4c 8b cb	 mov	 r9, rbx
  00085	45 03 c0	 add	 r8d, r8d
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 gz_load
  00090	83 f8 ff	 cmp	 eax, -1
  00093	74 ad		 je	 SHORT $LN19@gz_fetch

; 242  :                 return -1;
; 243  :             state->x.next = state->out;

  00095	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00099	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN20@gz_fetch:

; 244  :             return 0;

  0009d	33 c0		 xor	 eax, eax

; 252  :     return 0;
; 253  : }

  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5b		 pop	 rbx
  000a4	c3		 ret	 0
gz_fetch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gz_skip
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_skip	PROC						; COMDAT

; 259  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 260  :     unsigned n;
; 261  : 
; 262  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 263  :     while (len)

  00010	48 85 d2	 test	 rdx, rdx
  00013	74 47		 je	 SHORT $LN6@gz_skip
$LL7@gz_skip:

; 264  :         /* skip over whatever is in output buffer */
; 265  :         if (state->x.have) {

  00015	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00018	45 85 c0	 test	 r8d, r8d
  0001b	74 1e		 je	 SHORT $LN5@gz_skip

; 266  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
; 267  :                 (unsigned)len : state->x.have;

  0001d	4c 3b c7	 cmp	 r8, rdi
  00020	8b cf		 mov	 ecx, edi
  00022	41 0f 4e c8	 cmovle	 ecx, r8d

; 268  :             state->x.have -= n;
; 269  :             state->x.next += n;

  00026	8b c1		 mov	 eax, ecx
  00028	44 2b c1	 sub	 r8d, ecx
  0002b	48 01 43 08	 add	 QWORD PTR [rbx+8], rax

; 270  :             state->x.pos += n;

  0002f	48 01 43 10	 add	 QWORD PTR [rbx+16], rax

; 271  :             len -= n;

  00033	48 2b f8	 sub	 rdi, rax
  00036	44 89 03	 mov	 DWORD PTR [rbx], r8d
  00039	eb 1c		 jmp	 SHORT $LN1@gz_skip
$LN5@gz_skip:

; 272  :         }
; 273  : 
; 274  :         /* output buffer empty -- return if we're at the end of the input */
; 275  :         else if (state->eof && state->strm.avail_in == 0)

  0003b	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  0003f	74 09		 je	 SHORT $LN3@gz_skip
  00041	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00048	74 12		 je	 SHORT $LN6@gz_skip
$LN3@gz_skip:

; 276  :             break;
; 277  : 
; 278  :         /* need more data to skip -- load up output buffer */
; 279  :         else {
; 280  :             /* get more output, looking for header if required */
; 281  :             if (gz_fetch(state) == -1)

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 gz_fetch
  00052	83 f8 ff	 cmp	 eax, -1
  00055	74 12		 je	 SHORT $LN14@gz_skip
$LN1@gz_skip:

; 260  :     unsigned n;
; 261  : 
; 262  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 263  :     while (len)

  00057	48 85 ff	 test	 rdi, rdi
  0005a	75 b9		 jne	 SHORT $LL7@gz_skip
$LN6@gz_skip:

; 283  :         }
; 284  :     return 0;

  0005c	33 c0		 xor	 eax, eax

; 285  : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN14@gz_skip:

; 282  :                 return -1;

  00069	83 c8 ff	 or	 eax, -1

; 285  : }

  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
gz_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzread
_TEXT	SEGMENT
n$ = 80
file$ = 80
buf$ = 88
len$ = 96
gzread	PROC						; COMDAT

; 292  : {

$LN41:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	41 8b e8	 mov	 ebp, r8d
  0000c	4c 8b f2	 mov	 r14, rdx
  0000f	48 8b d9	 mov	 rbx, rcx

; 293  :     unsigned got, n;
; 294  :     gz_statep state;
; 295  :     z_streamp strm;
; 296  : 
; 297  :     /* get internal structure */
; 298  :     if (file == NULL)

  00012	48 85 c9	 test	 rcx, rcx
  00015	74 2b		 je	 SHORT $LN39@gzread

; 299  :         return -1;
; 300  :     state = (gz_statep)file;
; 301  :     strm = &(state->strm);
; 302  : 
; 303  :     /* check that we're reading and that there's no (serious) error */
; 304  :     if (state->mode != GZ_READ ||
; 305  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00017	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  0001e	75 22		 jne	 SHORT $LN39@gzread
  00020	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00023	85 c0		 test	 eax, eax
  00025	74 05		 je	 SHORT $LN21@gzread
  00027	83 f8 fb	 cmp	 eax, -5
  0002a	75 16		 jne	 SHORT $LN39@gzread
$LN21@gzread:

; 306  :         return -1;
; 307  : 
; 308  :     /* since an int is returned, make sure len fits in one, otherwise return
; 309  :        with an error (this avoids the flaw in the interface) */
; 310  :     if ((int)len < 0) {

  0002c	45 85 c0	 test	 r8d, r8d
  0002f	79 1d		 jns	 SHORT $LN38@gzread

; 311  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00031	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00038	ba fd ff ff ff	 mov	 edx, -3
  0003d	e8 00 00 00 00	 call	 gz_error
$LN39@gzread:

; 312  :         return -1;

  00042	83 c8 ff	 or	 eax, -1

; 379  : }

  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	41 5e		 pop	 r14
  0004b	5d		 pop	 rbp
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
$LN38@gzread:

; 313  :     }
; 314  : 
; 315  :     /* if len is zero, avoid unnecessary operations */
; 316  :     if (len == 0)

  0004e	75 0b		 jne	 SHORT $LN18@gzread

; 317  :         return 0;

  00050	33 c0		 xor	 eax, eax

; 379  : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	41 5e		 pop	 r14
  00058	5d		 pop	 rbp
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
$LN18@gzread:
  0005b	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12

; 318  : 
; 319  :     /* process a skip request */
; 320  :     if (state->seek) {

  00060	45 33 e4	 xor	 r12d, r12d
  00063	44 39 61 68	 cmp	 DWORD PTR [rcx+104], r12d
  00067	74 22		 je	 SHORT $LN16@gzread

; 321  :         state->seek = 0;
; 322  :         if (gz_skip(state, state->skip) == -1)

  00069	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0006d	44 89 61 68	 mov	 DWORD PTR [rcx+104], r12d
  00071	e8 00 00 00 00	 call	 gz_skip
  00076	83 f8 ff	 cmp	 eax, -1
  00079	75 10		 jne	 SHORT $LN16@gzread

; 323  :             return -1;

  0007b	0b c0		 or	 eax, eax
  0007d	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]

; 379  : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	41 5e		 pop	 r14
  00088	5d		 pop	 rbp
  00089	5b		 pop	 rbx
  0008a	c3		 ret	 0
$LN16@gzread:
  0008b	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00090	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 324  :     }
; 325  : 
; 326  :     /* get len bytes to buf, or less than len if at the end */
; 327  :     got = 0;

  00095	45 8b fc	 mov	 r15d, r12d
  00098	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0009d	0f 1f 00	 npad	 3
$LL15@gzread:

; 328  :     do {
; 329  :         /* first just try copying data from the output buffer */
; 330  :         if (state->x.have) {

  000a0	8b 33		 mov	 esi, DWORD PTR [rbx]
  000a2	85 f6		 test	 esi, esi
  000a4	74 33		 je	 SHORT $LN12@gzread

; 331  :             n = state->x.have > len ? len : state->x.have;
; 332  :             memcpy(buf, state->x.next, n);

  000a6	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  000aa	3b f5		 cmp	 esi, ebp
  000ac	49 8b ce	 mov	 rcx, r14
  000af	0f 47 f5	 cmova	 esi, ebp
  000b2	44 8b c6	 mov	 r8d, esi
  000b5	89 74 24 50	 mov	 DWORD PTR n$[rsp], esi
  000b9	8b fe		 mov	 edi, esi
  000bb	e8 00 00 00 00	 call	 memcpy

; 333  :             state->x.next += n;

  000c0	48 01 7b 08	 add	 QWORD PTR [rbx+8], rdi

; 334  :             state->x.have -= n;

  000c4	29 33		 sub	 DWORD PTR [rbx], esi

; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;
; 372  :         buf = (char *)buf + n;

  000c6	8b c6		 mov	 eax, esi
  000c8	2b ee		 sub	 ebp, esi

; 373  :         got += n;

  000ca	44 03 fe	 add	 r15d, esi
  000cd	4c 03 f0	 add	 r14, rax

; 374  :         state->x.pos += n;

  000d0	48 01 43 10	 add	 QWORD PTR [rbx+16], rax
  000d4	e9 91 00 00 00	 jmp	 $LN14@gzread
$LN12@gzread:

; 335  :         }
; 336  : 
; 337  :         /* output buffer empty -- return if we're at the end of the input */
; 338  :         else if (state->eof && strm->avail_in == 0) {

  000d9	44 39 63 50	 cmp	 DWORD PTR [rbx+80], r12d
  000dd	74 0d		 je	 SHORT $LN10@gzread
  000df	44 39 a3 80 00
	00 00		 cmp	 DWORD PTR [rbx+128], r12d
  000e6	0f 84 8b 00 00
	00		 je	 $LN28@gzread
$LN10@gzread:

; 340  :             break;
; 341  :         }
; 342  : 
; 343  :         /* need output data -- for small len or new stream load up our output
; 344  :            buffer */
; 345  :         else if (state->how == LOOK || len < (state->size << 1)) {

  000ec	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 6a		 je	 SHORT $LN7@gzread
  000f3	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  000f6	03 c0		 add	 eax, eax
  000f8	3b e8		 cmp	 ebp, eax
  000fa	72 61		 jb	 SHORT $LN7@gzread

; 349  :             continue;       /* no progress yet -- go back to copy above */
; 350  :             /* the copy above assures that we will leave with space in the
; 351  :                output buffer, allowing at least one gzungetc() to succeed */
; 352  :         }
; 353  : 
; 354  :         /* large len -- read directly into user buffer */
; 355  :         else if (state->how == COPY) {      /* read directly */

  000fc	83 f9 01	 cmp	 ecx, 1

; 356  :             if (gz_load(state, (unsigned char *)buf, len, &n) == -1)

  000ff	48 8b cb	 mov	 rcx, rbx
  00102	75 29		 jne	 SHORT $LN4@gzread
  00104	4c 8d 4c 24 50	 lea	 r9, QWORD PTR n$[rsp]
  00109	44 8b c5	 mov	 r8d, ebp
  0010c	49 8b d6	 mov	 rdx, r14
  0010f	e8 00 00 00 00	 call	 gz_load
  00114	83 f8 ff	 cmp	 eax, -1
  00117	74 6a		 je	 SHORT $LN31@gzread

; 357  :                 return -1;
; 358  :         }
; 359  : 
; 360  :         /* large len -- decompress directly into user buffer */
; 361  :         else {  /* state->how == GZIP */

  00119	8b 74 24 50	 mov	 esi, DWORD PTR n$[rsp]

; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;
; 372  :         buf = (char *)buf + n;

  0011d	8b c6		 mov	 eax, esi
  0011f	2b ee		 sub	 ebp, esi

; 373  :         got += n;

  00121	44 03 fe	 add	 r15d, esi
  00124	4c 03 f0	 add	 r14, rax

; 374  :         state->x.pos += n;

  00127	48 01 43 10	 add	 QWORD PTR [rbx+16], rax
  0012b	eb 3d		 jmp	 SHORT $LN14@gzread
$LN4@gzread:

; 362  :             strm->avail_out = len;

  0012d	89 ab 90 00 00
	00		 mov	 DWORD PTR [rbx+144], ebp

; 363  :             strm->next_out = (unsigned char *)buf;

  00133	4c 89 b3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r14

; 364  :             if (gz_decomp(state) == -1)

  0013a	e8 00 00 00 00	 call	 gz_decomp
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 3f		 je	 SHORT $LN31@gzread

; 365  :                 return -1;
; 366  :             n = state->x.have;

  00144	8b 33		 mov	 esi, DWORD PTR [rbx]

; 367  :             state->x.have = 0;

  00146	44 89 23	 mov	 DWORD PTR [rbx], r12d

; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;
; 372  :         buf = (char *)buf + n;

  00149	8b c6		 mov	 eax, esi
  0014b	2b ee		 sub	 ebp, esi

; 373  :         got += n;

  0014d	44 03 fe	 add	 r15d, esi
  00150	4c 03 f0	 add	 r14, rax

; 374  :         state->x.pos += n;

  00153	48 01 43 10	 add	 QWORD PTR [rbx+16], rax
  00157	89 74 24 50	 mov	 DWORD PTR n$[rsp], esi
  0015b	eb 0d		 jmp	 SHORT $LN14@gzread
$LN7@gzread:

; 346  :             /* get more output, looking for header if required */
; 347  :             if (gz_fetch(state) == -1)

  0015d	48 8b cb	 mov	 rcx, rbx
  00160	e8 00 00 00 00	 call	 gz_fetch
  00165	83 f8 ff	 cmp	 eax, -1
  00168	74 19		 je	 SHORT $LN31@gzread
$LN14@gzread:

; 375  :     } while (len);

  0016a	85 ed		 test	 ebp, ebp
  0016c	0f 85 2e ff ff
	ff		 jne	 $LL15@gzread

; 376  : 
; 377  :     /* return number of bytes read into user buffer (will fit in int) */
; 378  :     return (int)got;

  00172	41 8b c7	 mov	 eax, r15d
  00175	eb 0f		 jmp	 SHORT $LN37@gzread
$LN28@gzread:

; 339  :             state->past = 1;        /* tried to read past end */

  00177	c7 43 54 01 00
	00 00		 mov	 DWORD PTR [rbx+84], 1

; 376  : 
; 377  :     /* return number of bytes read into user buffer (will fit in int) */
; 378  :     return (int)got;

  0017e	41 8b c7	 mov	 eax, r15d
  00181	eb 03		 jmp	 SHORT $LN37@gzread
$LN31@gzread:

; 348  :                 return -1;

  00183	83 c8 ff	 or	 eax, -1
$LN37@gzread:
  00186	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  0018b	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00190	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00195	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]

; 379  : }

  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5e		 pop	 r14
  001a0	5d		 pop	 rbp
  001a1	5b		 pop	 rbx
  001a2	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzgetc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
gzgetc	PROC						; COMDAT

; 389  : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 390  :     int ret;
; 391  :     unsigned char buf[1];
; 392  :     gz_statep state;
; 393  : 
; 394  :     /* get internal structure */
; 395  :     if (file == NULL)

  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 57		 je	 SHORT $LN2@gzgetc

; 396  :         return -1;
; 397  :     state = (gz_statep)file;
; 398  : 
; 399  :     /* check that we're reading and that there's no (serious) error */
; 400  :     if (state->mode != GZ_READ ||
; 401  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0000c	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00013	75 4e		 jne	 SHORT $LN2@gzgetc
  00015	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00018	85 c0		 test	 eax, eax
  0001a	74 05		 je	 SHORT $LN3@gzgetc
  0001c	83 f8 fb	 cmp	 eax, -5
  0001f	75 42		 jne	 SHORT $LN2@gzgetc
$LN3@gzgetc:

; 403  : 
; 404  :     /* try output buffer (no need to check for skip request) */
; 405  :     if (state->x.have) {

  00021	8b 01		 mov	 eax, DWORD PTR [rcx]
  00023	85 c0		 test	 eax, eax
  00025	74 1d		 je	 SHORT $LN1@gzgetc

; 406  :         state->x.have--;
; 407  :         state->x.pos++;

  00027	48 ff 41 10	 inc	 QWORD PTR [rcx+16]
  0002b	ff c8		 dec	 eax
  0002d	89 01		 mov	 DWORD PTR [rcx], eax

; 408  :         return *(state->x.next)++;

  0002f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00033	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00036	48 ff c0	 inc	 rax
  00039	49 89 41 08	 mov	 QWORD PTR [r9+8], rax
  0003d	8b c1		 mov	 eax, ecx

; 414  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN1@gzgetc:

; 409  :     }
; 410  : 
; 411  :     /* nothing there -- try gzread() */
; 412  :     ret = gzread(file, buf, 1);

  00044	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00049	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004f	e8 00 00 00 00	 call	 gzread

; 413  :     return ret < 1 ? -1 : buf[0];

  00054	83 f8 01	 cmp	 eax, 1
  00057	7c 0a		 jl	 SHORT $LN2@gzgetc
  00059	0f b6 44 24 30	 movzx	 eax, BYTE PTR buf$[rsp]

; 414  : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
$LN2@gzgetc:

; 402  :         return -1;

  00063	83 c8 ff	 or	 eax, -1

; 414  : }

  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzgetc_
_TEXT	SEGMENT
file$ = 8
gzgetc_	PROC						; COMDAT

; 419  :     return gzgetc(file);

  00000	e9 00 00 00 00	 jmp	 gzgetc
gzgetc_	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzungetc
_TEXT	SEGMENT
c$ = 48
file$ = 56
gzungetc PROC						; COMDAT

; 426  : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b f9		 mov	 edi, ecx

; 427  :     gz_statep state;
; 428  : 
; 429  :     /* get internal structure */
; 430  :     if (file == NULL)

  0000f	48 85 d2	 test	 rdx, rdx
  00012	0f 84 91 00 00
	00		 je	 $LN9@gzungetc

; 431  :         return -1;
; 432  :     state = (gz_statep)file;
; 433  : 
; 434  :     /* check that we're reading and that there's no (serious) error */
; 435  :     if (state->mode != GZ_READ ||
; 436  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00018	81 7a 18 4f 1c
	00 00		 cmp	 DWORD PTR [rdx+24], 7247 ; 00001c4fH
  0001f	0f 85 84 00 00
	00		 jne	 $LN9@gzungetc
  00025	8b 42 6c	 mov	 eax, DWORD PTR [rdx+108]
  00028	85 c0		 test	 eax, eax
  0002a	74 05		 je	 SHORT $LN10@gzungetc
  0002c	83 f8 fb	 cmp	 eax, -5
  0002f	75 78		 jne	 SHORT $LN9@gzungetc
$LN10@gzungetc:

; 438  : 
; 439  :     /* process a skip request */
; 440  :     if (state->seek) {

  00031	83 7a 68 00	 cmp	 DWORD PTR [rdx+104], 0
  00035	74 18		 je	 SHORT $LN7@gzungetc

; 441  :         state->seek = 0;

  00037	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [rdx+104], 0

; 442  :         if (gz_skip(state, state->skip) == -1)

  0003e	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 gz_skip
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	74 5a		 je	 SHORT $LN9@gzungetc
$LN7@gzungetc:

; 443  :             return -1;
; 444  :     }
; 445  : 
; 446  :     /* can't push EOF */
; 447  :     if (c < 0)

  0004f	85 ff		 test	 edi, edi
  00051	78 56		 js	 SHORT $LN9@gzungetc

; 448  :         return -1;
; 449  : 
; 450  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 451  :     if (state->x.have == 0) {

  00053	8b 0b		 mov	 ecx, DWORD PTR [rbx]

; 452  :         state->x.have = 1;
; 453  :         state->x.next = state->out + (state->size << 1) - 1;

  00055	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00058	85 c9		 test	 ecx, ecx
  0005a	75 32		 jne	 SHORT $LN5@gzungetc
  0005c	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  00060	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  00063	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  00069	48 ff ca	 dec	 rdx

; 454  :         state->x.next[0] = c;
; 455  :         state->x.pos--;
; 456  :         state->past = 0;
; 457  :         return c;

  0006c	8b c7		 mov	 eax, edi
  0006e	48 03 d1	 add	 rdx, rcx
  00071	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  00075	40 88 3a	 mov	 BYTE PTR [rdx], dil
  00078	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]
  0007c	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 479  :     return c;
; 480  : }

  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
$LN5@gzungetc:

; 458  :     }
; 459  : 
; 460  :     /* if no room, give up (must have already done a gzungetc()) */
; 461  :     if (state->x.have == (state->size << 1)) {

  0008e	8d 14 00	 lea	 edx, DWORD PTR [rax+rax]
  00091	3b ca		 cmp	 ecx, edx
  00093	75 22		 jne	 SHORT $LN4@gzungetc

; 462  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  00095	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  0009c	ba fd ff ff ff	 mov	 edx, -3
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 gz_error
$LN9@gzungetc:

; 437  :         return -1;

  000a9	83 c8 ff	 or	 eax, -1

; 479  :     return c;
; 480  : }

  000ac	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
$LN4@gzungetc:

; 463  :         return -1;
; 464  :     }
; 465  : 
; 466  :     /* slide output data if needed and insert byte before existing data */
; 467  :     if (state->x.next == state->out) {

  000b7	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000bb	48 39 43 08	 cmp	 QWORD PTR [rbx+8], rax
  000bf	75 25		 jne	 SHORT $LN3@gzungetc

; 468  :         unsigned char *src = state->out + state->x.have;

  000c1	48 03 c8	 add	 rcx, rax

; 469  :         unsigned char *dest = state->out + (state->size << 1);

  000c4	48 03 d0	 add	 rdx, rax

; 470  :         while (src > state->out)

  000c7	48 3b c8	 cmp	 rcx, rax
  000ca	76 16		 jbe	 SHORT $LN1@gzungetc
  000cc	0f 1f 40 00	 npad	 4
$LL2@gzungetc:

; 471  :             *--dest = *--src;

  000d0	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  000d4	48 ff c9	 dec	 rcx
  000d7	48 ff ca	 dec	 rdx
  000da	88 02		 mov	 BYTE PTR [rdx], al
  000dc	48 3b 4b 38	 cmp	 rcx, QWORD PTR [rbx+56]
  000e0	77 ee		 ja	 SHORT $LL2@gzungetc
$LN1@gzungetc:

; 472  :         state->x.next = dest;

  000e2	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
$LN3@gzungetc:

; 473  :     }
; 474  :     state->x.have++;
; 475  :     state->x.next--;

  000e6	48 ff 4b 08	 dec	 QWORD PTR [rbx+8]
  000ea	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000ee	ff 03		 inc	 DWORD PTR [rbx]

; 476  :     state->x.next[0] = c;

  000f0	40 88 38	 mov	 BYTE PTR [rax], dil

; 477  :     state->x.pos--;

  000f3	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]

; 478  :     state->past = 0;

  000f7	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 479  :     return c;
; 480  : }

  000fe	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00103	8b c7		 mov	 eax, edi
  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzgets
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzgets	PROC						; COMDAT

; 487  : {

$LN32:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	45 8b f8	 mov	 r15d, r8d
  0000d	4c 8b f2	 mov	 r14, rdx
  00010	48 8b f1	 mov	 rsi, rcx

; 488  :     unsigned left, n;
; 489  :     char *str;
; 490  :     unsigned char *eol;
; 491  :     gz_statep state;
; 492  : 
; 493  :     /* check parameters and get internal structure */
; 494  :     if (file == NULL || buf == NULL || len < 1)

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 18 01 00
	00		 je	 $LN12@gzgets
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 0f 01 00
	00		 je	 $LN12@gzgets
  00025	41 83 f8 01	 cmp	 r8d, 1
  00029	0f 8c 05 01 00
	00		 jl	 $LN12@gzgets

; 495  :         return NULL;
; 496  :     state = (gz_statep)file;
; 497  : 
; 498  :     /* check that we're reading and that there's no (serious) error */
; 499  :     if (state->mode != GZ_READ ||
; 500  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0002f	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00036	0f 85 f8 00 00
	00		 jne	 $LN12@gzgets
  0003c	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0003f	85 c0		 test	 eax, eax
  00041	74 09		 je	 SHORT $LN13@gzgets
  00043	83 f8 fb	 cmp	 eax, -5
  00046	0f 85 e8 00 00
	00		 jne	 $LN12@gzgets
$LN13@gzgets:

; 502  : 
; 503  :     /* process a skip request */
; 504  :     if (state->seek) {

  0004c	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00050	74 19		 je	 SHORT $LN10@gzgets

; 505  :         state->seek = 0;
; 506  :         if (gz_skip(state, state->skip) == -1)

  00052	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00056	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  0005d	e8 00 00 00 00	 call	 gz_skip
  00062	83 f8 ff	 cmp	 eax, -1
  00065	0f 84 c9 00 00
	00		 je	 $LN12@gzgets
$LN10@gzgets:
  0006b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00070	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00075	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0007a	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 507  :             return NULL;
; 508  :     }
; 509  : 
; 510  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 511  :        append a terminating zero to the string (we don't check for a zero in
; 512  :        the contents, let the user worry about that) */
; 513  :     str = buf;

  0007f	4d 8b e6	 mov	 r12, r14

; 514  :     left = (unsigned)len - 1;

  00082	41 ff cf	 dec	 r15d

; 515  :     if (left) do {

  00085	0f 84 a5 00 00
	00		 je	 $LN25@gzgets
  0008b	0f 1f 44 00 00	 npad	 5
$LL8@gzgets:

; 516  :         /* assure that something is in the output buffer */
; 517  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  00090	8b 1e		 mov	 ebx, DWORD PTR [rsi]
  00092	85 db		 test	 ebx, ebx
  00094	75 17		 jne	 SHORT $LN26@gzgets
  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 gz_fetch
  0009e	83 f8 ff	 cmp	 eax, -1
  000a1	0f 84 89 00 00
	00		 je	 $LN25@gzgets

; 518  :             return NULL;                /* error */
; 519  :         if (state->x.have == 0) {       /* end of file */

  000a7	8b 1e		 mov	 ebx, DWORD PTR [rsi]
  000a9	85 db		 test	 ebx, ebx
  000ab	74 52		 je	 SHORT $LN22@gzgets
$LN26@gzgets:

; 521  :             break;                      /* return what we have */
; 522  :         }
; 523  : 
; 524  :         /* look for end-of-line in current output buffer */
; 525  :         n = state->x.have > left ? left : state->x.have;
; 526  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  000ad	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000b1	41 3b df	 cmp	 ebx, r15d
  000b4	ba 0a 00 00 00	 mov	 edx, 10
  000b9	41 0f 47 df	 cmova	 ebx, r15d
  000bd	44 8b c3	 mov	 r8d, ebx
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000c6	48 8b e8	 mov	 rbp, rax

; 527  :         if (eol != NULL)

  000c9	48 85 c0	 test	 rax, rax
  000cc	74 07		 je	 SHORT $LN3@gzgets

; 528  :             n = (unsigned)(eol - state->x.next) + 1;

  000ce	8b d8		 mov	 ebx, eax
  000d0	2b 5e 08	 sub	 ebx, DWORD PTR [rsi+8]
  000d3	ff c3		 inc	 ebx
$LN3@gzgets:

; 529  : 
; 530  :         /* copy through end-of-line, or remainder if not found */
; 531  :         memcpy(buf, state->x.next, n);

  000d5	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  000d9	44 8b c3	 mov	 r8d, ebx
  000dc	49 8b ce	 mov	 rcx, r14
  000df	8b fb		 mov	 edi, ebx
  000e1	e8 00 00 00 00	 call	 memcpy

; 532  :         state->x.have -= n;

  000e6	29 1e		 sub	 DWORD PTR [rsi], ebx

; 533  :         state->x.next += n;

  000e8	48 01 7e 08	 add	 QWORD PTR [rsi+8], rdi

; 534  :         state->x.pos += n;

  000ec	48 01 7e 10	 add	 QWORD PTR [rsi+16], rdi

; 535  :         left -= n;
; 536  :         buf += n;

  000f0	4c 03 f7	 add	 r14, rdi
  000f3	44 2b fb	 sub	 r15d, ebx

; 537  :     } while (left && eol == NULL);

  000f6	74 0e		 je	 SHORT $LN2@gzgets
  000f8	48 85 ed	 test	 rbp, rbp
  000fb	74 93		 je	 SHORT $LL8@gzgets
  000fd	eb 07		 jmp	 SHORT $LN2@gzgets
$LN22@gzgets:

; 520  :             state->past = 1;            /* read past end */

  000ff	c7 46 54 01 00
	00 00		 mov	 DWORD PTR [rsi+84], 1
$LN2@gzgets:

; 538  : 
; 539  :     /* return terminated string, or if nothing, end of file */
; 540  :     if (buf == str)

  00106	4d 3b f4	 cmp	 r14, r12
  00109	74 25		 je	 SHORT $LN25@gzgets

; 542  :     buf[0] = 0;

  0010b	41 c6 06 00	 mov	 BYTE PTR [r14], 0

; 543  :     return str;

  0010f	49 8b c4	 mov	 rax, r12
$LN30@gzgets:
  00112	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00117	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0011c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00121	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 544  : }

  00126	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012a	41 5f		 pop	 r15
  0012c	41 5e		 pop	 r14
  0012e	5e		 pop	 rsi
  0012f	c3		 ret	 0
$LN25@gzgets:

; 541  :         return NULL;

  00130	33 c0		 xor	 eax, eax
  00132	eb de		 jmp	 SHORT $LN30@gzgets
$LN12@gzgets:

; 501  :         return NULL;

  00134	33 c0		 xor	 eax, eax

; 544  : }

  00136	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013a	41 5f		 pop	 r15
  0013c	41 5e		 pop	 r14
  0013e	5e		 pop	 rsi
  0013f	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzread.c
;	COMDAT gzdirect
_TEXT	SEGMENT
file$ = 48
gzdirect PROC						; COMDAT

; 549  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 550  :     gz_statep state;
; 551  : 
; 552  :     /* get internal structure */
; 553  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 08		 jne	 SHORT $LN2@gzdirect

; 554  :         return 0;

  0000e	33 c0		 xor	 eax, eax

; 564  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	c3		 ret	 0
$LN2@gzdirect:

; 555  :     state = (gz_statep)file;
; 556  : 
; 557  :     /* if the state is not known, but we can find out, then do so (this is
; 558  :        mainly for right after a gzopen() or gzdopen()) */
; 559  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00016	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  0001d	75 10		 jne	 SHORT $LN1@gzdirect
  0001f	83 79 44 00	 cmp	 DWORD PTR [rcx+68], 0
  00023	75 0a		 jne	 SHORT $LN1@gzdirect
  00025	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00028	75 05		 jne	 SHORT $LN1@gzdirect

; 560  :         (void)gz_look(state);

  0002a	e8 00 00 00 00	 call	 gz_look
$LN1@gzdirect:

; 561  : 
; 562  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 563  :     return state->direct;

  0002f	8b 43 40	 mov	 eax, DWORD PTR [rbx+64]

; 564  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
END
