; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	__imp__write:PROC
EXTRN	__imp_vsnprintf:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
PUBLIC	gzsetparams
PUBLIC	gzflush
PUBLIC	gzprintf
PUBLIC	gzvprintf
PUBLIC	gzputs
PUBLIC	gzputc
PUBLIC	gzwrite
PUBLIC	gzclose_w
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN14
	DD	imagerel $LN14+197
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN12
	DD	imagerel $LN12+121
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzvprintf DD imagerel $LN16
	DD	imagerel $LN16+265
	DD	imagerel $unwind$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN7
	DD	imagerel $LN7+50
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN14
	DD	imagerel $LN14+189
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN31
	DD	imagerel $LN31+322
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_zero DD imagerel gz_zero+50
	DD	imagerel gz_zero+172
	DD	imagerel $chain$1$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_zero DD imagerel gz_zero+172
	DD	imagerel gz_zero+177
	DD	imagerel $chain$3$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+372
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+269
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN13
	DD	imagerel $LN13+194
	DD	imagerel $unwind$gzclose_w
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 089801H
	DD	066498H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_zero DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_zero DD 040a21H
	DD	07640aH
	DD	065405H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 0a9101H
	DD	097491H
	DD	08648cH
	DD	0a340eH
	DD	0f00a320eH
	DD	05006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzvprintf DD 0abe01H
	DD	0774beH
	DD	0664a3H
	DD	095410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 083b01H
	DD	06543bH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzclose_w
_TEXT	SEGMENT
file$ = 48
gzclose_w PROC						; COMDAT

; 541  : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 542  :     int ret = Z_OK;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 543  :     gz_statep state;
; 544  : 
; 545  :     /* get internal structure */
; 546  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 10		 jne	 SHORT $LN8@gzclose_w
$LN11@gzclose_w:

; 547  :         return Z_STREAM_ERROR;

  00014	b8 fe ff ff ff	 mov	 eax, -2

; 576  :     return ret;
; 577  : }

  00019	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	c3		 ret	 0
$LN8@gzclose_w:

; 548  :     state = (gz_statep)file;
; 549  : 
; 550  :     /* check that we're writing */
; 551  :     if (state->mode != GZ_WRITE)

  00024	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0002b	75 e7		 jne	 SHORT $LN11@gzclose_w

; 552  :         return Z_STREAM_ERROR;
; 553  : 
; 554  :     /* check for seek request */
; 555  :     if (state->seek) {

  0002d	39 79 68	 cmp	 DWORD PTR [rcx+104], edi
  00030	74 14		 je	 SHORT $LN5@gzclose_w

; 556  :         state->seek = 0;
; 557  :         if (gz_zero(state, state->skip) == -1)

  00032	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00036	89 79 68	 mov	 DWORD PTR [rcx+104], edi
  00039	e8 00 00 00 00	 call	 gz_zero
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	75 03		 jne	 SHORT $LN5@gzclose_w

; 558  :             ret = state->err;

  00043	8b 7b 6c	 mov	 edi, DWORD PTR [rbx+108]
$LN5@gzclose_w:

; 559  :     }
; 560  : 
; 561  :     /* flush, free memory, and close file */
; 562  :     if (gz_comp(state, Z_FINISH) == -1)

  00046	ba 04 00 00 00	 mov	 edx, 4
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 gz_comp
  00053	83 f8 ff	 cmp	 eax, -1
  00056	75 03		 jne	 SHORT $LN4@gzclose_w

; 563  :         ret = state->err;

  00058	8b 7b 6c	 mov	 edi, DWORD PTR [rbx+108]
$LN4@gzclose_w:

; 564  :     if (state->size) {

  0005b	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  0005f	74 23		 je	 SHORT $LN3@gzclose_w

; 565  :         if (!state->direct) {

  00061	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00065	75 13		 jne	 SHORT $LN2@gzclose_w

; 566  :             (void)deflateEnd(&(state->strm));

  00067	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  0006b	e8 00 00 00 00	 call	 deflateEnd

; 567  :             free(state->out);

  00070	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@gzclose_w:

; 568  :         }
; 569  :         free(state->in);

  0007a	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@gzclose_w:

; 570  :     }
; 571  :     gz_error(state, Z_OK, NULL);

  00084	45 33 c0	 xor	 r8d, r8d
  00087	33 d2		 xor	 edx, edx
  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 gz_error

; 572  :     free(state->path);

  00091	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 573  :     if (close(state->fd) == -1)

  0009b	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  000a4	83 c9 ff	 or	 ecx, -1
  000a7	3b c1		 cmp	 eax, ecx
  000a9	0f 44 f9	 cmove	 edi, ecx

; 574  :         ret = Z_ERRNO;
; 575  :     free(state);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 576  :     return ret;
; 577  : }

  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	8b c7		 mov	 eax, edi
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gz_init
_TEXT	SEGMENT
state$ = 80
gz_init	PROC						; COMDAT

; 17   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);
; 20   : 
; 21   :     /* allocate input buffer */
; 22   :     state->in = (unsigned char *)malloc(state->want);

  00014	8b 69 2c	 mov	 ebp, DWORD PTR [rcx+44]
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	8b cd		 mov	 ecx, ebp
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00022	48 8b f0	 mov	 rsi, rax
  00025	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 23   :     if (state->in == NULL) {

  00029	48 85 c0	 test	 rax, rax
  0002c	74 24		 je	 SHORT $LN8@gz_init

; 24   :         gz_error(state, Z_MEM_ERROR, "out of memory");
; 25   :         return -1;
; 26   :     }
; 27   : 
; 28   :     /* only need output buffer and deflate state if compressing */
; 29   :     if (!state->direct) {

  0002e	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00032	0f 85 9d 00 00
	00		 jne	 $LN2@gz_init

; 30   :         /* allocate output buffer */
; 31   :         state->out = (unsigned char *)malloc(state->want);

  00038	8b cd		 mov	 ecx, ebp
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00040	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 32   :         if (state->out == NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	75 25		 jne	 SHORT $LN3@gz_init

; 33   :             free(state->in);

  00049	48 8b ce	 mov	 rcx, rsi
$LN9@gz_init:
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gz_init:

; 34   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00059	ba fc ff ff ff	 mov	 edx, -4
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	e8 00 00 00 00	 call	 gz_error

; 35   :             return -1;

  00066	83 c8 ff	 or	 eax, -1
  00069	e9 8a 00 00 00	 jmp	 $LN6@gz_init
$LN3@gz_init:

; 36   :         }
; 37   : 
; 38   :         /* allocate deflate memory, set up for gzip compression */
; 39   :         strm->zalloc = Z_NULL;

  0006e	33 c0		 xor	 eax, eax

; 40   :         strm->zfree = Z_NULL;
; 41   :         strm->opaque = Z_NULL;
; 42   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 43   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  00070	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  00078	41 b9 1f 00 00
	00		 mov	 r9d, 31
  0007e	48 89 83 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rax
  00085	48 89 83 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rax
  0008c	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax
  00093	8b 53 58	 mov	 edx, DWORD PTR [rbx+88]
  00096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05IAIEPMAK@1?42?48?$AA@
  0009d	45 8d 41 e9	 lea	 r8d, QWORD PTR [r9-23]
  000a1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000a6	8b 43 5c	 mov	 eax, DWORD PTR [rbx+92]
  000a9	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  000ad	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b1	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000b9	e8 00 00 00 00	 call	 deflateInit2_

; 44   :         if (ret != Z_OK) {

  000be	85 c0		 test	 eax, eax
  000c0	74 13		 je	 SHORT $LN2@gz_init

; 45   :             free(state->out);

  000c2	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 46   :             free(state->in);

  000cc	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]

; 47   :             gz_error(state, Z_MEM_ERROR, "out of memory");
; 48   :             return -1;

  000d0	e9 77 ff ff ff	 jmp	 $LN9@gz_init
$LN2@gz_init:

; 49   :         }
; 50   :     }
; 51   : 
; 52   :     /* mark state as initialized */
; 53   :     state->size = state->want;
; 54   : 
; 55   :     /* initialize write buffer if compressing */
; 56   :     if (!state->direct) {

  000d5	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  000d9	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000dc	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  000df	75 15		 jne	 SHORT $LN1@gz_init

; 57   :         strm->avail_out = state->size;

  000e1	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax

; 58   :         strm->next_out = state->out;

  000e7	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000eb	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 59   :         state->x.next = strm->next_out;

  000f2	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN1@gz_init:

; 60   :     }
; 61   :     return 0;

  000f6	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 62   : }

  000f8	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000fd	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00102	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00107	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
gz_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gz_comp
_TEXT	SEGMENT
state$ = 48
flush$ = 56
gz_comp	PROC						; COMDAT

; 73   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 74   :     int ret, got;
; 75   :     unsigned have;
; 76   :     z_streamp strm = &(state->strm);
; 77   : 
; 78   :     /* allocate memory if this is the first time through */
; 79   :     if (state->size == 0 && gz_init(state) == -1)

  0000f	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00013	8b ea		 mov	 ebp, edx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	75 0a		 jne	 SHORT $LN15@gz_comp
  0001a	e8 00 00 00 00	 call	 gz_init
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	74 5a		 je	 SHORT $LN25@gz_comp
$LN15@gz_comp:

; 80   :         return -1;
; 81   : 
; 82   :     /* write directly if requested */
; 83   :     if (state->direct) {

  00024	83 7f 40 00	 cmp	 DWORD PTR [rdi+64], 0
  00028	74 67		 je	 SHORT $LN14@gz_comp

; 84   :         got = write(state->fd, strm->next_in, strm->avail_in);

  0002a	44 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [rdi+128]
  00031	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  00035	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write

; 85   :         if (got < 0 || (unsigned)got != strm->avail_in) {

  0003e	85 c0		 test	 eax, eax
  00040	78 20		 js	 SHORT $LN12@gz_comp
  00042	3b 87 80 00 00
	00		 cmp	 eax, DWORD PTR [rdi+128]
  00048	75 18		 jne	 SHORT $LN12@gz_comp

; 88   :         }
; 89   :         strm->avail_in = 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	89 87 80 00 00
	00		 mov	 DWORD PTR [rdi+128], eax

; 130  : }

  00052	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00057	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN12@gz_comp:

; 86   :             gz_error(state, Z_ERRNO, zstrerror());

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00068	8b 08		 mov	 ecx, DWORD PTR [rax]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00070	83 ca ff	 or	 edx, -1
  00073	48 8b cf	 mov	 rcx, rdi
  00076	4c 8b c0	 mov	 r8, rax
  00079	e8 00 00 00 00	 call	 gz_error
$LN25@gz_comp:

; 87   :             return -1;

  0007e	83 c8 ff	 or	 eax, -1

; 130  : }

  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN14@gz_comp:

; 90   :         return 0;
; 91   :     }
; 92   : 
; 93   :     /* run deflate() on provided input until it produces no more output */
; 94   :     ret = Z_OK;

  00091	33 c0		 xor	 eax, eax
  00093	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@gz_comp:

; 95   :     do {
; 96   :         /* write out current buffer contents if full, or if flushing, but if
; 97   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 98   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 99   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  000a0	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  000a7	74 0e		 je	 SHORT $LN6@gz_comp
  000a9	85 ed		 test	 ebp, ebp
  000ab	74 55		 je	 SHORT $LN8@gz_comp
  000ad	83 fd 04	 cmp	 ebp, 4
  000b0	75 05		 jne	 SHORT $LN6@gz_comp
  000b2	83 f8 01	 cmp	 eax, 1
  000b5	75 4b		 jne	 SHORT $LN8@gz_comp
$LN6@gz_comp:

; 100  :             have = (unsigned)(strm->next_out - state->x.next);

  000b7	8b b7 88 00 00
	00		 mov	 esi, DWORD PTR [rdi+136]
  000bd	2b 77 08	 sub	 esi, DWORD PTR [rdi+8]

; 101  :             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
; 102  :                          (unsigned)got != have)) {

  000c0	74 18		 je	 SHORT $LN5@gz_comp
  000c2	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000c6	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  000c9	44 8b c6	 mov	 r8d, esi
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write
  000d2	85 c0		 test	 eax, eax
  000d4	78 5c		 js	 SHORT $LN4@gz_comp
  000d6	3b c6		 cmp	 eax, esi
  000d8	75 58		 jne	 SHORT $LN4@gz_comp
$LN5@gz_comp:

; 105  :             }
; 106  :             if (strm->avail_out == 0) {

  000da	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  000e1	75 14		 jne	 SHORT $LN3@gz_comp

; 107  :                 strm->avail_out = state->size;

  000e3	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  000e6	89 87 90 00 00
	00		 mov	 DWORD PTR [rdi+144], eax

; 108  :                 strm->next_out = state->out;

  000ec	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  000f0	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax
$LN3@gz_comp:

; 109  :             }
; 110  :             state->x.next = strm->next_out;

  000f7	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]
  000fe	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN8@gz_comp:

; 111  :         }
; 112  : 
; 113  :         /* compress */
; 114  :         have = strm->avail_out;

  00102	8b b7 90 00 00
	00		 mov	 esi, DWORD PTR [rdi+144]

; 115  :         ret = deflate(strm, flush);

  00108	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  0010c	8b d5		 mov	 edx, ebp
  0010e	e8 00 00 00 00	 call	 deflate

; 116  :         if (ret == Z_STREAM_ERROR) {

  00113	83 f8 fe	 cmp	 eax, -2
  00116	74 30		 je	 SHORT $LN20@gz_comp

; 120  :         }
; 121  :         have -= strm->avail_out;

  00118	3b b7 90 00 00
	00		 cmp	 esi, DWORD PTR [rdi+144]

; 122  :     } while (have);

  0011e	75 80		 jne	 SHORT $LL11@gz_comp

; 123  : 
; 124  :     /* if that completed a deflate stream, allow another to start */
; 125  :     if (flush == Z_FINISH)

  00120	83 fd 04	 cmp	 ebp, 4
  00123	75 09		 jne	 SHORT $LN1@gz_comp

; 126  :         deflateReset(strm);

  00125	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00129	e8 00 00 00 00	 call	 deflateReset
$LN1@gz_comp:

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  0012e	33 c0		 xor	 eax, eax
  00130	eb 2d		 jmp	 SHORT $LN23@gz_comp
$LN4@gz_comp:

; 103  :                 gz_error(state, Z_ERRNO, zstrerror());

  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00138	8b 08		 mov	 ecx, DWORD PTR [rax]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00140	83 ca ff	 or	 edx, -1
  00143	4c 8b c0	 mov	 r8, rax

; 104  :                 return -1;

  00146	eb 0c		 jmp	 SHORT $LN24@gz_comp
$LN20@gz_comp:

; 117  :             gz_error(state, Z_STREAM_ERROR,
; 118  :                       "internal error: deflate stream corrupt");

  00148	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  0014f	ba fe ff ff ff	 mov	 edx, -2
$LN24@gz_comp:
  00154	48 8b cf	 mov	 rcx, rdi
  00157	e8 00 00 00 00	 call	 gz_error

; 119  :             return -1;

  0015c	83 c8 ff	 or	 eax, -1
$LN23@gz_comp:

; 130  : }

  0015f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00164	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00169	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0016e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
gz_comp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gz_zero
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_zero	PROC						; COMDAT

; 136  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 137  :     int first;
; 138  :     unsigned n;
; 139  :     z_streamp strm = &(state->strm);
; 140  : 
; 141  :     /* consume whatever's left in the input buffer */
; 142  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000a	83 b9 80 00 00
	00 00		 cmp	 DWORD PTR [rcx+128], 0
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	74 19		 je	 SHORT $LN5@gz_zero
  00019	33 d2		 xor	 edx, edx
  0001b	e8 00 00 00 00	 call	 gz_comp
  00020	83 f8 ff	 cmp	 eax, -1
  00023	75 0d		 jne	 SHORT $LN5@gz_zero

; 143  :         return -1;

  00025	0b c0		 or	 eax, eax

; 162  : }

  00027	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN5@gz_zero:
  00032	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00037	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;

  0003c	bd 01 00 00 00	 mov	 ebp, 1

; 147  :     while (len) {

  00041	48 85 ff	 test	 rdi, rdi
  00044	74 4f		 je	 SHORT $LN3@gz_zero
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@gz_zero:

; 148  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 149  :             (unsigned)len : state->size;

  00050	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00053	8b f7		 mov	 esi, edi
  00055	48 3b c7	 cmp	 rax, rdi
  00058	0f 4e f0	 cmovle	 esi, eax

; 150  :         if (first) {

  0005b	85 ed		 test	 ebp, ebp
  0005d	74 10		 je	 SHORT $LN2@gz_zero

; 151  :             memset(state->in, 0, n);

  0005f	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00063	44 8b c6	 mov	 r8d, esi
  00066	33 d2		 xor	 edx, edx
  00068	e8 00 00 00 00	 call	 memset

; 152  :             first = 0;

  0006d	33 ed		 xor	 ebp, ebp
$LN2@gz_zero:

; 153  :         }
; 154  :         strm->avail_in = n;

  0006f	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi

; 155  :         strm->next_in = state->in;

  00075	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]

; 156  :         state->x.pos += n;
; 157  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00079	33 d2		 xor	 edx, edx
  0007b	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
  0007f	48 01 73 10	 add	 QWORD PTR [rbx+16], rsi
  00083	48 8b cb	 mov	 rcx, rbx
  00086	e8 00 00 00 00	 call	 gz_comp
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	74 1c		 je	 SHORT $LN11@gz_zero

; 159  :         len -= n;

  00090	48 2b fe	 sub	 rdi, rsi

; 147  :     while (len) {

  00093	75 bb		 jne	 SHORT $LL4@gz_zero
$LN3@gz_zero:

; 160  :     }
; 161  :     return 0;

  00095	33 c0		 xor	 eax, eax
$LN16@gz_zero:
  00097	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 162  : }

  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN11@gz_zero:

; 158  :             return -1;

  000ac	83 c8 ff	 or	 eax, -1
  000af	eb e6		 jmp	 SHORT $LN16@gz_zero
gz_zero	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzwrite
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzwrite	PROC						; COMDAT

; 169  : {

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	41 8b e8	 mov	 ebp, r8d
  00011	4c 8b f2	 mov	 r14, rdx
  00014	48 8b d9	 mov	 rbx, rcx

; 170  :     unsigned put = len;

  00017	45 8b f8	 mov	 r15d, r8d

; 171  :     gz_statep state;
; 172  :     z_streamp strm;
; 173  : 
; 174  :     /* get internal structure */
; 175  :     if (file == NULL)

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	74 24		 je	 SHORT $LN29@gzwrite

; 176  :         return 0;
; 177  :     state = (gz_statep)file;
; 178  :     strm = &(state->strm);
; 179  : 
; 180  :     /* check that we're writing and that there's no error */
; 181  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0001f	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00026	75 1b		 jne	 SHORT $LN29@gzwrite
  00028	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0002c	75 15		 jne	 SHORT $LN29@gzwrite

; 182  :         return 0;
; 183  : 
; 184  :     /* since an int is returned, make sure len fits in one, otherwise return
; 185  :        with an error (this avoids the flaw in the interface) */
; 186  :     if ((int)len < 0) {

  0002e	85 ed		 test	 ebp, ebp
  00030	79 22		 jns	 SHORT $LN15@gzwrite

; 187  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00039	ba fd ff ff ff	 mov	 edx, -3
  0003e	e8 00 00 00 00	 call	 gz_error
$LN29@gzwrite:

; 188  :         return 0;

  00043	33 c0		 xor	 eax, eax

; 242  : }

  00045	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	41 5f		 pop	 r15
  00050	41 5e		 pop	 r14
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
$LN15@gzwrite:

; 189  :     }
; 190  : 
; 191  :     /* if len is zero, avoid unnecessary operations */
; 192  :     if (len == 0)

  00054	45 85 c0	 test	 r8d, r8d
  00057	74 ea		 je	 SHORT $LN29@gzwrite

; 193  :         return 0;
; 194  : 
; 195  :     /* allocate memory if this is the first time through */
; 196  :     if (state->size == 0 && gz_init(state) == -1)

  00059	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0005d	75 0a		 jne	 SHORT $LN13@gzwrite
  0005f	e8 00 00 00 00	 call	 gz_init
  00064	83 f8 ff	 cmp	 eax, -1
  00067	74 da		 je	 SHORT $LN29@gzwrite
$LN13@gzwrite:

; 197  :         return 0;
; 198  : 
; 199  :     /* check for seek request */
; 200  :     if (state->seek) {

  00069	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  0006d	74 18		 je	 SHORT $LN11@gzwrite

; 201  :         state->seek = 0;
; 202  :         if (gz_zero(state, state->skip) == -1)

  0006f	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00073	48 8b cb	 mov	 rcx, rbx
  00076	c7 43 68 00 00
	00 00		 mov	 DWORD PTR [rbx+104], 0
  0007d	e8 00 00 00 00	 call	 gz_zero
  00082	83 f8 ff	 cmp	 eax, -1
  00085	74 bc		 je	 SHORT $LN29@gzwrite
$LN11@gzwrite:
  00087	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0008c	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 203  :             return 0;
; 204  :     }
; 205  : 
; 206  :     /* for small len, copy to input buffer, otherwise compress directly */
; 207  :     if (len < state->size) {

  00091	3b 6b 28	 cmp	 ebp, DWORD PTR [rbx+40]
  00094	73 5b		 jae	 SHORT $LN10@gzwrite
$LL9@gzwrite:

; 208  :         /* copy to input buffer, compress when full */
; 209  :         do {
; 210  :             unsigned have, copy;
; 211  : 
; 212  :             if (strm->avail_in == 0)

  00096	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0009c	85 c9		 test	 ecx, ecx
  0009e	75 08		 jne	 SHORT $LN6@gzwrite

; 213  :                 strm->next_in = state->in;

  000a0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  000a4	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN6@gzwrite:

; 214  :             have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  000a8	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]

; 215  :             copy = state->size - have;

  000ab	8b 73 28	 mov	 esi, DWORD PTR [rbx+40]

; 216  :             if (copy > len)
; 217  :                 copy = len;
; 218  :             memcpy(state->in + have, buf, copy);

  000ae	49 8b d6	 mov	 rdx, r14
  000b1	2b 43 30	 sub	 eax, DWORD PTR [rbx+48]
  000b4	03 c1		 add	 eax, ecx
  000b6	2b f0		 sub	 esi, eax
  000b8	8b c8		 mov	 ecx, eax
  000ba	3b f5		 cmp	 esi, ebp
  000bc	0f 47 f5	 cmova	 esi, ebp
  000bf	48 03 4b 30	 add	 rcx, QWORD PTR [rbx+48]
  000c3	44 8b c6	 mov	 r8d, esi
  000c6	8b fe		 mov	 edi, esi
  000c8	e8 00 00 00 00	 call	 memcpy

; 219  :             strm->avail_in += copy;

  000cd	01 b3 80 00 00
	00		 add	 DWORD PTR [rbx+128], esi

; 220  :             state->x.pos += copy;

  000d3	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 221  :             buf = (const char *)buf + copy;

  000d7	4c 03 f7	 add	 r14, rdi

; 222  :             len -= copy;

  000da	2b ee		 sub	 ebp, esi

; 223  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000dc	74 48		 je	 SHORT $LN1@gzwrite
  000de	33 d2		 xor	 edx, edx
  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	e8 00 00 00 00	 call	 gz_comp
  000e8	83 f8 ff	 cmp	 eax, -1
  000eb	75 a9		 jne	 SHORT $LL9@gzwrite
$LN28@gzwrite:

; 224  :                 return 0;

  000ed	33 c0		 xor	 eax, eax
  000ef	eb 38		 jmp	 SHORT $LN27@gzwrite
$LN10@gzwrite:

; 225  :         } while (len);
; 226  :     }
; 227  :     else {
; 228  :         /* consume whatever's left in the input buffer */
; 229  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000f1	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  000f8	74 0f		 je	 SHORT $LN2@gzwrite
  000fa	33 d2		 xor	 edx, edx
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 gz_comp
  00104	83 f8 ff	 cmp	 eax, -1
  00107	74 e4		 je	 SHORT $LN28@gzwrite
$LN2@gzwrite:

; 230  :             return 0;
; 231  : 
; 232  :         /* directly compress user buffer to file */
; 233  :         strm->avail_in = len;

  00109	89 ab 80 00 00
	00		 mov	 DWORD PTR [rbx+128], ebp

; 234  :         strm->next_in = (z_const Bytef *)buf;

  0010f	4c 89 73 78	 mov	 QWORD PTR [rbx+120], r14

; 235  :         state->x.pos += len;

  00113	48 01 6b 10	 add	 QWORD PTR [rbx+16], rbp

; 236  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00117	33 d2		 xor	 edx, edx
  00119	48 8b cb	 mov	 rcx, rbx
  0011c	e8 00 00 00 00	 call	 gz_comp
  00121	83 f8 ff	 cmp	 eax, -1
  00124	74 c7		 je	 SHORT $LN28@gzwrite
$LN1@gzwrite:

; 237  :             return 0;
; 238  :     }
; 239  : 
; 240  :     /* input was all buffered or compressed (put will fit in int) */
; 241  :     return (int)put;

  00126	41 8b c7	 mov	 eax, r15d
$LN27@gzwrite:
  00129	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012e	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 242  : }

  00133	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	41 5f		 pop	 r15
  0013e	41 5e		 pop	 r14
  00140	5d		 pop	 rbp
  00141	c3		 ret	 0
gzwrite	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzputc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
c$ = 56
gzputc	PROC						; COMDAT

; 248  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 249  :     unsigned have;
; 250  :     unsigned char buf[1];
; 251  :     gz_statep state;
; 252  :     z_streamp strm;
; 253  : 
; 254  :     /* get internal structure */
; 255  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 97 00 00
	00		 je	 $LN7@gzputc

; 256  :         return -1;
; 257  :     state = (gz_statep)file;
; 258  :     strm = &(state->strm);
; 259  : 
; 260  :     /* check that we're writing and that there's no error */
; 261  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00018	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001f	0f 85 8a 00 00
	00		 jne	 $LN7@gzputc
  00025	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00029	0f 85 80 00 00
	00		 jne	 $LN7@gzputc

; 263  : 
; 264  :     /* check for seek request */
; 265  :     if (state->seek) {

  0002f	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00033	74 15		 je	 SHORT $LN5@gzputc

; 266  :         state->seek = 0;
; 267  :         if (gz_zero(state, state->skip) == -1)

  00035	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00039	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  00040	e8 00 00 00 00	 call	 gz_zero
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 65		 je	 SHORT $LN7@gzputc
$LN5@gzputc:

; 268  :             return -1;
; 269  :     }
; 270  : 
; 271  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 272  :        initialized) */
; 273  :     if (state->size) {

  0004a	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  0004e	74 42		 je	 SHORT $LN2@gzputc

; 274  :         if (strm->avail_in == 0)

  00050	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00056	85 c9		 test	 ecx, ecx
  00058	75 08		 jne	 SHORT $LN3@gzputc

; 275  :             strm->next_in = state->in;

  0005a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0005e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN3@gzputc:

; 276  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00062	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  00065	2b 43 30	 sub	 eax, DWORD PTR [rbx+48]
  00068	03 c1		 add	 eax, ecx

; 277  :         if (have < state->size) {

  0006a	3b 43 28	 cmp	 eax, DWORD PTR [rbx+40]
  0006d	73 23		 jae	 SHORT $LN2@gzputc

; 278  :             state->in[have] = c;

  0006f	8b c8		 mov	 ecx, eax
  00071	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00075	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil

; 279  :             strm->avail_in++;

  00079	ff 83 80 00 00
	00		 inc	 DWORD PTR [rbx+128]

; 280  :             state->x.pos++;

  0007f	48 ff 43 10	 inc	 QWORD PTR [rbx+16]
$LN12@gzputc:

; 281  :             return c & 0xff;

  00083	40 0f b6 c7	 movzx	 eax, dil

; 288  :         return -1;
; 289  :     return c & 0xff;
; 290  : }

  00087	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
$LN2@gzputc:

; 282  :         }
; 283  :     }
; 284  : 
; 285  :     /* no room in buffer or not initialized, use gz_write() */
; 286  :     buf[0] = c;
; 287  :     if (gzwrite(file, buf, 1) != 1)

  00092	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00097	41 b8 01 00 00
	00		 mov	 r8d, 1
  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	40 88 7c 24 30	 mov	 BYTE PTR buf$[rsp], dil
  000a5	e8 00 00 00 00	 call	 gzwrite
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	74 d4		 je	 SHORT $LN12@gzputc
$LN7@gzputc:

; 262  :         return -1;

  000af	83 c8 ff	 or	 eax, -1

; 288  :         return -1;
; 289  :     return c & 0xff;
; 290  : }

  000b2	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
gzputc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzputs
_TEXT	SEGMENT
file$ = 48
str$ = 56
gzputs	PROC						; COMDAT

; 296  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 297  :     int ret;
; 298  :     unsigned len;
; 299  : 
; 300  :     /* write string */
; 301  :     len = (unsigned)strlen(str);

  00006	48 83 cb ff	 or	 rbx, -1
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL5@gzputs:
  00010	48 ff c3	 inc	 rbx
  00013	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00017	75 f7		 jne	 SHORT $LL5@gzputs

; 302  :     ret = gzwrite(file, str, len);

  00019	44 8b c3	 mov	 r8d, ebx
  0001c	e8 00 00 00 00	 call	 gzwrite

; 303  :     return ret == 0 && len != 0 ? -1 : ret;

  00021	85 c0		 test	 eax, eax
  00023	75 07		 jne	 SHORT $LN3@gzputs
  00025	85 db		 test	 ebx, ebx
  00027	74 03		 je	 SHORT $LN3@gzputs
  00029	83 c8 ff	 or	 eax, -1
$LN3@gzputs:

; 304  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzvprintf
_TEXT	SEGMENT
file$ = 48
format$ = 56
va$ = 64
gzvprintf PROC						; COMDAT

; 311  : {

$LN16:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	49 8b e8	 mov	 rbp, r8
  00013	4c 8b f2	 mov	 r14, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 312  :     int size, len;
; 313  :     gz_statep state;
; 314  :     z_streamp strm;
; 315  : 
; 316  :     /* get internal structure */
; 317  :     if (file == NULL)

  00019	48 85 c9	 test	 rcx, rcx
  0001c	75 14		 jne	 SHORT $LN9@gzvprintf

; 318  :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 370  : }

  00021	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00026	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	41 5e		 pop	 r14
  00031	c3		 ret	 0
$LN9@gzvprintf:

; 319  :     state = (gz_statep)file;
; 320  :     strm = &(state->strm);
; 321  : 
; 322  :     /* check that we're writing and that there's no error */
; 323  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00032	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00039	75 16		 jne	 SHORT $LN14@gzvprintf
  0003b	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0003f	75 10		 jne	 SHORT $LN14@gzvprintf

; 324  :         return 0;
; 325  : 
; 326  :     /* make sure we have some buffer space */
; 327  :     if (state->size == 0 && gz_init(state) == -1)

  00041	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00045	75 1d		 jne	 SHORT $LN6@gzvprintf
  00047	e8 00 00 00 00	 call	 gz_init
  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	75 13		 jne	 SHORT $LN6@gzvprintf
$LN14@gzvprintf:

; 328  :         return 0;

  00051	33 c0		 xor	 eax, eax

; 370  : }

  00053	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00058	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	41 5e		 pop	 r14
  00063	c3		 ret	 0
$LN6@gzvprintf:

; 329  : 
; 330  :     /* check for seek request */
; 331  :     if (state->seek) {

  00064	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00068	74 18		 je	 SHORT $LN4@gzvprintf

; 332  :         state->seek = 0;
; 333  :         if (gz_zero(state, state->skip) == -1)

  0006a	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	c7 43 68 00 00
	00 00		 mov	 DWORD PTR [rbx+104], 0
  00078	e8 00 00 00 00	 call	 gz_zero
  0007d	83 f8 ff	 cmp	 eax, -1
  00080	74 cf		 je	 SHORT $LN14@gzvprintf
$LN4@gzvprintf:

; 334  :             return 0;
; 335  :     }
; 336  : 
; 337  :     /* consume whatever's left in the input buffer */
; 338  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00082	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00089	74 0f		 je	 SHORT $LN3@gzvprintf
  0008b	33 d2		 xor	 edx, edx
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 gz_comp
  00095	83 f8 ff	 cmp	 eax, -1
  00098	74 b7		 je	 SHORT $LN14@gzvprintf
$LN3@gzvprintf:

; 339  :         return 0;
; 340  : 
; 341  :     /* do the printf() into the input buffer, put length in len */
; 342  :     size = (int)(state->size);
; 343  :     state->in[size - 1] = 0;

  0009a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0009e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  000a3	48 63 73 28	 movsxd	 rsi, DWORD PTR [rbx+40]
  000a7	c6 44 30 ff 00	 mov	 BYTE PTR [rax+rsi-1], 0

; 344  : #ifdef NO_vsnprintf
; 345  : #  ifdef HAS_vsprintf_void
; 346  :     (void)vsprintf((char *)(state->in), format, va);
; 347  :     for (len = 0; len < size; len++)
; 348  :         if (state->in[len] == 0) break;
; 349  : #  else
; 350  :     len = vsprintf((char *)(state->in), format, va);
; 351  : #  endif
; 352  : #else
; 353  : #  ifdef HAS_vsnprintf_void
; 354  :     (void)vsnprintf((char *)(state->in), size, format, va);
; 355  :     len = strlen((char *)(state->in));
; 356  : #  else
; 357  :     len = vsnprintf((char *)(state->in), size, format, va);

  000ac	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000b0	4c 8b cd	 mov	 r9, rbp
  000b3	4d 8b c6	 mov	 r8, r14
  000b6	48 8b d6	 mov	 rdx, rsi
  000b9	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_vsnprintf
  000c4	48 63 d0	 movsxd	 rdx, eax

; 358  : #  endif
; 359  : #endif
; 360  : 
; 361  :     /* check that printf() results fit in buffer */
; 362  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000c7	85 c0		 test	 eax, eax
  000c9	7e 21		 jle	 SHORT $LN1@gzvprintf
  000cb	3b d6		 cmp	 edx, esi
  000cd	7d 1d		 jge	 SHORT $LN1@gzvprintf
  000cf	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000d3	80 7c 31 ff 00	 cmp	 BYTE PTR [rcx+rsi-1], 0
  000d8	75 12		 jne	 SHORT $LN1@gzvprintf

; 364  : 
; 365  :     /* update buffer and position, defer compression until needed */
; 366  :     strm->avail_in = (unsigned)len;

  000da	89 93 80 00 00
	00		 mov	 DWORD PTR [rbx+128], edx

; 367  :     strm->next_in = state->in;

  000e0	48 89 4b 78	 mov	 QWORD PTR [rbx+120], rcx

; 368  :     state->x.pos += len;

  000e4	48 01 53 10	 add	 QWORD PTR [rbx+16], rdx

; 369  :     return len;

  000e8	8b c2		 mov	 eax, edx
  000ea	eb 02		 jmp	 SHORT $LN13@gzvprintf
$LN1@gzvprintf:

; 363  :         return 0;

  000ec	33 c0		 xor	 eax, eax
$LN13@gzvprintf:
  000ee	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000f3	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 370  : }

  000f8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fd	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00102	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00106	41 5e		 pop	 r14
  00108	c3		 ret	 0
gzvprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzprintf
_TEXT	SEGMENT
file$ = 48
format$ = 56
gzprintf PROC						; COMDAT

; 373  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 374  :     va_list va;
; 375  :     int ret;
; 376  : 
; 377  :     va_start(va, format);

  00013	4c 8d 44 24 40	 lea	 r8, QWORD PTR format$[rsp+8]

; 378  :     ret = gzvprintf(file, format, va);

  00018	e8 00 00 00 00	 call	 gzvprintf

; 379  :     va_end(va);
; 380  :     return ret;
; 381  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzflush
_TEXT	SEGMENT
file$ = 48
flush$ = 56
gzflush	PROC						; COMDAT

; 468  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 469  :     gz_statep state;
; 470  : 
; 471  :     /* get internal structure */
; 472  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 0e		 jne	 SHORT $LN7@gzflush
$LN10@gzflush:

; 473  :         return -1;

  00014	83 c8 ff	 or	 eax, -1

; 494  : }

  00017	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
$LN7@gzflush:

; 474  :     state = (gz_statep)file;
; 475  : 
; 476  :     /* check that we're writing and that there's no error */
; 477  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00022	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00029	75 3e		 jne	 SHORT $LN5@gzflush
  0002b	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0002f	75 38		 jne	 SHORT $LN5@gzflush

; 479  : 
; 480  :     /* check flush parameter */
; 481  :     if (flush < 0 || flush > Z_FINISH)

  00031	83 fa 04	 cmp	 edx, 4
  00034	77 33		 ja	 SHORT $LN5@gzflush

; 482  :         return Z_STREAM_ERROR;
; 483  : 
; 484  :     /* check for seek request */
; 485  :     if (state->seek) {

  00036	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  0003a	74 15		 je	 SHORT $LN1@gzflush

; 486  :         state->seek = 0;
; 487  :         if (gz_zero(state, state->skip) == -1)

  0003c	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00040	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  00047	e8 00 00 00 00	 call	 gz_zero
  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	74 c3		 je	 SHORT $LN10@gzflush
$LN1@gzflush:

; 488  :             return -1;
; 489  :     }
; 490  : 
; 491  :     /* compress remaining data with requested flush */
; 492  :     gz_comp(state, flush);

  00051	8b d7		 mov	 edx, edi
  00053	48 8b cb	 mov	 rcx, rbx
  00056	e8 00 00 00 00	 call	 gz_comp

; 493  :     return state->err;

  0005b	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]

; 494  : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN5@gzflush:

; 478  :         return Z_STREAM_ERROR;

  00069	b8 fe ff ff ff	 mov	 eax, -2

; 494  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\gzwrite.c
;	COMDAT gzsetparams
_TEXT	SEGMENT
file$ = 48
level$ = 56
strategy$ = 64
gzsetparams PROC					; COMDAT

; 501  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b f8	 mov	 edi, r8d
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 502  :     gz_statep state;
; 503  :     z_streamp strm;
; 504  : 
; 505  :     /* get internal structure */
; 506  :     if (file == NULL)

  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 13		 jne	 SHORT $LN8@gzsetparam

; 507  :         return Z_STREAM_ERROR;

  0001c	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 536  : }

  0001f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00024	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN8@gzsetparam:

; 508  :     state = (gz_statep)file;
; 509  :     strm = &(state->strm);
; 510  : 
; 511  :     /* check that we're writing and that there's no error */
; 512  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0002f	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00036	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003b	75 6e		 jne	 SHORT $LN6@gzsetparam
  0003d	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00041	75 68		 jne	 SHORT $LN6@gzsetparam

; 514  : 
; 515  :     /* if no change is requested, then do nothing */
; 516  :     if (level == state->level && strategy == state->strategy)

  00043	3b 51 58	 cmp	 edx, DWORD PTR [rcx+88]
  00046	75 06		 jne	 SHORT $LN5@gzsetparam
  00048	44 3b 41 5c	 cmp	 r8d, DWORD PTR [rcx+92]
  0004c	74 59		 je	 SHORT $LN12@gzsetparam
$LN5@gzsetparam:

; 517  :         return Z_OK;
; 518  : 
; 519  :     /* check for seek request */
; 520  :     if (state->seek) {

  0004e	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00052	74 19		 je	 SHORT $LN3@gzsetparam

; 521  :         state->seek = 0;
; 522  :         if (gz_zero(state, state->skip) == -1)

  00054	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00058	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  0005f	e8 00 00 00 00	 call	 gz_zero
  00064	83 f8 ff	 cmp	 eax, -1
  00067	75 04		 jne	 SHORT $LN3@gzsetparam

; 523  :             return -1;

  00069	0b c0		 or	 eax, eax
  0006b	eb 43		 jmp	 SHORT $LN11@gzsetparam
$LN3@gzsetparam:

; 524  :     }
; 525  : 
; 526  :     /* change compression parameters for subsequent input */
; 527  :     if (state->size) {

  0006d	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  00071	74 2e		 je	 SHORT $LN2@gzsetparam

; 528  :         /* flush previous input with previous parameters before changing */
; 529  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00073	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  0007a	74 17		 je	 SHORT $LN1@gzsetparam
  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 gz_comp
  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 05		 jne	 SHORT $LN1@gzsetparam

; 530  :             return state->err;

  0008e	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]
  00091	eb 1d		 jmp	 SHORT $LN11@gzsetparam
$LN1@gzsetparam:

; 531  :         deflateParams(strm, level, strategy);

  00093	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  00097	44 8b c7	 mov	 r8d, edi
  0009a	8b d6		 mov	 edx, esi
  0009c	e8 00 00 00 00	 call	 deflateParams
$LN2@gzsetparam:

; 532  :     }
; 533  :     state->level = level;

  000a1	89 73 58	 mov	 DWORD PTR [rbx+88], esi

; 534  :     state->strategy = strategy;

  000a4	89 7b 5c	 mov	 DWORD PTR [rbx+92], edi
$LN12@gzsetparam:

; 535  :     return Z_OK;

  000a7	33 c0		 xor	 eax, eax
  000a9	eb 05		 jmp	 SHORT $LN11@gzsetparam
$LN6@gzsetparam:

; 513  :         return Z_STREAM_ERROR;

  000ab	b8 fe ff ff ff	 mov	 eax, -2
$LN11@gzsetparam:
  000b0	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 536  : }

  000b5	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ba	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
END
