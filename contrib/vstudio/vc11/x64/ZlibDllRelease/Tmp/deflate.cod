; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	match_init:PROC
EXTRN	longest_match:PROC
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
?my_version@?1??deflateInit2_@@9@9 DB '1.2.8', 00H	; `deflateInit2_'::`2'::my_version
PUBLIC	deflateCopy
PUBLIC	deflateBound
PUBLIC	deflateTune
PUBLIC	deflateParams
PUBLIC	deflatePrime
PUBLIC	deflatePending
PUBLIC	deflateSetHeader
PUBLIC	deflateReset
PUBLIC	deflateResetKeep
PUBLIC	deflateSetDictionary
PUBLIC	deflateInit2_
PUBLIC	deflateEnd
PUBLIC	deflateInit_
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+452
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+816
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+1288
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+1018
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+482
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+21
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fill_window DD imagerel fill_window+21
	DD	imagerel fill_window+453
	DD	imagerel $chain$0$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$fill_window DD imagerel fill_window+453
	DD	imagerel fill_window+584
	DD	imagerel $chain$1$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+180
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+160
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN12
	DD	imagerel $LN12+53
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateCopy DD imagerel $LN12+53
	DD	imagerel $LN12+142
	DD	imagerel $chain$0$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateCopy DD imagerel $LN12+142
	DD	imagerel $LN12+582
	DD	imagerel $chain$3$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateCopy DD imagerel $LN12+582
	DD	imagerel $LN12+597
	DD	imagerel $chain$5$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateCopy DD imagerel $LN12+597
	DD	imagerel $LN12+613
	DD	imagerel $chain$6$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+55
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$flush_pending DD imagerel flush_pending+55
	DD	imagerel flush_pending+91
	DD	imagerel $chain$0$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$flush_pending DD imagerel flush_pending+91
	DD	imagerel flush_pending+115
	DD	imagerel $chain$1$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN16
	DD	imagerel $LN16+86
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateParams DD imagerel $LN16+86
	DD	imagerel $LN16+250
	DD	imagerel $chain$0$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateParams DD imagerel $LN16+250
	DD	imagerel $LN16+277
	DD	imagerel $chain$1$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePrime DD imagerel $LN17
	DD	imagerel $LN17+191
	DD	imagerel $unwind$deflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateResetKeep DD imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateResetKeep DD imagerel $LN9+60
	DD	imagerel $LN9+179
	DD	imagerel $chain$0$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateResetKeep DD imagerel $LN9+179
	DD	imagerel $LN9+195
	DD	imagerel $chain$1$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN26
	DD	imagerel $LN26+49
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateSetDictionary DD imagerel $LN26+49
	DD	imagerel $LN26+514
	DD	imagerel $chain$3$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateSetDictionary DD imagerel $LN26+514
	DD	imagerel $LN26+533
	DD	imagerel $chain$5$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateSetDictionary DD imagerel $LN26+533
	DD	imagerel $LN26+547
	DD	imagerel $chain$6$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN23
	DD	imagerel $LN23+91
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateInit2_ DD imagerel $LN23+91
	DD	imagerel $LN23+266
	DD	imagerel $chain$1$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateInit2_ DD imagerel $LN23+266
	DD	imagerel $LN23+562
	DD	imagerel $chain$2$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateInit2_ DD imagerel $LN23+562
	DD	imagerel $LN23+584
	DD	imagerel $chain$3$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateInit2_ DD imagerel $LN23+584
	DD	imagerel $LN23+617
	DD	imagerel $chain$5$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateInit2_ DD imagerel $LN23+617
	DD	imagerel $LN23+624
	DD	imagerel $chain$6$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateInit2_ DD imagerel $LN23+624
	DD	imagerel $LN23+641
	DD	imagerel $chain$7$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN14
	DD	imagerel $LN14+31
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateEnd DD imagerel $LN14+31
	DD	imagerel $LN14+92
	DD	imagerel $chain$0$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateEnd DD imagerel $LN14+92
	DD	imagerel $LN14+207
	DD	imagerel $chain$2$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateEnd DD imagerel $LN14+207
	DD	imagerel $LN14+218
	DD	imagerel $chain$3$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN122
	DD	imagerel $LN122+123
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflate DD imagerel $LN122+123
	DD	imagerel $LN122+1073
	DD	imagerel $chain$1$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflate DD imagerel $LN122+1073
	DD	imagerel $LN122+1465
	DD	imagerel $chain$2$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflate DD imagerel $LN122+1465
	DD	imagerel $LN122+1605
	DD	imagerel $chain$3$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflate DD imagerel $LN122+1605
	DD	imagerel $LN122+2177
	DD	imagerel $chain$5$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflate DD imagerel $LN122+2177
	DD	imagerel $LN122+2202
	DD	imagerel $chain$6$deflate
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflate DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+123
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflate DD 040021H
	DD	0af400H
	DD	085400H
	DD	imagerel $LN122
	DD	imagerel $LN122+123
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflate DD 021H
	DD	imagerel $LN122+123
	DD	imagerel $LN122+1073
	DD	imagerel $chain$1$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflate DD 020521H
	DD	096405H
	DD	imagerel $LN122+123
	DD	imagerel $LN122+1073
	DD	imagerel $chain$1$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflate DD 040a21H
	DD	0af40aH
	DD	085405H
	DD	imagerel $LN122
	DD	imagerel $LN122+123
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateEnd DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+31
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateEnd DD 020021H
	DD	067400H
	DD	imagerel $LN14
	DD	imagerel $LN14+31
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateEnd DD 020521H
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+31
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateInit2_ DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateInit2_ DD 040021H
	DD	0cd400H
	DD	0bc400H
	DD	imagerel $LN23
	DD	imagerel $LN23+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateInit2_ DD 060021H
	DD	0cd400H
	DD	0bc400H
	DD	0a6400H
	DD	imagerel $LN23
	DD	imagerel $LN23+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateInit2_ DD 021H
	DD	imagerel $LN23+91
	DD	imagerel $LN23+266
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateInit2_ DD 020521H
	DD	0a6405H
	DD	imagerel $LN23+91
	DD	imagerel $LN23+266
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateInit2_ DD 045f21H
	DD	0bc45fH
	DD	0cd405H
	DD	imagerel $LN23
	DD	imagerel $LN23+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateSetDictionary DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+49
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateSetDictionary DD 020021H
	DD	0ce400H
	DD	imagerel $LN26
	DD	imagerel $LN26+49
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateSetDictionary DD 083f21H
	DD	04f43fH
	DD	0bd43aH
	DD	0ac435H
	DD	0ce405H
	DD	imagerel $LN26
	DD	imagerel $LN26+49
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 050901H
	DD	070054209H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateResetKeep DD 021H
	DD	imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$deflateResetKeep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateResetKeep DD 020521H
	DD	066405H
	DD	imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$deflateResetKeep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateResetKeep DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePrime DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateParams DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+86
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateParams DD 020521H
	DD	065405H
	DD	imagerel $LN16
	DD	imagerel $LN16+86
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$flush_pending DD 021H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+55
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$flush_pending DD 020521H
	DD	063405H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+55
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateCopy DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+53
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateCopy DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN12
	DD	imagerel $LN12+53
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateCopy DD 040c21H
	DD	07e40cH
	DD	067400H
	DD	imagerel $LN12
	DD	imagerel $LN12+53
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateCopy DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+53
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 084a01H
	DD	06544aH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$fill_window DD 021H
	DD	imagerel fill_window
	DD	imagerel fill_window+21
	DD	imagerel $unwind$fill_window
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fill_window DD 020521H
	DD	065405H
	DD	imagerel fill_window
	DD	imagerel fill_window+21
	DD	imagerel $unwind$fill_window
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 0c3a01H
	DD	0a643aH
	DD	0c5417H
	DD	0b3417H
	DD	0f0133217H
	DD	0d00fe011H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflate
_TEXT	SEGMENT
strm$ = 64
flush$ = 72
deflate	PROC						; COMDAT

; 668  : {

$LN122:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	44 8b f2	 mov	 r14d, edx
  0000c	48 8b f9	 mov	 rdi, rcx

; 669  :     int old_flush; /* value of flush param for previous deflate call */
; 670  :     deflate_state *s;
; 671  : 
; 672  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 673  :         flush > Z_BLOCK || flush < 0) {

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 74 08 00
	00		 je	 $LN82@deflate
  00018	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  0001c	48 85 db	 test	 rbx, rbx
  0001f	0f 84 67 08 00
	00		 je	 $LN82@deflate
  00025	83 fa 05	 cmp	 edx, 5
  00028	0f 87 5e 08 00
	00		 ja	 $LN82@deflate

; 674  :         return Z_STREAM_ERROR;
; 675  :     }
; 676  :     s = strm->state;
; 677  : 
; 678  :     if (strm->next_out == Z_NULL ||
; 679  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 680  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  0002e	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  00033	0f 84 48 08 00
	00		 je	 $LN80@deflate
  00039	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0003d	75 0a		 jne	 SHORT $LN79@deflate
  0003f	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00043	0f 85 38 08 00
	00		 jne	 $LN80@deflate
$LN79@deflate:
  00049	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  0004c	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00051	75 09		 jne	 SHORT $LN81@deflate
  00053	83 fa 04	 cmp	 edx, 4
  00056	0f 85 25 08 00
	00		 jne	 $LN80@deflate
$LN81@deflate:

; 682  :     }
; 683  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  0005c	83 79 18 00	 cmp	 DWORD PTR [rcx+24], 0
  00060	75 19		 jne	 SHORT $LN78@deflate
  00062	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00069	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  0006d	b8 fb ff ff ff	 mov	 eax, -5

; 976  : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	41 5e		 pop	 r14
  00078	5f		 pop	 rdi
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
$LN78@deflate:
  0007b	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00080	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15

; 684  : 
; 685  :     s->strm = strm; /* just in case */
; 686  :     old_flush = s->last_flush;

  00085	44 8b 7b 40	 mov	 r15d, DWORD PTR [rbx+64]

; 687  :     s->last_flush = flush;
; 688  : 
; 689  :     /* Write the header */
; 690  :     if (s->status == INIT_STATE) {

  00089	33 ed		 xor	 ebp, ebp
  0008b	89 53 40	 mov	 DWORD PTR [rbx+64], edx
  0008e	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00091	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00094	0f 85 be 02 00
	00		 jne	 $LN71@deflate

; 691  : #ifdef GZIP
; 692  :         if (s->wrap == 2) {

  0009a	83 7b 2c 02	 cmp	 DWORD PTR [rbx+44], 2
  0009e	0f 85 19 02 00
	00		 jne	 $LN76@deflate

; 693  :             strm->adler = crc32(0L, Z_NULL, 0);

  000a4	45 33 c0	 xor	 r8d, r8d
  000a7	33 d2		 xor	 edx, edx
  000a9	33 c9		 xor	 ecx, ecx
  000ab	e8 00 00 00 00	 call	 crc32
  000b0	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 694  :             put_byte(s, 31);

  000b3	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000b6	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ba	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  000be	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000c1	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 695  :             put_byte(s, 139);

  000c4	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000c8	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  000cc	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000cf	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 696  :             put_byte(s, 8);

  000d2	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000d6	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  000da	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 697  :             if (s->gzhead == Z_NULL) {

  000dd	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  000e1	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  000e5	4d 85 c0	 test	 r8, r8
  000e8	0f 85 8f 00 00
	00		 jne	 $LN75@deflate

; 698  :                 put_byte(s, 0);

  000ee	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000f2	41 88 2c 01	 mov	 BYTE PTR [r9+rax], bpl
  000f6	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000f9	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 699  :                 put_byte(s, 0);

  000fc	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00100	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00104	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00107	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 700  :                 put_byte(s, 0);

  0010a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0010e	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00112	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00115	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 701  :                 put_byte(s, 0);

  00118	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0011c	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00120	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00123	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 702  :                 put_byte(s, 0);

  00126	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0012a	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl

; 703  :                 put_byte(s, s->level == 9 ? 2 :
; 704  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 705  :                              4 : 0));

  0012e	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  00134	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00137	83 f8 09	 cmp	 eax, 9
  0013a	75 05		 jne	 SHORT $LN88@deflate
  0013c	8d 55 02	 lea	 edx, QWORD PTR [rbp+2]
  0013f	eb 15		 jmp	 SHORT $LN87@deflate
$LN88@deflate:
  00141	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00148	7d 07		 jge	 SHORT $LN86@deflate
  0014a	8b d5		 mov	 edx, ebp
  0014c	83 f8 02	 cmp	 eax, 2
  0014f	7d 05		 jge	 SHORT $LN87@deflate
$LN86@deflate:
  00151	ba 04 00 00 00	 mov	 edx, 4
$LN87@deflate:
  00156	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00159	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0015d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00160	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00163	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 706  :                 put_byte(s, OS_CODE);

  00166	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0016a	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11
  0016e	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 707  :                 s->status = BUSY_STATE;

  00171	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H

; 708  :             }
; 709  :             else {

  00178	e9 db 01 00 00	 jmp	 $LN71@deflate
$LN75@deflate:

; 710  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 711  :                             (s->gzhead->hcrc ? 2 : 0) +
; 712  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 713  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 714  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 715  :                         );

  0017d	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  00181	48 f7 d8	 neg	 rax
  00184	41 8b 40 3c	 mov	 eax, DWORD PTR [r8+60]
  00188	1a d2		 sbb	 dl, dl
  0018a	80 e2 10	 and	 dl, 16
  0018d	f7 d8		 neg	 eax
  0018f	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00193	1a c9		 sbb	 cl, cl
  00195	80 e1 02	 and	 cl, 2
  00198	02 d1		 add	 dl, cl
  0019a	48 f7 d8	 neg	 rax
  0019d	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  001a1	1a c9		 sbb	 cl, cl
  001a3	80 e1 08	 and	 cl, 8
  001a6	02 d1		 add	 dl, cl
  001a8	48 f7 d8	 neg	 rax
  001ab	1a c9		 sbb	 cl, cl
  001ad	80 e1 04	 and	 cl, 4
  001b0	02 d1		 add	 dl, cl
  001b2	41 39 28	 cmp	 DWORD PTR [r8], ebp
  001b5	0f 95 c0	 setne	 al
  001b8	02 d0		 add	 dl, al
  001ba	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001be	41 88 14 01	 mov	 BYTE PTR [r9+rax], dl
  001c2	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001c5	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 716  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  001c8	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001cc	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001d0	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001d4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001d7	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001da	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 717  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  001dd	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001e1	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001e5	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  001e9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001ec	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001ef	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 718  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  001f2	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001f6	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001fa	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  001fe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00201	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 719  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  00204	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00208	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0020c	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0020f	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00213	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 720  :                 put_byte(s, s->level == 9 ? 2 :
; 721  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 722  :                              4 : 0));

  00216	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  0021c	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0021f	83 f8 09	 cmp	 eax, 9
  00222	75 05		 jne	 SHORT $LN92@deflate
  00224	8d 50 f9	 lea	 edx, QWORD PTR [rax-7]
  00227	eb 15		 jmp	 SHORT $LN91@deflate
$LN92@deflate:
  00229	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00230	7d 07		 jge	 SHORT $LN90@deflate
  00232	8b d5		 mov	 edx, ebp
  00234	83 f8 02	 cmp	 eax, 2
  00237	7d 05		 jge	 SHORT $LN91@deflate
$LN90@deflate:
  00239	ba 04 00 00 00	 mov	 edx, 4
$LN91@deflate:
  0023e	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00241	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00245	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00248	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 723  :                 put_byte(s, s->gzhead->os & 0xff);

  0024b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0024f	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00253	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00256	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0025a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0025d	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 724  :                 if (s->gzhead->extra != Z_NULL) {

  00260	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00264	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00268	48 39 68 10	 cmp	 QWORD PTR [rax+16], rbp
  0026c	74 28		 je	 SHORT $LN73@deflate

; 725  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  0026e	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00272	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00276	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0027a	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 726  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  0027d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00281	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00284	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00288	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0028c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0028f	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00292	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
$LN73@deflate:

; 727  :                 }
; 728  :                 if (s->gzhead->hcrc)

  00296	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0029a	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  0029d	74 0f		 je	 SHORT $LN72@deflate

; 729  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 730  :                                         s->pending);

  0029f	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  002a3	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  002a6	e8 00 00 00 00	 call	 crc32
  002ab	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN72@deflate:

; 731  :                 s->gzindex = 0;

  002ae	89 6b 38	 mov	 DWORD PTR [rbx+56], ebp

; 732  :                 s->status = EXTRA_STATE;

  002b1	c7 43 08 45 00
	00 00		 mov	 DWORD PTR [rbx+8], 69	; 00000045H

; 733  :             }
; 734  :         }
; 735  :         else

  002b8	e9 9b 00 00 00	 jmp	 $LN71@deflate
$LN76@deflate:

; 736  : #endif
; 737  :         {
; 738  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  002bd	8b 4b 48	 mov	 ecx, DWORD PTR [rbx+72]
  002c0	83 e9 08	 sub	 ecx, 8
  002c3	c1 e1 0c	 shl	 ecx, 12
  002c6	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H

; 739  :             uInt level_flags;
; 740  : 
; 741  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  002cc	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  002d3	7d 24		 jge	 SHORT $LN69@deflate
  002d5	8b 93 ac 00 00
	00		 mov	 edx, DWORD PTR [rbx+172]
  002db	83 fa 02	 cmp	 edx, 2
  002de	7c 19		 jl	 SHORT $LN69@deflate

; 743  :             else if (s->level < 6)

  002e0	83 fa 06	 cmp	 edx, 6
  002e3	7d 07		 jge	 SHORT $LN67@deflate

; 744  :                 level_flags = 1;

  002e5	b8 01 00 00 00	 mov	 eax, 1
  002ea	eb 0f		 jmp	 SHORT $LN64@deflate
$LN67@deflate:

; 745  :             else if (s->level == 6)

  002ec	83 fa 06	 cmp	 edx, 6
  002ef	8b c5		 mov	 eax, ebp
  002f1	0f 95 c0	 setne	 al
  002f4	83 c0 02	 add	 eax, 2

; 746  :                 level_flags = 2;
; 747  :             else
; 748  :                 level_flags = 3;

  002f7	eb 02		 jmp	 SHORT $LN64@deflate
$LN69@deflate:

; 742  :                 level_flags = 0;

  002f9	8b c5		 mov	 eax, ebp
$LN64@deflate:

; 749  :             header |= (level_flags << 6);

  002fb	c1 e0 06	 shl	 eax, 6
  002fe	0b c8		 or	 ecx, eax

; 750  :             if (s->strstart != 0) header |= PRESET_DICT;

  00300	39 ab 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], ebp
  00306	74 03		 je	 SHORT $LN63@deflate
  00308	83 c9 20	 or	 ecx, 32			; 00000020H
$LN63@deflate:

; 751  :             header += 31 - (header % 31);

  0030b	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H

; 752  : 
; 753  :             s->status = BUSY_STATE;

  00310	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  00317	f7 e1		 mul	 ecx
  00319	2b ca		 sub	 ecx, edx
  0031b	d1 e9		 shr	 ecx, 1
  0031d	03 ca		 add	 ecx, edx
  0031f	c1 e9 04	 shr	 ecx, 4

; 754  :             putShortMSB(s, header);

  00322	ff c1		 inc	 ecx
  00324	6b d1 1f	 imul	 edx, ecx, 31
  00327	48 8b cb	 mov	 rcx, rbx
  0032a	e8 00 00 00 00	 call	 putShortMSB

; 755  : 
; 756  :             /* Save the adler32 of the preset dictionary: */
; 757  :             if (s->strstart != 0) {

  0032f	39 ab 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], ebp
  00335	74 12		 je	 SHORT $LN62@deflate

; 758  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  00337	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  0033b	e8 00 00 00 00	 call	 putShortMSB

; 759  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00340	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  00344	e8 00 00 00 00	 call	 putShortMSB
$LN62@deflate:

; 760  :             }
; 761  :             strm->adler = adler32(0L, Z_NULL, 0);

  00349	45 33 c0	 xor	 r8d, r8d
  0034c	33 d2		 xor	 edx, edx
  0034e	33 c9		 xor	 ecx, ecx
  00350	e8 00 00 00 00	 call	 adler32
  00355	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN71@deflate:

; 762  :         }
; 763  :     }
; 764  : #ifdef GZIP
; 765  :     if (s->status == EXTRA_STATE) {

  00358	83 7b 08 45	 cmp	 DWORD PTR [rbx+8], 69	; 00000045H
  0035c	0f 85 cb 00 00
	00		 jne	 $LN52@deflate

; 766  :         if (s->gzhead->extra != Z_NULL) {

  00362	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00366	48 39 68 10	 cmp	 QWORD PTR [rax+16], rbp
  0036a	0f 84 b6 00 00
	00		 je	 $LN60@deflate

; 767  :             uInt beg = s->pending;  /* start of bytes to update crc */
; 768  : 
; 769  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  00370	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  00374	44 8b 53 28	 mov	 r10d, DWORD PTR [rbx+40]
  00378	39 43 38	 cmp	 DWORD PTR [rbx+56], eax
  0037b	73 73		 jae	 SHORT $LN113@deflate
  0037d	0f 1f 00	 npad	 3
$LL59@deflate:

; 770  :                 if (s->pending == s->pending_buf_size) {

  00380	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00383	3b 4b 18	 cmp	 ecx, DWORD PTR [rbx+24]
  00386	75 39		 jne	 SHORT $LN55@deflate

; 771  :                     if (s->gzhead->hcrc && s->pending > beg)

  00388	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0038c	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  0038f	74 1d		 je	 SHORT $LN56@deflate
  00391	41 3b ca	 cmp	 ecx, r10d
  00394	76 18		 jbe	 SHORT $LN56@deflate

; 772  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 773  :                                             s->pending - beg);

  00396	41 2b ca	 sub	 ecx, r10d
  00399	41 8b d2	 mov	 edx, r10d
  0039c	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  003a0	44 8b c1	 mov	 r8d, ecx
  003a3	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  003a6	e8 00 00 00 00	 call	 crc32
  003ab	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN56@deflate:

; 774  :                     flush_pending(strm);

  003ae	48 8b cf	 mov	 rcx, rdi
  003b1	e8 00 00 00 00	 call	 flush_pending

; 775  :                     beg = s->pending;

  003b6	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  003b9	44 8b d1	 mov	 r10d, ecx

; 776  :                     if (s->pending == s->pending_buf_size)

  003bc	3b 4b 18	 cmp	 ecx, DWORD PTR [rbx+24]
  003bf	74 2f		 je	 SHORT $LN113@deflate
$LN55@deflate:

; 777  :                         break;
; 778  :                 }
; 779  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  003c1	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003c5	44 8b 4b 38	 mov	 r9d, DWORD PTR [rbx+56]
  003c9	44 8b c1	 mov	 r8d, ecx
  003cc	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  003d0	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  003d4	41 0f b6 04 11	 movzx	 eax, BYTE PTR [r9+rdx]
  003d9	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  003dd	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 780  :                 s->gzindex++;

  003e0	ff 43 38	 inc	 DWORD PTR [rbx+56]
  003e3	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003e7	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  003eb	39 4b 38	 cmp	 DWORD PTR [rbx+56], ecx
  003ee	72 90		 jb	 SHORT $LL59@deflate
$LN113@deflate:

; 781  :             }
; 782  :             if (s->gzhead->hcrc && s->pending > beg)

  003f0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003f4	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  003f7	74 1e		 je	 SHORT $LN54@deflate
  003f9	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  003fd	45 3b c2	 cmp	 r8d, r10d
  00400	76 15		 jbe	 SHORT $LN54@deflate

; 783  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 784  :                                     s->pending - beg);

  00402	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00405	41 8b d2	 mov	 edx, r10d
  00408	45 2b c2	 sub	 r8d, r10d
  0040b	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  0040f	e8 00 00 00 00	 call	 crc32
  00414	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN54@deflate:

; 785  :             if (s->gzindex == s->gzhead->extra_len) {

  00417	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0041b	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0041e	39 4b 38	 cmp	 DWORD PTR [rbx+56], ecx
  00421	75 0a		 jne	 SHORT $LN52@deflate

; 786  :                 s->gzindex = 0;

  00423	89 6b 38	 mov	 DWORD PTR [rbx+56], ebp
$LN60@deflate:

; 787  :                 s->status = NAME_STATE;
; 788  :             }
; 789  :         }
; 790  :         else
; 791  :             s->status = NAME_STATE;

  00426	c7 43 08 49 00
	00 00		 mov	 DWORD PTR [rbx+8], 73	; 00000049H
$LN52@deflate:

; 792  :     }
; 793  :     if (s->status == NAME_STATE) {

  0042d	83 7b 08 49	 cmp	 DWORD PTR [rbx+8], 73	; 00000049H
  00431	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00436	0f 85 b5 00 00
	00		 jne	 $LN41@deflate

; 794  :         if (s->gzhead->name != Z_NULL) {

  0043c	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00440	48 39 68 20	 cmp	 QWORD PTR [rax+32], rbp
  00444	0f 84 a0 00 00
	00		 je	 $LN50@deflate

; 795  :             uInt beg = s->pending;  /* start of bytes to update crc */

  0044a	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0044d	0f 1f 00	 npad	 3
$LL49@deflate:

; 796  :             int val;
; 797  : 
; 798  :             do {
; 799  :                 if (s->pending == s->pending_buf_size) {

  00450	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00454	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  00458	75 37		 jne	 SHORT $LN44@deflate

; 800  :                     if (s->gzhead->hcrc && s->pending > beg)

  0045a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0045e	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  00461	74 19		 je	 SHORT $LN45@deflate
  00463	44 3b c2	 cmp	 r8d, edx
  00466	76 14		 jbe	 SHORT $LN45@deflate

; 801  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 802  :                                             s->pending - beg);

  00468	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0046b	44 2b c2	 sub	 r8d, edx
  0046e	8b d2		 mov	 edx, edx
  00470	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00474	e8 00 00 00 00	 call	 crc32
  00479	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN45@deflate:

; 803  :                     flush_pending(strm);

  0047c	48 8b cf	 mov	 rcx, rdi
  0047f	e8 00 00 00 00	 call	 flush_pending

; 804  :                     beg = s->pending;

  00484	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00488	41 8b d0	 mov	 edx, r8d

; 805  :                     if (s->pending == s->pending_buf_size) {

  0048b	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  0048f	74 29		 je	 SHORT $LN102@deflate
$LN44@deflate:

; 807  :                         break;
; 808  :                     }
; 809  :                 }
; 810  :                 val = s->gzhead->name[s->gzindex++];

  00491	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00494	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00498	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0049c	0f b6 34 08	 movzx	 esi, BYTE PTR [rax+rcx]
  004a0	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 811  :                 put_byte(s, val);

  004a3	41 8b c8	 mov	 ecx, r8d
  004a6	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  004a9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  004ad	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  004b1	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 812  :             } while (val != 0);

  004b4	85 f6		 test	 esi, esi
  004b6	75 98		 jne	 SHORT $LL49@deflate
  004b8	eb 05		 jmp	 SHORT $LN47@deflate
$LN102@deflate:

; 806  :                         val = 1;

  004ba	be 01 00 00 00	 mov	 esi, 1
$LN47@deflate:

; 813  :             if (s->gzhead->hcrc && s->pending > beg)

  004bf	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004c3	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  004c6	74 1b		 je	 SHORT $LN43@deflate
  004c8	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  004cc	44 3b c2	 cmp	 r8d, edx
  004cf	76 12		 jbe	 SHORT $LN43@deflate

; 814  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 815  :                                     s->pending - beg);

  004d1	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  004d4	44 2b c2	 sub	 r8d, edx
  004d7	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  004db	e8 00 00 00 00	 call	 crc32
  004e0	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN43@deflate:

; 816  :             if (val == 0) {

  004e3	85 f6		 test	 esi, esi
  004e5	75 0a		 jne	 SHORT $LN41@deflate

; 817  :                 s->gzindex = 0;

  004e7	89 6b 38	 mov	 DWORD PTR [rbx+56], ebp
$LN50@deflate:

; 818  :                 s->status = COMMENT_STATE;
; 819  :             }
; 820  :         }
; 821  :         else
; 822  :             s->status = COMMENT_STATE;

  004ea	c7 43 08 5b 00
	00 00		 mov	 DWORD PTR [rbx+8], 91	; 0000005bH
$LN41@deflate:

; 823  :     }
; 824  :     if (s->status == COMMENT_STATE) {

  004f1	83 7b 08 5b	 cmp	 DWORD PTR [rbx+8], 91	; 0000005bH
  004f5	0f 85 b3 00 00
	00		 jne	 $LN30@deflate

; 825  :         if (s->gzhead->comment != Z_NULL) {

  004fb	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004ff	48 39 68 30	 cmp	 QWORD PTR [rax+48], rbp
  00503	0f 84 9e 00 00
	00		 je	 $LN39@deflate

; 826  :             uInt beg = s->pending;  /* start of bytes to update crc */

  00509	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0050c	0f 1f 40 00	 npad	 4
$LL38@deflate:

; 827  :             int val;
; 828  : 
; 829  :             do {
; 830  :                 if (s->pending == s->pending_buf_size) {

  00510	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00514	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  00518	75 37		 jne	 SHORT $LN33@deflate

; 831  :                     if (s->gzhead->hcrc && s->pending > beg)

  0051a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0051e	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  00521	74 19		 je	 SHORT $LN34@deflate
  00523	44 3b c2	 cmp	 r8d, edx
  00526	76 14		 jbe	 SHORT $LN34@deflate

; 832  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 833  :                                             s->pending - beg);

  00528	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0052b	44 2b c2	 sub	 r8d, edx
  0052e	8b d2		 mov	 edx, edx
  00530	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00534	e8 00 00 00 00	 call	 crc32
  00539	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN34@deflate:

; 834  :                     flush_pending(strm);

  0053c	48 8b cf	 mov	 rcx, rdi
  0053f	e8 00 00 00 00	 call	 flush_pending

; 835  :                     beg = s->pending;

  00544	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00548	41 8b d0	 mov	 edx, r8d

; 836  :                     if (s->pending == s->pending_buf_size) {

  0054b	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  0054f	74 29		 je	 SHORT $LN103@deflate
$LN33@deflate:

; 838  :                         break;
; 839  :                     }
; 840  :                 }
; 841  :                 val = s->gzhead->comment[s->gzindex++];

  00551	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00554	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00558	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0055c	0f b6 34 08	 movzx	 esi, BYTE PTR [rax+rcx]
  00560	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 842  :                 put_byte(s, val);

  00563	41 8b c8	 mov	 ecx, r8d
  00566	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  00569	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0056d	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00571	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 843  :             } while (val != 0);

  00574	85 f6		 test	 esi, esi
  00576	75 98		 jne	 SHORT $LL38@deflate
  00578	eb 05		 jmp	 SHORT $LN36@deflate
$LN103@deflate:

; 837  :                         val = 1;

  0057a	be 01 00 00 00	 mov	 esi, 1
$LN36@deflate:

; 844  :             if (s->gzhead->hcrc && s->pending > beg)

  0057f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00583	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  00586	74 1b		 je	 SHORT $LN32@deflate
  00588	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0058c	44 3b c2	 cmp	 r8d, edx
  0058f	76 12		 jbe	 SHORT $LN32@deflate

; 845  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 846  :                                     s->pending - beg);

  00591	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00594	44 2b c2	 sub	 r8d, edx
  00597	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  0059b	e8 00 00 00 00	 call	 crc32
  005a0	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN32@deflate:

; 847  :             if (val == 0)

  005a3	85 f6		 test	 esi, esi
  005a5	75 07		 jne	 SHORT $LN30@deflate
$LN39@deflate:

; 848  :                 s->status = HCRC_STATE;
; 849  :         }
; 850  :         else
; 851  :             s->status = HCRC_STATE;

  005a7	c7 43 08 67 00
	00 00		 mov	 DWORD PTR [rbx+8], 103	; 00000067H
$LN30@deflate:

; 852  :     }
; 853  :     if (s->status == HCRC_STATE) {

  005ae	83 7b 08 67	 cmp	 DWORD PTR [rbx+8], 103	; 00000067H
  005b2	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  005b7	75 5e		 jne	 SHORT $LN25@deflate

; 854  :         if (s->gzhead->hcrc) {

  005b9	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005bd	39 68 3c	 cmp	 DWORD PTR [rax+60], ebp
  005c0	74 4e		 je	 SHORT $LN28@deflate

; 855  :             if (s->pending + 2 > s->pending_buf_size)

  005c2	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  005c5	83 c0 02	 add	 eax, 2
  005c8	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  005cb	76 08		 jbe	 SHORT $LN27@deflate

; 856  :                 flush_pending(strm);

  005cd	48 8b cf	 mov	 rcx, rdi
  005d0	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate:

; 857  :             if (s->pending + 2 <= s->pending_buf_size) {

  005d5	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  005d8	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  005db	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  005de	77 37		 ja	 SHORT $LN25@deflate

; 858  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  005e0	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  005e4	8b d1		 mov	 edx, ecx
  005e6	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  005ea	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005ed	ff 43 28	 inc	 DWORD PTR [rbx+40]
  005f0	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 859  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  005f3	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  005f7	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]

; 860  :                 strm->adler = crc32(0L, Z_NULL, 0);

  005fb	45 33 c0	 xor	 r8d, r8d
  005fe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00601	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00604	33 d2		 xor	 edx, edx
  00606	33 c9		 xor	 ecx, ecx
  00608	e8 00 00 00 00	 call	 crc32
  0060d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN28@deflate:

; 861  :                 s->status = BUSY_STATE;
; 862  :             }
; 863  :         }
; 864  :         else
; 865  :             s->status = BUSY_STATE;

  00610	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
$LN25@deflate:

; 866  :     }
; 867  : #endif
; 868  : 
; 869  :     /* Flush as much pending output as possible */
; 870  :     if (s->pending != 0) {

  00617	39 6b 28	 cmp	 DWORD PTR [rbx+40], ebp
  0061a	74 29		 je	 SHORT $LN24@deflate

; 871  :         flush_pending(strm);

  0061c	48 8b cf	 mov	 rcx, rdi
  0061f	e8 00 00 00 00	 call	 flush_pending

; 872  :         if (strm->avail_out == 0) {

  00624	39 6f 18	 cmp	 DWORD PTR [rdi+24], ebp
  00627	75 51		 jne	 SHORT $LN21@deflate
$LN119@deflate:

; 873  :             /* Since avail_out is 0, deflate will be called again with
; 874  :              * more output space, but possibly with both pending and
; 875  :              * avail_in equal to zero. There won't be anything to do,
; 876  :              * but this is not an error situation so make sure we
; 877  :              * return OK instead of BUF_ERROR at next call of deflate:
; 878  :              */
; 879  :             s->last_flush = -1;

  00629	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
$LN13@deflate:

; 880  :             return Z_OK;

  00630	33 c0		 xor	 eax, eax
$LN115@deflate:
  00632	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00637	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 976  : }

  0063c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00640	41 5e		 pop	 r14
  00642	5f		 pop	 rdi
  00643	5b		 pop	 rbx
  00644	c3		 ret	 0
$LN24@deflate:

; 881  :         }
; 882  : 
; 883  :     /* Make sure there is something to do and avoid duplicate consecutive
; 884  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 885  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 886  :      */
; 887  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
; 888  :                flush != Z_FINISH) {

  00645	39 6f 08	 cmp	 DWORD PTR [rdi+8], ebp
  00648	75 30		 jne	 SHORT $LN21@deflate
  0064a	41 83 ff 04	 cmp	 r15d, 4
  0064e	41 b8 09 00 00
	00		 mov	 r8d, 9
  00654	8b c5		 mov	 eax, ebp
  00656	41 0f 4f c0	 cmovg	 eax, r8d
  0065a	43 8d 14 3f	 lea	 edx, DWORD PTR [r15+r15]
  0065e	8b cd		 mov	 ecx, ebp
  00660	2b d0		 sub	 edx, eax
  00662	41 83 fe 04	 cmp	 r14d, 4
  00666	43 8d 04 36	 lea	 eax, DWORD PTR [r14+r14]
  0066a	41 0f 4f c8	 cmovg	 ecx, r8d
  0066e	2b c1		 sub	 eax, ecx
  00670	3b c2		 cmp	 eax, edx
  00672	7f 06		 jg	 SHORT $LN21@deflate
  00674	41 83 fe 04	 cmp	 r14d, 4
  00678	75 0f		 jne	 SHORT $LN120@deflate
$LN21@deflate:

; 889  :         ERR_RETURN(strm, Z_BUF_ERROR);
; 890  :     }
; 891  : 
; 892  :     /* User must not provide more input after the first FINISH: */
; 893  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  0067a	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  0067d	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00682	75 17		 jne	 SHORT $LN20@deflate
  00684	39 6f 08	 cmp	 DWORD PTR [rdi+8], ebp
  00687	74 17		 je	 SHORT $LN117@deflate
$LN120@deflate:

; 894  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00689	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00690	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00694	b8 fb ff ff ff	 mov	 eax, -5
  00699	eb 97		 jmp	 SHORT $LN115@deflate
$LN20@deflate:

; 895  :     }
; 896  : 
; 897  :     /* Start a new block or continue the current one.
; 898  :      */
; 899  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 900  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  0069b	39 6f 08	 cmp	 DWORD PTR [rdi+8], ebp
  0069e	75 1c		 jne	 SHORT $LN18@deflate
$LN117@deflate:
  006a0	39 ab 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], ebp
  006a6	75 14		 jne	 SHORT $LN18@deflate
  006a8	45 85 f6	 test	 r14d, r14d
  006ab	0f 84 de 00 00
	00		 je	 $LN6@deflate
  006b1	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  006b6	0f 84 d3 00 00
	00		 je	 $LN6@deflate
$LN18@deflate:

; 901  :         block_state bstate;
; 902  : 
; 903  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 904  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 905  :                         (*(configuration_table[s->level].func))(s, flush));

  006bc	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [rbx+176]
  006c2	41 8b d6	 mov	 edx, r14d
  006c5	48 8b cb	 mov	 rcx, rbx
  006c8	83 f8 02	 cmp	 eax, 2
  006cb	75 07		 jne	 SHORT $LN96@deflate
  006cd	e8 00 00 00 00	 call	 deflate_huff
  006d2	eb 21		 jmp	 SHORT $LN118@deflate
$LN96@deflate:
  006d4	83 f8 03	 cmp	 eax, 3
  006d7	75 07		 jne	 SHORT $LN94@deflate
  006d9	e8 00 00 00 00	 call	 deflate_rle
  006de	eb 15		 jmp	 SHORT $LN118@deflate
$LN94@deflate:
  006e0	48 63 83 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rbx+172]
  006e7	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_table+8
  006ee	48 03 c0	 add	 rax, rax
  006f1	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
$LN118@deflate:
  006f5	8b c8		 mov	 ecx, eax
  006f7	8d 40 fe	 lea	 eax, DWORD PTR [rax-2]
  006fa	83 f8 01	 cmp	 eax, 1
  006fd	77 07		 ja	 SHORT $LN17@deflate

; 906  : 
; 907  :         if (bstate == finish_started || bstate == finish_done) {
; 908  :             s->status = FINISH_STATE;

  006ff	c7 43 08 9a 02
	00 00		 mov	 DWORD PTR [rbx+8], 666	; 0000029aH
$LN17@deflate:
  00706	f7 c1 fd ff ff
	ff		 test	 ecx, -3			; fffffffdH
  0070c	0f 84 61 01 00
	00		 je	 $LN14@deflate

; 915  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 916  :              * of deflate should use the same flush parameter to make sure
; 917  :              * that the flush is complete. So we don't have to output an
; 918  :              * empty block here, this will be done at next call. This also
; 919  :              * ensures that for a very small output buffer, we emit at most
; 920  :              * one empty block.
; 921  :              */
; 922  :         }
; 923  :         if (bstate == block_done) {

  00712	83 f9 01	 cmp	 ecx, 1
  00715	75 78		 jne	 SHORT $LN6@deflate

; 924  :             if (flush == Z_PARTIAL_FLUSH) {

  00717	44 3b f1	 cmp	 r14d, ecx
  0071a	75 0a		 jne	 SHORT $LN11@deflate

; 925  :                 _tr_align(s);

  0071c	48 8b cb	 mov	 rcx, rbx
  0071f	e8 00 00 00 00	 call	 _tr_align
  00724	eb 58		 jmp	 SHORT $LN7@deflate
$LN11@deflate:

; 926  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  00726	41 83 fe 05	 cmp	 r14d, 5
  0072a	74 52		 je	 SHORT $LN7@deflate

; 927  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  0072c	45 33 c9	 xor	 r9d, r9d
  0072f	45 33 c0	 xor	 r8d, r8d
  00732	33 d2		 xor	 edx, edx
  00734	48 8b cb	 mov	 rcx, rbx
  00737	e8 00 00 00 00	 call	 _tr_stored_block

; 928  :                 /* For a full flush, this empty block will be recognized
; 929  :                  * as a special marker by inflate_sync().
; 930  :                  */
; 931  :                 if (flush == Z_FULL_FLUSH) {

  0073c	41 83 fe 03	 cmp	 r14d, 3
  00740	75 3c		 jne	 SHORT $LN7@deflate

; 932  :                     CLEAR_HASH(s);             /* forget history */

  00742	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00745	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00749	33 d2		 xor	 edx, edx
  0074b	ff c9		 dec	 ecx
  0074d	66 89 2c 48	 mov	 WORD PTR [rax+rcx*2], bp
  00751	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  00755	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00759	41 ff c8	 dec	 r8d
  0075c	4d 03 c0	 add	 r8, r8
  0075f	e8 00 00 00 00	 call	 memset

; 933  :                     if (s->lookahead == 0) {

  00764	39 ab 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], ebp
  0076a	75 12		 jne	 SHORT $LN7@deflate

; 934  :                         s->strstart = 0;

  0076c	89 ab 94 00 00
	00		 mov	 DWORD PTR [rbx+148], ebp

; 935  :                         s->block_start = 0L;

  00772	89 ab 84 00 00
	00		 mov	 DWORD PTR [rbx+132], ebp

; 936  :                         s->insert = 0;

  00778	89 ab 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], ebp
$LN7@deflate:

; 937  :                     }
; 938  :                 }
; 939  :             }
; 940  :             flush_pending(strm);

  0077e	48 8b cf	 mov	 rcx, rdi
  00781	e8 00 00 00 00	 call	 flush_pending

; 941  :             if (strm->avail_out == 0) {

  00786	39 6f 18	 cmp	 DWORD PTR [rdi+24], ebp
  00789	0f 84 9a fe ff
	ff		 je	 $LN119@deflate
$LN6@deflate:

; 942  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 943  :               return Z_OK;
; 944  :             }
; 945  :         }
; 946  :     }
; 947  :     Assert(strm->avail_out > 0, "bug2");
; 948  : 
; 949  :     if (flush != Z_FINISH) return Z_OK;

  0078f	41 83 fe 04	 cmp	 r14d, 4
  00793	0f 85 97 fe ff
	ff		 jne	 $LN13@deflate

; 950  :     if (s->wrap <= 0) return Z_STREAM_END;

  00799	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  0079c	85 c9		 test	 ecx, ecx
  0079e	7f 09		 jg	 SHORT $LN4@deflate
  007a0	41 8d 46 fd	 lea	 eax, QWORD PTR [r14-3]
  007a4	e9 89 fe ff ff	 jmp	 $LN115@deflate
$LN4@deflate:

; 951  : 
; 952  :     /* Write the trailer */
; 953  : #ifdef GZIP
; 954  :     if (s->wrap == 2) {

  007a9	83 f9 02	 cmp	 ecx, 2
  007ac	0f 85 8a 00 00
	00		 jne	 $LN3@deflate

; 955  :         put_byte(s, (Byte)(strm->adler & 0xff));

  007b2	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  007b5	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  007b9	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007bd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007c0	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007c3	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 956  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  007c6	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  007ca	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007ce	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007d1	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007d4	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 957  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  007d7	0f b6 47 4e	 movzx	 eax, BYTE PTR [rdi+78]
  007db	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007df	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007e2	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007e5	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 958  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  007e8	0f b6 47 4f	 movzx	 eax, BYTE PTR [rdi+79]
  007ec	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007f0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007f3	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007f6	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 959  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  007f9	0f b6 47 0c	 movzx	 eax, BYTE PTR [rdi+12]
  007fd	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00801	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00804	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00807	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 960  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  0080a	0f b6 47 0d	 movzx	 eax, BYTE PTR [rdi+13]
  0080e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00812	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00815	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00818	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 961  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  0081b	0f b6 47 0e	 movzx	 eax, BYTE PTR [rdi+14]
  0081f	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00823	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00826	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00829	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 962  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  0082c	0f b6 47 0f	 movzx	 eax, BYTE PTR [rdi+15]
  00830	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00834	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00837	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 963  :     }
; 964  :     else

  0083a	eb 15		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 965  : #endif
; 966  :     {
; 967  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  0083c	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  00840	48 8b cb	 mov	 rcx, rbx
  00843	e8 00 00 00 00	 call	 putShortMSB

; 968  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00848	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  0084c	e8 00 00 00 00	 call	 putShortMSB
$LN2@deflate:

; 969  :     }
; 970  :     flush_pending(strm);

  00851	48 8b cf	 mov	 rcx, rdi
  00854	e8 00 00 00 00	 call	 flush_pending

; 971  :     /* If avail_out is zero, the application will call deflate again
; 972  :      * to flush the rest.
; 973  :      */
; 974  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  00859	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  0085c	85 c0		 test	 eax, eax
  0085e	7e 05		 jle	 SHORT $LN1@deflate
  00860	f7 d8		 neg	 eax
  00862	89 43 2c	 mov	 DWORD PTR [rbx+44], eax
$LN1@deflate:

; 975  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  00865	39 6b 28	 cmp	 DWORD PTR [rbx+40], ebp
  00868	40 0f 94 c5	 sete	 bpl
  0086c	8b c5		 mov	 eax, ebp
  0086e	e9 bf fd ff ff	 jmp	 $LN115@deflate
$LN14@deflate:

; 909  :         }
; 910  :         if (bstate == need_more || bstate == finish_started) {
; 911  :             if (strm->avail_out == 0) {

  00873	39 6f 18	 cmp	 DWORD PTR [rdi+24], ebp
  00876	0f 85 b4 fd ff
	ff		 jne	 $LN13@deflate

; 912  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
; 913  :             }
; 914  :             return Z_OK;

  0087c	e9 a8 fd ff ff	 jmp	 $LN119@deflate
$LN80@deflate:

; 681  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  00881	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  00888	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN82@deflate:
  0088c	b8 fe ff ff ff	 mov	 eax, -2

; 976  : }

  00891	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00895	41 5e		 pop	 r14
  00897	5f		 pop	 rdi
  00898	5b		 pop	 rbx
  00899	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 206  : {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 207  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 208  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00004	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  00009	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  0000e	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00014	45 8d 41 f9	 lea	 r8d, QWORD PTR [r9-7]
  00018	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00020	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00028	e8 00 00 00 00	 call	 deflateInit2_

; 209  :     /* To do: ignore strm->next_in if we use it as window */
; 210  : }

  0002d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00031	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateEnd
_TEXT	SEGMENT
strm$ = 48
deflateEnd PROC						; COMDAT

; 981  : {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 982  :     int status;
; 983  : 
; 984  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 bd 00 00
	00		 je	 $LN6@deflateEnd
  00012	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00016	48 85 c9	 test	 rcx, rcx
  00019	0f 84 b0 00 00
	00		 je	 $LN6@deflateEnd

; 985  : 
; 986  :     status = strm->state->status;

  0001f	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00024	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00027	8d 47 d6	 lea	 eax, DWORD PTR [rdi-42]
  0002a	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0002d	77 10		 ja	 SHORT $LN10@deflateEnd
  0002f	48 ba 01 00 00
	88 00 00 02 20	 mov	 rdx, 2306405961448816641 ; 2002000088000001H
  00039	48 0f a3 c2	 bt	 rdx, rax
  0003d	72 1d		 jb	 SHORT $LN5@deflateEnd
$LN10@deflateEnd:
  0003f	83 ff 71	 cmp	 edi, 113		; 00000071H
  00042	74 18		 je	 SHORT $LN5@deflateEnd
  00044	81 ff 9a 02 00
	00		 cmp	 edi, 666		; 0000029aH
  0004a	74 10		 je	 SHORT $LN5@deflateEnd

; 987  :     if (status != INIT_STATE &&
; 988  :         status != EXTRA_STATE &&
; 989  :         status != NAME_STATE &&
; 990  :         status != COMMENT_STATE &&
; 991  :         status != HCRC_STATE &&
; 992  :         status != BUSY_STATE &&
; 993  :         status != FINISH_STATE) {
; 994  :       return Z_STREAM_ERROR;

  0004c	b8 fe ff ff ff	 mov	 eax, -2
  00051	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1007 : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN5@deflateEnd:

; 995  :     }
; 996  : 
; 997  :     /* Deallocate in reverse order of allocations: */
; 998  :     TRY_FREE(strm, strm->state->pending_buf);

  0005c	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00060	48 85 d2	 test	 rdx, rdx
  00063	74 07		 je	 SHORT $LN4@deflateEnd
  00065	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00069	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN4@deflateEnd:

; 999  :     TRY_FREE(strm, strm->state->head);

  0006c	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00070	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  00074	48 85 d2	 test	 rdx, rdx
  00077	74 07		 je	 SHORT $LN3@deflateEnd
  00079	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0007d	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN3@deflateEnd:

; 1000 :     TRY_FREE(strm, strm->state->prev);

  00080	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00084	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00088	48 85 d2	 test	 rdx, rdx
  0008b	74 07		 je	 SHORT $LN2@deflateEnd
  0008d	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00091	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN2@deflateEnd:

; 1001 :     TRY_FREE(strm, strm->state->window);

  00094	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00098	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  0009c	48 85 d2	 test	 rdx, rdx
  0009f	74 07		 je	 SHORT $LN1@deflateEnd
  000a1	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000a5	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN1@deflateEnd:

; 1002 : 
; 1003 :     ZFREE(strm, strm->state);

  000a8	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  000ac	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000b0	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1004 :     strm->state = Z_NULL;

  000b3	33 c0		 xor	 eax, eax

; 1005 : 
; 1006 :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  000b5	83 ff 71	 cmp	 edi, 113		; 00000071H
  000b8	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000bd	b9 fd ff ff ff	 mov	 ecx, -3
  000c2	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  000c6	0f 44 c1	 cmove	 eax, ecx

; 1007 : }

  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5b		 pop	 rbx
  000ce	c3		 ret	 0
$LN6@deflateEnd:

; 982  :     int status;
; 983  : 
; 984  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000cf	b8 fe ff ff ff	 mov	 eax, -2

; 1007 : }

  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	5b		 pop	 rbx
  000d9	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateInit2_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 223  : {

$LN23:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 224  :     deflate_state *s;
; 225  :     int wrap = 1;
; 226  :     static const char my_version[] = ZLIB_VERSION;
; 227  : 
; 228  :     ushf *overlay;
; 229  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 230  :      * output size for (length,distance) codes is <= 24 bits.
; 231  :      */
; 232  : 
; 233  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 234  :         stream_size != sizeof(z_stream)) {

  0000c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00014	41 be 01 00 00
	00		 mov	 r14d, 1
  0001a	41 8b f9	 mov	 edi, r9d
  0001d	8b ea		 mov	 ebp, edx
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	45 8b fe	 mov	 r15d, r14d
  00025	48 85 c0	 test	 rax, rax
  00028	0f 84 42 02 00
	00		 je	 $LN14@deflateIni
  0002e	80 38 31	 cmp	 BYTE PTR [rax], 49	; 00000031H
  00031	0f 85 39 02 00
	00		 jne	 $LN14@deflateIni
  00037	83 bc 24 88 00
	00 00 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0003f	0f 85 2b 02 00
	00		 jne	 $LN14@deflateIni

; 236  :     }
; 237  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00045	48 85 c9	 test	 rcx, rcx
  00048	75 0f		 jne	 SHORT $LN13@deflateIni
  0004a	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 320  : }

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	41 5f		 pop	 r15
  00053	41 5e		 pop	 r14
  00055	5f		 pop	 rdi
  00056	5d		 pop	 rbp
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
$LN13@deflateIni:

; 238  : 
; 239  :     strm->msg = Z_NULL;

  00059	33 c9		 xor	 ecx, ecx
  0005b	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00060	48 89 4b 20	 mov	 QWORD PTR [rbx+32], rcx

; 240  :     if (strm->zalloc == (alloc_func)0) {

  00064	48 39 4b 30	 cmp	 QWORD PTR [rbx+48], rcx
  00068	75 0f		 jne	 SHORT $LN12@deflateIni

; 241  : #ifdef Z_SOLO
; 242  :         return Z_STREAM_ERROR;
; 243  : #else
; 244  :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 245  :         strm->opaque = (voidpf)0;

  00071	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  00075	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
$LN12@deflateIni:

; 246  : #endif
; 247  :     }
; 248  :     if (strm->zfree == (free_func)0)

  00079	48 39 4b 38	 cmp	 QWORD PTR [rbx+56], rcx
  0007d	75 0b		 jne	 SHORT $LN11@deflateIni

; 249  : #ifdef Z_SOLO
; 250  :         return Z_STREAM_ERROR;
; 251  : #else
; 252  :         strm->zfree = zcfree;

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00086	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
$LN11@deflateIni:

; 253  : #endif
; 254  : 
; 255  : #ifdef FASTEST
; 256  :     if (level != 0) level = 1;
; 257  : #else
; 258  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0008a	83 fa ff	 cmp	 edx, -1
  0008d	b8 06 00 00 00	 mov	 eax, 6
  00092	0f 44 e8	 cmove	 ebp, eax

; 259  : #endif
; 260  : 
; 261  :     if (windowBits < 0) { /* suppress zlib wrapper */

  00095	45 85 c9	 test	 r9d, r9d
  00098	79 07		 jns	 SHORT $LN9@deflateIni

; 262  :         wrap = 0;

  0009a	44 8b f9	 mov	 r15d, ecx

; 263  :         windowBits = -windowBits;

  0009d	f7 df		 neg	 edi
  0009f	eb 0f		 jmp	 SHORT $LN7@deflateIni
$LN9@deflateIni:

; 264  :     }
; 265  : #ifdef GZIP
; 266  :     else if (windowBits > 15) {

  000a1	41 83 f9 0f	 cmp	 r9d, 15
  000a5	7e 09		 jle	 SHORT $LN7@deflateIni

; 267  :         wrap = 2;       /* write gzip wrapper instead */

  000a7	41 bf 02 00 00
	00		 mov	 r15d, 2

; 268  :         windowBits -= 16;

  000ad	83 ef 10	 sub	 edi, 16
$LN7@deflateIni:

; 269  :     }
; 270  : #endif
; 271  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 272  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 273  :         strategy < 0 || strategy > Z_FIXED) {

  000b0	44 8b 6c 24 70	 mov	 r13d, DWORD PTR memLevel$[rsp]
  000b5	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  000ba	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000be	83 f8 08	 cmp	 eax, 8
  000c1	0f 87 a2 01 00
	00		 ja	 $LN5@deflateIni
  000c7	41 83 f8 08	 cmp	 r8d, 8
  000cb	0f 85 98 01 00
	00		 jne	 $LN5@deflateIni
  000d1	8d 47 f8	 lea	 eax, DWORD PTR [rdi-8]
  000d4	83 f8 07	 cmp	 eax, 7
  000d7	0f 87 8c 01 00
	00		 ja	 $LN5@deflateIni
  000dd	83 fd 09	 cmp	 ebp, 9
  000e0	0f 87 83 01 00
	00		 ja	 $LN5@deflateIni
  000e6	44 8b 64 24 78	 mov	 r12d, DWORD PTR strategy$[rsp]
  000eb	41 83 fc 04	 cmp	 r12d, 4
  000ef	0f 87 74 01 00
	00		 ja	 $LN5@deflateIni

; 275  :     }
; 276  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
; 277  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000f5	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000f9	41 3b f8	 cmp	 edi, r8d
  000fc	b8 09 00 00 00	 mov	 eax, 9
  00101	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  00107	41 8b d6	 mov	 edx, r14d
  0010a	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0010f	0f 44 f8	 cmove	 edi, eax
  00112	ff 53 30	 call	 QWORD PTR [rbx+48]
  00115	48 8b f0	 mov	 rsi, rax

; 278  :     if (s == Z_NULL) return Z_MEM_ERROR;

  00118	48 85 c0	 test	 rax, rax
  0011b	0f 84 41 01 00
	00		 je	 $LN21@deflateIni

; 279  :     strm->state = (struct internal_state FAR *)s;

  00121	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 280  :     s->strm = strm;
; 281  : 
; 282  :     s->wrap = wrap;

  00125	44 89 78 2c	 mov	 DWORD PTR [rax+44], r15d
  00129	48 89 18	 mov	 QWORD PTR [rax], rbx

; 283  :     s->gzhead = Z_NULL;
; 284  :     s->w_bits = windowBits;

  0012c	89 78 48	 mov	 DWORD PTR [rax+72], edi

; 285  :     s->w_size = 1 << s->w_bits;

  0012f	8b cf		 mov	 ecx, edi
  00131	45 33 ff	 xor	 r15d, r15d
  00134	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
  00138	45 8b ce	 mov	 r9d, r14d

; 286  :     s->w_mask = s->w_size - 1;
; 287  : 
; 288  :     s->hash_bits = memLevel + 7;
; 289  :     s->hash_size = 1 << s->hash_bits;
; 290  :     s->hash_mask = s->hash_size - 1;
; 291  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
; 292  : 
; 293  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  0013b	45 8d 47 02	 lea	 r8d, QWORD PTR [r15+2]
  0013f	41 d3 e1	 shl	 r9d, cl
  00142	41 8d 4d 07	 lea	 ecx, DWORD PTR [r13+7]
  00146	44 89 48 44	 mov	 DWORD PTR [rax+68], r9d
  0014a	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  0014e	89 4e 78	 mov	 DWORD PTR [rsi+120], ecx
  00151	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
  00154	41 8b c6	 mov	 eax, r14d
  00157	d3 e0		 shl	 eax, cl
  00159	83 c1 02	 add	 ecx, 2
  0015c	89 46 74	 mov	 DWORD PTR [rsi+116], eax
  0015f	ff c8		 dec	 eax
  00161	89 46 7c	 mov	 DWORD PTR [rsi+124], eax
  00164	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00169	f7 e1		 mul	 ecx
  0016b	d1 ea		 shr	 edx, 1
  0016d	89 96 80 00 00
	00		 mov	 DWORD PTR [rsi+128], edx
  00173	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00177	41 8b d1	 mov	 edx, r9d
  0017a	ff 53 30	 call	 QWORD PTR [rbx+48]

; 294  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0017d	8b 56 44	 mov	 edx, DWORD PTR [rsi+68]
  00180	45 8d 47 02	 lea	 r8d, QWORD PTR [r15+2]
  00184	48 89 46 50	 mov	 QWORD PTR [rsi+80], rax
  00188	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0018c	ff 53 30	 call	 QWORD PTR [rbx+48]

; 295  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  0018f	8b 56 74	 mov	 edx, DWORD PTR [rsi+116]
  00192	45 8d 47 02	 lea	 r8d, QWORD PTR [r15+2]
  00196	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
  0019a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0019e	ff 53 30	 call	 QWORD PTR [rbx+48]

; 296  : 
; 297  :     s->high_water = 0;      /* nothing written to s->window yet */
; 298  : 
; 299  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  001a1	41 8d 4d 06	 lea	 ecx, DWORD PTR [r13+6]
  001a5	44 89 be 18 17
	00 00		 mov	 DWORD PTR [rsi+5912], r15d
  001ac	41 d3 e6	 shl	 r14d, cl
  001af	48 89 46 68	 mov	 QWORD PTR [rsi+104], rax

; 300  : 
; 301  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  001b3	45 8d 47 04	 lea	 r8d, QWORD PTR [r15+4]
  001b7	44 89 b6 f0 16
	00 00		 mov	 DWORD PTR [rsi+5872], r14d
  001be	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001c2	41 8b d6	 mov	 edx, r14d
  001c5	ff 53 30	 call	 QWORD PTR [rbx+48]
  001c8	48 8b d0	 mov	 rdx, rax

; 302  :     s->pending_buf = (uchf *) overlay;

  001cb	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax

; 303  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  001cf	8b 86 f0 16 00
	00		 mov	 eax, DWORD PTR [rsi+5872]
  001d5	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [rax*4]
  001dc	89 4e 18	 mov	 DWORD PTR [rsi+24], ecx

; 304  : 
; 305  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 306  :         s->pending_buf == Z_NULL) {

  001df	4c 39 7e 50	 cmp	 QWORD PTR [rsi+80], r15
  001e3	74 63		 je	 SHORT $LN1@deflateIni
  001e5	4c 39 7e 60	 cmp	 QWORD PTR [rsi+96], r15
  001e9	74 5d		 je	 SHORT $LN1@deflateIni
  001eb	4c 39 7e 68	 cmp	 QWORD PTR [rsi+104], r15
  001ef	74 57		 je	 SHORT $LN1@deflateIni
  001f1	48 85 d2	 test	 rdx, rdx
  001f4	74 52		 je	 SHORT $LN1@deflateIni

; 311  :     }
; 312  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001f6	8b c8		 mov	 ecx, eax
  001f8	48 d1 e8	 shr	 rax, 1

; 313  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
; 314  : 
; 315  :     s->level = level;

  001fb	89 ae ac 00 00
	00		 mov	 DWORD PTR [rsi+172], ebp
  00201	48 8d 04 42	 lea	 rax, QWORD PTR [rdx+rax*2]

; 316  :     s->strategy = strategy;

  00205	44 89 a6 b0 00
	00 00		 mov	 DWORD PTR [rsi+176], r12d

; 317  :     s->method = (Byte)method;

  0020c	c6 46 3c 08	 mov	 BYTE PTR [rsi+60], 8
  00210	48 89 86 f8 16
	00 00		 mov	 QWORD PTR [rsi+5880], rax
  00217	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  0021b	48 03 c8	 add	 rcx, rax
  0021e	48 89 8e e8 16
	00 00		 mov	 QWORD PTR [rsi+5864], rcx

; 318  : 
; 319  :     return deflateReset(strm);

  00225	48 8b cb	 mov	 rcx, rbx
  00228	e8 00 00 00 00	 call	 deflateReset
$LN20@deflateIni:
  0022d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
$LN19@deflateIni:
  00232	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  00237	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]

; 320  : }

  0023c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00240	41 5f		 pop	 r15
  00242	41 5e		 pop	 r14
  00244	5f		 pop	 rdi
  00245	5d		 pop	 rbp
  00246	5b		 pop	 rbx
  00247	c3		 ret	 0
$LN1@deflateIni:

; 307  :         s->status = FINISH_STATE;
; 308  :         strm->msg = ERR_MSG(Z_MEM_ERROR);

  00248	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48
  0024f	c7 46 08 9a 02
	00 00		 mov	 DWORD PTR [rsi+8], 666	; 0000029aH

; 309  :         deflateEnd (strm);

  00256	48 8b cb	 mov	 rcx, rbx
  00259	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0025d	e8 00 00 00 00	 call	 deflateEnd
$LN21@deflateIni:

; 310  :         return Z_MEM_ERROR;

  00262	b8 fc ff ff ff	 mov	 eax, -4
  00267	eb c4		 jmp	 SHORT $LN20@deflateIni
$LN5@deflateIni:

; 274  :         return Z_STREAM_ERROR;

  00269	b8 fe ff ff ff	 mov	 eax, -2
  0026e	eb c2		 jmp	 SHORT $LN19@deflateIni
$LN14@deflateIni:

; 235  :         return Z_VERSION_ERROR;

  00270	b8 fa ff ff ff	 mov	 eax, -6

; 320  : }

  00275	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00279	41 5f		 pop	 r15
  0027b	41 5e		 pop	 r14
  0027d	5f		 pop	 rdi
  0027e	5d		 pop	 rbp
  0027f	5b		 pop	 rbx
  00280	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
strm$ = 80
dictionary$ = 88
dictLength$ = 96
deflateSetDictionary PROC				; COMDAT

; 327  : {

$LN26:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	41 8b f8	 mov	 edi, r8d
  0000c	48 8b ea	 mov	 rbp, rdx
  0000f	48 8b f1	 mov	 rsi, rcx

; 328  :     deflate_state *s;
; 329  :     uInt str, n;
; 330  :     int wrap;
; 331  :     unsigned avail;
; 332  :     z_const unsigned char *next;
; 333  : 
; 334  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)

  00012	48 85 c9	 test	 rcx, rcx
  00015	0f 84 fa 01 00
	00		 je	 $LN12@deflateSet
  0001b	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  0001f	48 85 db	 test	 rbx, rbx
  00022	0f 84 ed 01 00
	00		 je	 $LN12@deflateSet
  00028	48 85 d2	 test	 rdx, rdx
  0002b	0f 84 e4 01 00
	00		 je	 $LN12@deflateSet

; 336  :     s = strm->state;
; 337  :     wrap = s->wrap;

  00031	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00036	44 8b 73 2c	 mov	 r14d, DWORD PTR [rbx+44]

; 338  :     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)

  0003a	41 83 fe 02	 cmp	 r14d, 2
  0003e	0f 84 be 01 00
	00		 je	 $LN10@deflateSet
  00044	41 83 fe 01	 cmp	 r14d, 1
  00048	75 0a		 jne	 SHORT $LN9@deflateSet
  0004a	83 7b 08 2a	 cmp	 DWORD PTR [rbx+8], 42	; 0000002aH
  0004e	0f 85 ae 01 00
	00		 jne	 $LN10@deflateSet
$LN9@deflateSet:
  00054	83 bb 9c 00 00
	00 00		 cmp	 DWORD PTR [rbx+156], 0
  0005b	0f 85 a1 01 00
	00		 jne	 $LN10@deflateSet

; 340  : 
; 341  :     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
; 342  :     if (wrap == 1)

  00061	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00066	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  0006b	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00070	41 83 fe 01	 cmp	 r14d, 1
  00074	75 0b		 jne	 SHORT $LN8@deflateSet

; 343  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  00076	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00079	e8 00 00 00 00	 call	 adler32
  0007e	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
$LN8@deflateSet:

; 344  :     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

  00081	45 33 ed	 xor	 r13d, r13d
  00084	44 89 6b 2c	 mov	 DWORD PTR [rbx+44], r13d

; 345  : 
; 346  :     /* if dictionary would fill window, just replace the history */
; 347  :     if (dictLength >= s->w_size) {

  00088	3b 7b 44	 cmp	 edi, DWORD PTR [rbx+68]
  0008b	72 48		 jb	 SHORT $LN7@deflateSet

; 348  :         if (wrap == 0) {            /* already empty otherwise */

  0008d	45 85 f6	 test	 r14d, r14d
  00090	75 38		 jne	 SHORT $LN6@deflateSet

; 349  :             CLEAR_HASH(s);

  00092	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00095	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00099	33 d2		 xor	 edx, edx
  0009b	ff c9		 dec	 ecx
  0009d	66 44 89 2c 48	 mov	 WORD PTR [rax+rcx*2], r13w
  000a2	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  000a6	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000aa	41 ff c8	 dec	 r8d
  000ad	4d 03 c0	 add	 r8, r8
  000b0	e8 00 00 00 00	 call	 memset

; 350  :             s->strstart = 0;

  000b5	44 89 ab 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r13d

; 351  :             s->block_start = 0L;

  000bc	44 89 ab 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r13d

; 352  :             s->insert = 0;

  000c3	44 89 ab 0c 17
	00 00		 mov	 DWORD PTR [rbx+5900], r13d
$LN6@deflateSet:

; 353  :         }
; 354  :         dictionary += dictLength - s->w_size;  /* use the tail */

  000ca	2b 7b 44	 sub	 edi, DWORD PTR [rbx+68]
  000cd	8b c7		 mov	 eax, edi

; 355  :         dictLength = s->w_size;

  000cf	8b 7b 44	 mov	 edi, DWORD PTR [rbx+68]
  000d2	48 03 e8	 add	 rbp, rax
$LN7@deflateSet:

; 356  :     }
; 357  : 
; 358  :     /* insert dictionary into window and hash */
; 359  :     avail = strm->avail_in;

  000d5	44 8b 7e 08	 mov	 r15d, DWORD PTR [rsi+8]

; 360  :     next = strm->next_in;

  000d9	4c 8b 26	 mov	 r12, QWORD PTR [rsi]

; 361  :     strm->avail_in = dictLength;
; 362  :     strm->next_in = (z_const Bytef *)dictionary;
; 363  :     fill_window(s);

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	89 7e 08	 mov	 DWORD PTR [rsi+8], edi
  000e2	48 89 2e	 mov	 QWORD PTR [rsi], rbp
  000e5	e8 00 00 00 00	 call	 fill_window

; 364  :     while (s->lookahead >= MIN_MATCH) {

  000ea	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  000f1	0f 82 a1 00 00
	00		 jb	 $LN4@deflateSet
  000f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL5@deflateSet:

; 365  :         str = s->strstart;

  00100	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 366  :         n = s->lookahead - (MIN_MATCH-1);

  00107	44 8b 9b 9c 00
	00 00		 mov	 r11d, DWORD PTR [rbx+156]
  0010e	41 8d 7a 02	 lea	 edi, DWORD PTR [r10+2]
  00112	41 83 eb 02	 sub	 r11d, 2
  00116	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL3@deflateSet:

; 367  :         do {
; 368  :             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00120	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00124	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 369  : #ifndef FASTEST
; 370  :             s->prev[str & s->w_mask] = s->head[s->ins_h];

  0012a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0012e	44 0f b6 0c 07	 movzx	 r9d, BYTE PTR [rdi+rax]
  00133	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00136	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  0013a	d3 e0		 shl	 eax, cl
  0013c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]

; 371  : #endif
; 372  :             s->head[s->ins_h] = (Pos)str;
; 373  :             str++;

  00140	8d 7f 01	 lea	 edi, DWORD PTR [rdi+1]
  00143	44 33 c8	 xor	 r9d, eax
  00146	41 8b c2	 mov	 eax, r10d
  00149	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0014d	4c 23 c0	 and	 r8, rax
  00150	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00154	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00159	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0015e	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00161	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00165	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0016a	41 ff c2	 inc	 r10d

; 374  :         } while (--n);

  0016d	41 ff cb	 dec	 r11d
  00170	75 ae		 jne	 SHORT $LL3@deflateSet

; 375  :         s->strstart = str;
; 376  :         s->lookahead = MIN_MATCH-1;
; 377  :         fill_window(s);

  00172	48 8b cb	 mov	 rcx, rbx
  00175	44 89 93 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r10d
  0017c	c7 83 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+156], 2
  00186	e8 00 00 00 00	 call	 fill_window
  0018b	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  00192	0f 83 68 ff ff
	ff		 jae	 $LL5@deflateSet
$LN4@deflateSet:

; 378  :     }
; 379  :     s->strstart += s->lookahead;

  00198	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]

; 380  :     s->block_start = (long)s->strstart;
; 381  :     s->insert = s->lookahead;
; 382  :     s->lookahead = 0;
; 383  :     s->match_length = s->prev_length = MIN_MATCH-1;
; 384  :     s->match_available = 0;

  0019e	44 89 ab 90 00
	00 00		 mov	 DWORD PTR [rbx+144], r13d
  001a5	44 89 ab 9c 00
	00 00		 mov	 DWORD PTR [rbx+156], r13d
  001ac	01 8b 94 00 00
	00		 add	 DWORD PTR [rbx+148], ecx
  001b2	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  001b8	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  001bd	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  001c3	89 8b 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], ecx
  001c9	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  001d3	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2

; 385  :     strm->next_in = next;

  001dd	4c 89 26	 mov	 QWORD PTR [rsi], r12
  001e0	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 386  :     strm->avail_in = avail;

  001e5	44 89 7e 08	 mov	 DWORD PTR [rsi+8], r15d
  001e9	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 387  :     s->wrap = wrap;

  001ee	44 89 73 2c	 mov	 DWORD PTR [rbx+44], r14d
  001f2	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 388  :     return Z_OK;

  001f7	33 c0		 xor	 eax, eax

; 389  : }

  001f9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001fd	5f		 pop	 rdi
  001fe	5e		 pop	 rsi
  001ff	5d		 pop	 rbp
  00200	5b		 pop	 rbx
  00201	c3		 ret	 0
$LN10@deflateSet:

; 339  :         return Z_STREAM_ERROR;

  00202	b8 fe ff ff ff	 mov	 eax, -2
  00207	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 389  : }

  0020c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00210	5f		 pop	 rdi
  00211	5e		 pop	 rsi
  00212	5d		 pop	 rbp
  00213	5b		 pop	 rbx
  00214	c3		 ret	 0
$LN12@deflateSet:

; 335  :         return Z_STREAM_ERROR;

  00215	b8 fe ff ff ff	 mov	 eax, -2

; 389  : }

  0021a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0021e	5f		 pop	 rdi
  0021f	5e		 pop	 rsi
  00220	5d		 pop	 rbp
  00221	5b		 pop	 rbx
  00222	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateResetKeep
_TEXT	SEGMENT
strm$ = 48
deflateResetKeep PROC					; COMDAT

; 394  : {

$LN9:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 395  :     deflate_state *s;
; 396  : 
; 397  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 398  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 9d 00 00
	00		 je	 $LN2@deflateRes
  00016	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001a	48 85 ff	 test	 rdi, rdi
  0001d	0f 84 90 00 00
	00		 je	 $LN2@deflateRes
  00023	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  00028	0f 84 85 00 00
	00		 je	 $LN2@deflateRes
  0002e	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00033	74 7e		 je	 SHORT $LN2@deflateRes

; 400  :     }
; 401  : 
; 402  :     strm->total_in = strm->total_out = 0;
; 403  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
; 404  :     strm->data_type = Z_UNKNOWN;

  00035	c7 41 48 02 00
	00 00		 mov	 DWORD PTR [rcx+72], 2
  0003c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00041	33 f6		 xor	 esi, esi
  00043	89 71 1c	 mov	 DWORD PTR [rcx+28], esi
  00046	89 71 0c	 mov	 DWORD PTR [rcx+12], esi
  00049	48 89 71 20	 mov	 QWORD PTR [rcx+32], rsi

; 405  : 
; 406  :     s = (deflate_state *)strm->state;
; 407  :     s->pending = 0;
; 408  :     s->pending_out = s->pending_buf;

  0004d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00051	89 77 28	 mov	 DWORD PTR [rdi+40], esi
  00054	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 409  : 
; 410  :     if (s->wrap < 0) {

  00058	8b 47 2c	 mov	 eax, DWORD PTR [rdi+44]
  0005b	85 c0		 test	 eax, eax
  0005d	79 05		 jns	 SHORT $LN1@deflateRes

; 411  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  0005f	f7 d8		 neg	 eax
  00061	89 47 2c	 mov	 DWORD PTR [rdi+44], eax
$LN1@deflateRes:

; 412  :     }
; 413  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  00064	8b 4f 2c	 mov	 ecx, DWORD PTR [rdi+44]
  00067	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  0006c	b8 71 00 00 00	 mov	 eax, 113		; 00000071H
  00071	85 c9		 test	 ecx, ecx
  00073	0f 45 c2	 cmovne	 eax, edx

; 414  :     strm->adler =
; 415  : #ifdef GZIP
; 416  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 417  : #endif
; 418  :         adler32(0L, Z_NULL, 0);

  00076	45 33 c0	 xor	 r8d, r8d
  00079	33 d2		 xor	 edx, edx
  0007b	89 47 08	 mov	 DWORD PTR [rdi+8], eax
  0007e	83 f9 02	 cmp	 ecx, 2
  00081	75 09		 jne	 SHORT $LN6@deflateRes
  00083	33 c9		 xor	 ecx, ecx
  00085	e8 00 00 00 00	 call	 crc32
  0008a	eb 07		 jmp	 SHORT $LN7@deflateRes
$LN6@deflateRes:
  0008c	33 c9		 xor	 ecx, ecx
  0008e	e8 00 00 00 00	 call	 adler32
$LN7@deflateRes:
  00093	89 43 4c	 mov	 DWORD PTR [rbx+76], eax

; 419  :     s->last_flush = Z_NO_FLUSH;
; 420  : 
; 421  :     _tr_init(s);

  00096	48 8b cf	 mov	 rcx, rdi
  00099	89 77 40	 mov	 DWORD PTR [rdi+64], esi
  0009c	e8 00 00 00 00	 call	 _tr_init
  000a1	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 422  : 
; 423  :     return Z_OK;

  000a6	33 c0		 xor	 eax, eax

; 424  : }

  000a8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
$LN2@deflateRes:

; 399  :         return Z_STREAM_ERROR;

  000b3	b8 fe ff ff ff	 mov	 eax, -2

; 424  : }

  000b8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
deflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateReset
_TEXT	SEGMENT
strm$ = 48
deflateReset PROC					; COMDAT

; 429  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 430  :     int ret;
; 431  : 
; 432  :     ret = deflateResetKeep(strm);

  0000d	e8 00 00 00 00	 call	 deflateResetKeep
  00012	8b d8		 mov	 ebx, eax

; 433  :     if (ret == Z_OK)

  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN1@deflateRes

; 434  :         lm_init(strm->state);

  00018	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0001c	e8 00 00 00 00	 call	 lm_init

; 435  :     return ret;

  00021	8b c3		 mov	 eax, ebx
$LN1@deflateRes:

; 436  : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
deflateSetHeader PROC					; COMDAT

; 443  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 16		 je	 SHORT $LN2@deflateSet
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 0d		 je	 SHORT $LN2@deflateSet

; 444  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  0000e	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00012	75 07		 jne	 SHORT $LN2@deflateSet

; 445  :     strm->state->gzhead = head;

  00014	48 89 50 30	 mov	 QWORD PTR [rax+48], rdx

; 446  :     return Z_OK;

  00018	33 c0		 xor	 eax, eax

; 447  : }

  0001a	c3		 ret	 0
$LN2@deflateSet:

; 443  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2

; 447  : }

  00020	c3		 ret	 0
deflateSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflatePending
_TEXT	SEGMENT
strm$ = 8
pending$ = 16
bits$ = 24
deflatePending PROC					; COMDAT

; 455  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 28		 je	 SHORT $LN3@deflatePen
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 1f		 je	 SHORT $LN3@deflatePen

; 456  :     if (pending != Z_NULL)

  0000e	48 85 d2	 test	 rdx, rdx
  00011	74 05		 je	 SHORT $LN2@deflatePen

; 457  :         *pending = strm->state->pending;

  00013	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00016	89 02		 mov	 DWORD PTR [rdx], eax
$LN2@deflatePen:

; 458  :     if (bits != Z_NULL)

  00018	4d 85 c0	 test	 r8, r8
  0001b	74 0d		 je	 SHORT $LN1@deflatePen

; 459  :         *bits = strm->state->bi_valid;

  0001d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00021	8b 88 14 17 00
	00		 mov	 ecx, DWORD PTR [rax+5908]
  00027	41 89 08	 mov	 DWORD PTR [r8], ecx
$LN1@deflatePen:

; 460  :     return Z_OK;

  0002a	33 c0		 xor	 eax, eax

; 461  : }

  0002c	c3		 ret	 0
$LN3@deflatePen:

; 455  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002d	b8 fe ff ff ff	 mov	 eax, -2

; 461  : }

  00032	c3		 ret	 0
deflatePending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
deflatePrime PROC					; COMDAT

; 468  : {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b f8	 mov	 edi, r8d
  0000d	8b da		 mov	 ebx, edx

; 469  :     deflate_state *s;
; 470  :     int put;
; 471  : 
; 472  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 97 00 00
	00		 je	 $LN6@deflatePri
  00018	4c 8b 51 28	 mov	 r10, QWORD PTR [rcx+40]
  0001c	4d 85 d2	 test	 r10, r10
  0001f	0f 84 8a 00 00
	00		 je	 $LN6@deflatePri

; 473  :     s = strm->state;
; 474  :     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))

  00025	49 8b 42 20	 mov	 rax, QWORD PTR [r10+32]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	49 39 82 f8 16
	00 00		 cmp	 QWORD PTR [r10+5880], rax
  00034	73 1a		 jae	 SHORT $LL4@deflatePri

; 475  :         return Z_BUF_ERROR;

  00036	b8 fb ff ff ff	 mov	 eax, -5

; 487  : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@deflatePri:

; 476  :     do {
; 477  :         put = Buf_size - s->bi_valid;

  00050	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]

; 478  :         if (put > bits)
; 479  :             put = bits;
; 480  :         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	41 bb 10 00 00
	00		 mov	 r11d, 16
  00062	44 2b da	 sub	 r11d, edx
  00065	44 3b db	 cmp	 r11d, ebx
  00068	44 0f 4f db	 cmovg	 r11d, ebx
  0006c	41 8b cb	 mov	 ecx, r11d
  0006f	66 d3 e0	 shl	 ax, cl
  00072	8b ca		 mov	 ecx, edx
  00074	66 ff c8	 dec	 ax
  00077	66 23 c7	 and	 ax, di
  0007a	66 d3 e0	 shl	 ax, cl

; 481  :         s->bi_valid += put;
; 482  :         _tr_flush_bits(s);

  0007d	49 8b ca	 mov	 rcx, r10
  00080	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00088	42 8d 04 1a	 lea	 eax, DWORD PTR [rdx+r11]
  0008c	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
  00093	e8 00 00 00 00	 call	 _tr_flush_bits

; 483  :         value >>= put;

  00098	41 8b cb	 mov	 ecx, r11d
  0009b	d3 ff		 sar	 edi, cl

; 484  :         bits -= put;

  0009d	41 2b db	 sub	 ebx, r11d

; 485  :     } while (bits);

  000a0	75 ae		 jne	 SHORT $LL4@deflatePri

; 486  :     return Z_OK;

  000a2	33 c0		 xor	 eax, eax

; 487  : }

  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
$LN6@deflatePri:

; 469  :     deflate_state *s;
; 470  :     int put;
; 471  : 
; 472  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000af	b8 fe ff ff ff	 mov	 eax, -2

; 487  : }

  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateParams
_TEXT	SEGMENT
strm$ = 48
level$ = 56
strategy$ = 64
deflateParams PROC					; COMDAT

; 494  : {

$LN16:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 495  :     deflate_state *s;
; 496  :     compress_func func;
; 497  :     int err = Z_OK;

  00015	45 33 f6	 xor	 r14d, r14d
  00018	41 8b f0	 mov	 esi, r8d
  0001b	8b fa		 mov	 edi, edx
  0001d	4c 8b d1	 mov	 r10, rcx
  00020	45 8b ce	 mov	 r9d, r14d

; 498  : 
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00023	48 85 c9	 test	 rcx, rcx
  00026	0f 84 ce 00 00
	00		 je	 $LN8@deflatePar
  0002c	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00030	48 85 db	 test	 rbx, rbx
  00033	0f 84 c1 00 00
	00		 je	 $LN8@deflatePar

; 500  :     s = strm->state;
; 501  : 
; 502  : #ifdef FASTEST
; 503  :     if (level != 0) level = 1;
; 504  : #else
; 505  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  00039	83 fa ff	 cmp	 edx, -1
  0003c	75 05		 jne	 SHORT $LN7@deflatePar
  0003e	8d 7a 07	 lea	 edi, QWORD PTR [rdx+7]

; 506  : #endif
; 507  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00041	eb 09		 jmp	 SHORT $LN13@deflatePar
$LN7@deflatePar:
  00043	83 fa 09	 cmp	 edx, 9
  00046	0f 87 ae 00 00
	00		 ja	 $LN8@deflatePar
$LN13@deflatePar:
  0004c	41 83 f8 04	 cmp	 r8d, 4
  00050	0f 87 a4 00 00
	00		 ja	 $LN8@deflatePar

; 508  :         return Z_STREAM_ERROR;
; 509  :     }
; 510  :     func = configuration_table[s->level].func;
; 511  : 
; 512  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 513  :         strm->total_in != 0) {

  00056	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0005b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:configuration_table
  00062	44 3b 83 b0 00
	00 00		 cmp	 r8d, DWORD PTR [rbx+176]
  00069	75 1c		 jne	 SHORT $LN3@deflatePar
  0006b	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00072	48 63 c7	 movsxd	 rax, edi
  00075	48 03 c0	 add	 rax, rax
  00078	48 03 c9	 add	 rcx, rcx
  0007b	48 8b 44 c5 08	 mov	 rax, QWORD PTR [rbp+rax*8+8]
  00080	48 39 44 cd 08	 cmp	 QWORD PTR [rbp+rcx*8+8], rax
  00085	74 23		 je	 SHORT $LN2@deflatePar
$LN3@deflatePar:
  00087	45 39 4a 0c	 cmp	 DWORD PTR [r10+12], r9d
  0008b	74 1d		 je	 SHORT $LN2@deflatePar

; 514  :         /* Flush the last buffer: */
; 515  :         err = deflate(strm, Z_BLOCK);

  0008d	ba 05 00 00 00	 mov	 edx, 5
  00092	49 8b ca	 mov	 rcx, r10
  00095	e8 00 00 00 00	 call	 deflate
  0009a	44 8b c8	 mov	 r9d, eax

; 516  :         if (err == Z_BUF_ERROR && s->pending == 0)

  0009d	83 f8 fb	 cmp	 eax, -5
  000a0	75 08		 jne	 SHORT $LN2@deflatePar
  000a2	44 39 73 28	 cmp	 DWORD PTR [rbx+40], r14d
  000a6	45 0f 44 ce	 cmove	 r9d, r14d
$LN2@deflatePar:

; 517  :             err = Z_OK;
; 518  :     }
; 519  :     if (s->level != level) {

  000aa	39 bb ac 00 00
	00		 cmp	 DWORD PTR [rbx+172], edi
  000b0	74 38		 je	 SHORT $LN1@deflatePar

; 520  :         s->level = level;

  000b2	89 bb ac 00 00
	00		 mov	 DWORD PTR [rbx+172], edi

; 521  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  000b8	48 63 cf	 movsxd	 rcx, edi
  000bb	48 03 c9	 add	 rcx, rcx
  000be	0f b7 44 cd 02	 movzx	 eax, WORD PTR [rbp+rcx*8+2]
  000c3	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 522  :         s->good_match       = configuration_table[level].good_length;

  000c9	0f b7 44 cd 00	 movzx	 eax, WORD PTR [rbp+rcx*8]
  000ce	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 523  :         s->nice_match       = configuration_table[level].nice_length;

  000d4	0f b7 44 cd 04	 movzx	 eax, WORD PTR [rbp+rcx*8+4]
  000d9	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 524  :         s->max_chain_length = configuration_table[level].max_chain;

  000df	0f b7 44 cd 06	 movzx	 eax, WORD PTR [rbp+rcx*8+6]
  000e4	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
$LN1@deflatePar:

; 525  :     }
; 526  :     s->strategy = strategy;

  000ea	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000ef	89 b3 b0 00 00
	00		 mov	 DWORD PTR [rbx+176], esi

; 527  :     return err;

  000f5	41 8b c1	 mov	 eax, r9d
  000f8	eb 05		 jmp	 SHORT $LN10@deflatePar
$LN8@deflatePar:

; 498  : 
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000fa	b8 fe ff ff ff	 mov	 eax, -2
$LN10@deflatePar:

; 528  : }

  000ff	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00104	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00109	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0010e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00112	41 5e		 pop	 r14
  00114	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateTune
_TEXT	SEGMENT
strm$ = 8
good_length$ = 16
max_lazy$ = 24
nice_length$ = 32
max_chain$ = 40
deflateTune PROC					; COMDAT

; 538  :     deflate_state *s;
; 539  : 
; 540  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2a		 je	 SHORT $LN1@deflateTun
  00005	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 21		 je	 SHORT $LN1@deflateTun

; 541  :     s = strm->state;
; 542  :     s->good_match = good_length;
; 543  :     s->max_lazy_match = max_lazy;
; 544  :     s->nice_match = nice_length;
; 545  :     s->max_chain_length = max_chain;

  0000e	8b 44 24 28	 mov	 eax, DWORD PTR max_chain$[rsp]
  00012	89 91 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], edx
  00018	44 89 81 a8 00
	00 00		 mov	 DWORD PTR [rcx+168], r8d
  0001f	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 546  :     return Z_OK;

  00025	33 c0		 xor	 eax, eax
  00027	44 89 89 b8 00
	00 00		 mov	 DWORD PTR [rcx+184], r9d

; 547  : }

  0002e	c3		 ret	 0
$LN1@deflateTun:

; 538  :     deflate_state *s;
; 539  : 
; 540  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2

; 547  : }

  00034	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateBound
_TEXT	SEGMENT
strm$ = 8
sourceLen$ = 16
deflateBound PROC					; COMDAT

; 570  :     deflate_state *s;
; 571  :     uLong complen, wraplen;
; 572  :     Bytef *str;
; 573  : 
; 574  :     /* conservative upper bound for compressed data */
; 575  :     complen = sourceLen +
; 576  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

  00000	44 8d 5a 3f	 lea	 r11d, DWORD PTR [rdx+63]
  00004	44 8d 42 07	 lea	 r8d, DWORD PTR [rdx+7]
  00008	44 8b d2	 mov	 r10d, edx
  0000b	41 c1 eb 06	 shr	 r11d, 6
  0000f	41 c1 e8 03	 shr	 r8d, 3
  00013	44 03 da	 add	 r11d, edx
  00016	41 83 c0 05	 add	 r8d, 5
  0001a	45 03 d8	 add	 r11d, r8d

; 577  : 
; 578  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 579  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0001d	48 85 c9	 test	 rcx, rcx
  00020	0f 84 e0 00 00
	00		 je	 $LN20@deflateBou
  00026	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  0002a	4d 85 c9	 test	 r9, r9
  0002d	0f 84 d3 00 00
	00		 je	 $LN20@deflateBou

; 581  : 
; 582  :     /* compute wrapper length */
; 583  :     s = strm->state;
; 584  :     switch (s->wrap) {

  00033	41 8b 49 2c	 mov	 ecx, DWORD PTR [r9+44]
  00037	85 c9		 test	 ecx, ecx
  00039	0f 84 91 00 00
	00		 je	 $LN17@deflateBou
  0003f	ff c9		 dec	 ecx
  00041	74 77		 je	 SHORT $LN16@deflateBou
  00043	ff c9		 dec	 ecx
  00045	74 0b		 je	 SHORT $LN15@deflateBou

; 610  :     default:                                /* for compiler happiness */
; 611  :         wraplen = 6;

  00047	41 b8 06 00 00
	00		 mov	 r8d, 6
  0004d	e9 81 00 00 00	 jmp	 $LN18@deflateBou
$LN15@deflateBou:

; 591  :     case 2:                                 /* gzip wrapper */
; 592  :         wraplen = 18;
; 593  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  00052	49 8b 51 30	 mov	 rdx, QWORD PTR [r9+48]
  00056	41 b8 12 00 00
	00		 mov	 r8d, 18
  0005c	48 85 d2	 test	 rdx, rdx
  0005f	74 72		 je	 SHORT $LN18@deflateBou

; 594  :             if (s->gzhead->extra != Z_NULL)

  00061	48 83 7a 10 00	 cmp	 QWORD PTR [rdx+16], 0
  00066	74 08		 je	 SHORT $LN13@deflateBou

; 595  :                 wraplen += 2 + s->gzhead->extra_len;

  00068	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  0006c	41 83 c0 14	 add	 r8d, 20
$LN13@deflateBou:

; 596  :             str = s->gzhead->name;

  00070	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]

; 597  :             if (str != Z_NULL)

  00074	48 85 c9	 test	 rcx, rcx
  00077	74 15		 je	 SHORT $LN9@deflateBou
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@deflateBou:

; 598  :                 do {
; 599  :                     wraplen++;
; 600  :                 } while (*str++);

  00080	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00083	41 ff c0	 inc	 r8d
  00086	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  0008a	84 c0		 test	 al, al
  0008c	75 f2		 jne	 SHORT $LL11@deflateBou
$LN9@deflateBou:

; 601  :             str = s->gzhead->comment;

  0008e	48 8b 4a 30	 mov	 rcx, QWORD PTR [rdx+48]

; 602  :             if (str != Z_NULL)

  00092	48 85 c9	 test	 rcx, rcx
  00095	74 17		 je	 SHORT $LN5@deflateBou
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@deflateBou:

; 603  :                 do {
; 604  :                     wraplen++;
; 605  :                 } while (*str++);

  000a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000a3	41 ff c0	 inc	 r8d
  000a6	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  000aa	84 c0		 test	 al, al
  000ac	75 f2		 jne	 SHORT $LL7@deflateBou
$LN5@deflateBou:

; 606  :             if (s->gzhead->hcrc)

  000ae	83 7a 3c 00	 cmp	 DWORD PTR [rdx+60], 0
  000b2	74 1f		 je	 SHORT $LN18@deflateBou

; 607  :                 wraplen += 2;

  000b4	41 83 c0 02	 add	 r8d, 2

; 608  :         }
; 609  :         break;

  000b8	eb 19		 jmp	 SHORT $LN18@deflateBou
$LN16@deflateBou:

; 587  :         break;
; 588  :     case 1:                                 /* zlib wrapper */
; 589  :         wraplen = 6 + (s->strstart ? 4 : 0);

  000ba	41 8b 81 94 00
	00 00		 mov	 eax, DWORD PTR [r9+148]
  000c1	f7 d8		 neg	 eax
  000c3	45 1b c0	 sbb	 r8d, r8d
  000c6	41 83 e0 04	 and	 r8d, 4
  000ca	41 83 c0 06	 add	 r8d, 6

; 590  :         break;

  000ce	eb 03		 jmp	 SHORT $LN18@deflateBou
$LN17@deflateBou:

; 585  :     case 0:                                 /* raw deflate */
; 586  :         wraplen = 0;

  000d0	45 33 c0	 xor	 r8d, r8d
$LN18@deflateBou:

; 612  :     }
; 613  : 
; 614  :     /* if not default parameters, return conservative bound */
; 615  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  000d3	41 83 79 48 0f	 cmp	 DWORD PTR [r9+72], 15
  000d8	75 27		 jne	 SHORT $LN1@deflateBou
  000da	41 83 79 78 0f	 cmp	 DWORD PTR [r9+120], 15
  000df	75 20		 jne	 SHORT $LN1@deflateBou

; 617  : 
; 618  :     /* default settings: return tight bound for that case */
; 619  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 620  :            (sourceLen >> 25) + 13 - 6 + wraplen;

  000e1	41 8b d2	 mov	 edx, r10d
  000e4	41 8b ca	 mov	 ecx, r10d
  000e7	41 8b c2	 mov	 eax, r10d
  000ea	c1 ea 0e	 shr	 edx, 14
  000ed	c1 e8 0c	 shr	 eax, 12
  000f0	c1 e9 19	 shr	 ecx, 25
  000f3	41 03 d0	 add	 edx, r8d
  000f6	83 c0 07	 add	 eax, 7
  000f9	03 d1		 add	 edx, ecx
  000fb	03 c2		 add	 eax, edx
  000fd	41 03 c2	 add	 eax, r10d

; 621  : }

  00100	c3		 ret	 0
$LN1@deflateBou:

; 616  :         return complen + wraplen;

  00101	43 8d 04 18	 lea	 eax, DWORD PTR [r8+r11]

; 621  : }

  00105	c3		 ret	 0
$LN20@deflateBou:

; 580  :         return complen + 6;

  00106	41 8d 43 06	 lea	 eax, DWORD PTR [r11+6]

; 621  : }

  0010a	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 632  :     put_byte(s, (Byte)(b >> 8));

  00000	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00004	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00008	44 8b ca	 mov	 r9d, edx
  0000b	41 c1 e9 08	 shr	 r9d, 8
  0000f	45 88 0c 00	 mov	 BYTE PTR [r8+rax], r9b
  00013	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00016	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]

; 633  :     put_byte(s, (Byte)(b & 0xff));

  0001a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001e	41 88 14 00	 mov	 BYTE PTR [r8+rax], dl
  00022	ff 41 28	 inc	 DWORD PTR [rcx+40]

; 634  : }

  00025	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT flush_pending
_TEXT	SEGMENT
strm$ = 48
flush_pending PROC					; COMDAT

; 644  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 645  :     unsigned len;
; 646  :     deflate_state *s = strm->state;

  0000f	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  00013	48 8b f1	 mov	 rsi, rcx

; 647  : 
; 648  :     _tr_flush_bits(s);

  00016	48 8b cf	 mov	 rcx, rdi
  00019	e8 00 00 00 00	 call	 _tr_flush_bits

; 649  :     len = s->pending;

  0001e	8b 6f 28	 mov	 ebp, DWORD PTR [rdi+40]

; 650  :     if (len > strm->avail_out) len = strm->avail_out;

  00021	3b 6e 18	 cmp	 ebp, DWORD PTR [rsi+24]
  00024	0f 47 6e 18	 cmova	 ebp, DWORD PTR [rsi+24]

; 651  :     if (len == 0) return;

  00028	85 ed		 test	 ebp, ebp
  0002a	74 37		 je	 SHORT $LN1@flush_pend

; 652  : 
; 653  :     zmemcpy(strm->next_out, s->pending_out, len);

  0002c	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00030	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00034	44 8b c5	 mov	 r8d, ebp
  00037	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003c	8b dd		 mov	 ebx, ebp
  0003e	e8 00 00 00 00	 call	 memcpy

; 654  :     strm->next_out  += len;

  00043	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx

; 655  :     s->pending_out  += len;

  00047	48 01 5f 20	 add	 QWORD PTR [rdi+32], rbx

; 656  :     strm->total_out += len;

  0004b	01 6e 1c	 add	 DWORD PTR [rsi+28], ebp

; 657  :     strm->avail_out  -= len;

  0004e	29 6e 18	 sub	 DWORD PTR [rsi+24], ebp

; 658  :     s->pending -= len;

  00051	29 6f 28	 sub	 DWORD PTR [rdi+40], ebp
  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 659  :     if (s->pending == 0) {

  00059	75 08		 jne	 SHORT $LN1@flush_pend

; 660  :         s->pending_out = s->pending_buf;

  0005b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0005f	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
$LN1@flush_pend:

; 661  :     }
; 662  : }

  00063	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00068	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflateCopy
_TEXT	SEGMENT
dest$ = 48
source$ = 56
deflateCopy PROC					; COMDAT

; 1017 : {

$LN12:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1018 : #ifdef MAXSEG_64K
; 1019 :     return Z_STREAM_ERROR;
; 1020 : #else
; 1021 :     deflate_state *ds;
; 1022 :     deflate_state *ss;
; 1023 :     ushf *overlay;
; 1024 : 
; 1025 : 
; 1026 :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  0000d	48 85 d2	 test	 rdx, rdx
  00010	0f 84 3f 02 00
	00		 je	 $LN4@deflateCop
  00016	48 85 c9	 test	 rcx, rcx
  00019	0f 84 36 02 00
	00		 je	 $LN4@deflateCop
  0001f	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  00023	48 85 f6	 test	 rsi, rsi
  00026	0f 84 29 02 00
	00		 je	 $LN4@deflateCop

; 1028 :     }
; 1029 : 
; 1030 :     ss = source->state;
; 1031 : 
; 1032 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0002c	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]

; 1033 : 
; 1034 :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  0002f	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  00035	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0003a	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  0003d	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  00041	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1
  00045	0f 10 42 20	 movups	 xmm0, XMMWORD PTR [rdx+32]
  00049	0f 11 41 20	 movups	 XMMWORD PTR [rcx+32], xmm0
  0004d	0f 10 4a 30	 movups	 xmm1, XMMWORD PTR [rdx+48]
  00051	0f 11 49 30	 movups	 XMMWORD PTR [rcx+48], xmm1
  00055	0f 10 42 40	 movups	 xmm0, XMMWORD PTR [rdx+64]
  00059	0f 11 41 40	 movups	 XMMWORD PTR [rcx+64], xmm0
  0005d	f2 0f 10 4a 50	 movsdx	 xmm1, QWORD PTR [rdx+80]
  00062	ba 01 00 00 00	 mov	 edx, 1
  00067	f2 0f 11 49 50	 movsdx	 QWORD PTR [rcx+80], xmm1
  0006c	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00070	ff 53 30	 call	 QWORD PTR [rbx+48]
  00073	48 8b f8	 mov	 rdi, rax

; 1035 :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00076	48 85 c0	 test	 rax, rax
  00079	75 13		 jne	 SHORT $LN3@deflateCop
  0007b	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
  0007e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1066 : #endif /* MAXSEG_64K */
; 1067 : }

  00083	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5e		 pop	 rsi
  0008d	c3		 ret	 0
$LN3@deflateCop:

; 1036 :     dest->state = (struct internal_state FAR *) ds;

  0008e	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 1037 :     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));

  00092	48 8b c8	 mov	 rcx, rax
  00095	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0009a	48 8b c6	 mov	 rax, rsi
  0009d	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
$LL8@deflateCop:
  000a2	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000a5	48 8d 89 80 00
	00 00		 lea	 rcx, QWORD PTR [rcx+128]
  000ac	48 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [rax+128]
  000b3	0f 11 41 80	 movups	 XMMWORD PTR [rcx-128], xmm0
  000b7	0f 10 48 90	 movups	 xmm1, XMMWORD PTR [rax-112]
  000bb	0f 11 49 90	 movups	 XMMWORD PTR [rcx-112], xmm1
  000bf	0f 10 40 a0	 movups	 xmm0, XMMWORD PTR [rax-96]
  000c3	0f 11 41 a0	 movups	 XMMWORD PTR [rcx-96], xmm0
  000c7	0f 10 48 b0	 movups	 xmm1, XMMWORD PTR [rax-80]
  000cb	0f 11 49 b0	 movups	 XMMWORD PTR [rcx-80], xmm1
  000cf	0f 10 40 c0	 movups	 xmm0, XMMWORD PTR [rax-64]
  000d3	0f 11 41 c0	 movups	 XMMWORD PTR [rcx-64], xmm0
  000d7	0f 10 48 d0	 movups	 xmm1, XMMWORD PTR [rax-48]
  000db	0f 11 49 d0	 movups	 XMMWORD PTR [rcx-48], xmm1
  000df	0f 10 40 e0	 movups	 xmm0, XMMWORD PTR [rax-32]
  000e3	0f 11 41 e0	 movups	 XMMWORD PTR [rcx-32], xmm0
  000e7	0f 10 48 f0	 movups	 xmm1, XMMWORD PTR [rax-16]
  000eb	0f 11 49 f0	 movups	 XMMWORD PTR [rcx-16], xmm1
  000ef	48 ff ca	 dec	 rdx
  000f2	75 ae		 jne	 SHORT $LL8@deflateCop
  000f4	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]

; 1038 :     ds->strm = dest;
; 1039 : 
; 1040 :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  000f7	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  000fb	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  000fe	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00102	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1
  00106	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00109	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  0010c	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00110	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1041 :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00113	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00116	41 b8 02 00 00
	00		 mov	 r8d, 2
  0011c	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  00120	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00124	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1042 :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00127	8b 57 74	 mov	 edx, DWORD PTR [rdi+116]
  0012a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00130	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  00134	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00138	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1043 :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  0013b	8b 97 f0 16 00
	00		 mov	 edx, DWORD PTR [rdi+5872]
  00141	41 b8 04 00 00
	00		 mov	 r8d, 4
  00147	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  0014b	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0014f	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1044 :     ds->pending_buf = (uchf *) overlay;
; 1045 : 
; 1046 :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 1047 :         ds->pending_buf == Z_NULL) {

  00152	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  00156	4c 8b f0	 mov	 r14, rax
  00159	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0015d	48 85 c9	 test	 rcx, rcx
  00160	0f 84 e0 00 00
	00		 je	 $LN1@deflateCop
  00166	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  0016b	0f 84 d5 00 00
	00		 je	 $LN1@deflateCop
  00171	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  00176	0f 84 ca 00 00
	00		 je	 $LN1@deflateCop
  0017c	48 85 c0	 test	 rax, rax
  0017f	0f 84 c1 00 00
	00		 je	 $LN1@deflateCop

; 1050 :     }
; 1051 :     /* following zmemcpy do not work for 16-bit MSDOS */
; 1052 :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  00185	8b 47 44	 mov	 eax, DWORD PTR [rdi+68]
  00188	48 8b 56 50	 mov	 rdx, QWORD PTR [rsi+80]
  0018c	44 8d 04 00	 lea	 r8d, DWORD PTR [rax+rax]
  00190	e8 00 00 00 00	 call	 memcpy

; 1053 :     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));

  00195	44 8b 47 44	 mov	 r8d, DWORD PTR [rdi+68]
  00199	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  0019d	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  001a1	4d 03 c0	 add	 r8, r8
  001a4	e8 00 00 00 00	 call	 memcpy

; 1054 :     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));

  001a9	44 8b 47 74	 mov	 r8d, DWORD PTR [rdi+116]
  001ad	48 8b 56 68	 mov	 rdx, QWORD PTR [rsi+104]
  001b1	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  001b5	4d 03 c0	 add	 r8, r8
  001b8	e8 00 00 00 00	 call	 memcpy

; 1055 :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  001bd	44 8b 47 18	 mov	 r8d, DWORD PTR [rdi+24]
  001c1	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  001c5	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  001c9	e8 00 00 00 00	 call	 memcpy

; 1056 : 
; 1057 :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  001ce	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]

; 1058 :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  001d2	8b 8f f0 16 00
	00		 mov	 ecx, DWORD PTR [rdi+5872]
  001d8	48 2b 46 10	 sub	 rax, QWORD PTR [rsi+16]
  001dc	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  001e0	48 03 c2	 add	 rax, rdx
  001e3	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  001e7	8b c1		 mov	 eax, ecx
  001e9	48 d1 e8	 shr	 rax, 1
  001ec	49 8d 04 46	 lea	 rax, QWORD PTR [r14+rax*2]
  001f0	48 89 87 f8 16
	00 00		 mov	 QWORD PTR [rdi+5880], rax

; 1059 :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  001f7	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  001fb	48 03 c8	 add	 rcx, rax

; 1060 : 
; 1061 :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  001fe	48 8d 87 bc 00
	00 00		 lea	 rax, QWORD PTR [rdi+188]
  00205	48 89 87 40 0b
	00 00		 mov	 QWORD PTR [rdi+2880], rax

; 1062 :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  0020c	48 8d 87 b0 09
	00 00		 lea	 rax, QWORD PTR [rdi+2480]
  00213	48 89 8f e8 16
	00 00		 mov	 QWORD PTR [rdi+5864], rcx
  0021a	48 89 87 58 0b
	00 00		 mov	 QWORD PTR [rdi+2904], rax

; 1063 :     ds->bl_desc.dyn_tree = ds->bl_tree;

  00221	48 8d 87 a4 0a
	00 00		 lea	 rax, QWORD PTR [rdi+2724]
  00228	48 89 87 70 0b
	00 00		 mov	 QWORD PTR [rdi+2928], rax

; 1064 : 
; 1065 :     return Z_OK;

  0022f	33 c0		 xor	 eax, eax
$LN10@deflateCop:
  00231	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00236	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1066 : #endif /* MAXSEG_64K */
; 1067 : }

  0023b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00240	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00244	5e		 pop	 rsi
  00245	c3		 ret	 0
$LN1@deflateCop:

; 1048 :         deflateEnd (dest);

  00246	48 8b cb	 mov	 rcx, rbx
  00249	e8 00 00 00 00	 call	 deflateEnd

; 1049 :         return Z_MEM_ERROR;

  0024e	b8 fc ff ff ff	 mov	 eax, -4
  00253	eb dc		 jmp	 SHORT $LN10@deflateCop
$LN4@deflateCop:

; 1027 :         return Z_STREAM_ERROR;

  00255	b8 fe ff ff ff	 mov	 eax, -2

; 1066 : #endif /* MAXSEG_64K */
; 1067 : }

  0025a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0025f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00263	5e		 pop	 rsi
  00264	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT read_buf
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
size$ = 64
read_buf PROC						; COMDAT

; 1080 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1081 :     unsigned len = strm->avail_in;

  0000f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1082 : 
; 1083 :     if (len > size) len = size;

  00018	41 3b c0	 cmp	 eax, r8d
  0001b	8b f8		 mov	 edi, eax
  0001d	41 0f 47 f8	 cmova	 edi, r8d

; 1084 :     if (len == 0) return 0;

  00021	85 ff		 test	 edi, edi
  00023	75 12		 jne	 SHORT $LN4@read_buf
  00025	33 c0		 xor	 eax, eax

; 1099 : 
; 1100 :     return (int)len;
; 1101 : }

  00027	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN4@read_buf:

; 1085 : 
; 1086 :     strm->avail_in  -= len;
; 1087 : 
; 1088 :     zmemcpy(buf, strm->next_in, len);

  00037	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0003a	2b c7		 sub	 eax, edi
  0003c	44 8b c7	 mov	 r8d, edi
  0003f	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00042	48 8b ce	 mov	 rcx, rsi
  00045	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004a	8b ef		 mov	 ebp, edi
  0004c	e8 00 00 00 00	 call	 memcpy

; 1089 :     if (strm->state->wrap == 1) {

  00051	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00055	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00058	83 f9 01	 cmp	 ecx, 1
  0005b	75 10		 jne	 SHORT $LN3@read_buf

; 1090 :         strm->adler = adler32(strm->adler, buf, len);

  0005d	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00060	44 8b c7	 mov	 r8d, edi
  00063	48 8b d6	 mov	 rdx, rsi
  00066	e8 00 00 00 00	 call	 adler32
  0006b	eb 13		 jmp	 SHORT $LN8@read_buf
$LN3@read_buf:

; 1091 :     }
; 1092 : #ifdef GZIP
; 1093 :     else if (strm->state->wrap == 2) {

  0006d	83 f9 02	 cmp	 ecx, 2
  00070	75 11		 jne	 SHORT $LN1@read_buf

; 1094 :         strm->adler = crc32(strm->adler, buf, len);

  00072	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00075	44 8b c7	 mov	 r8d, edi
  00078	48 8b d6	 mov	 rdx, rsi
  0007b	e8 00 00 00 00	 call	 crc32
$LN8@read_buf:
  00080	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN1@read_buf:

; 1095 :     }
; 1096 : #endif
; 1097 :     strm->next_in  += len;

  00083	48 01 2b	 add	 QWORD PTR [rbx], rbp

; 1098 :     strm->total_in += len;

  00086	01 7b 0c	 add	 DWORD PTR [rbx+12], edi

; 1099 : 
; 1100 :     return (int)len;
; 1101 : }

  00089	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00093	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00098	8b c7		 mov	 eax, edi
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1108 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1109 :     s->window_size = (ulg)2L*s->w_size;

  0000a	8b 41 44	 mov	 eax, DWORD PTR [rcx+68]

; 1110 : 
; 1111 :     CLEAR_HASH(s);

  0000d	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  00010	48 8b d9	 mov	 rbx, rcx
  00013	03 c0		 add	 eax, eax
  00015	ff ca		 dec	 edx
  00017	33 ff		 xor	 edi, edi
  00019	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  0001c	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00020	66 89 3c 50	 mov	 WORD PTR [rax+rdx*2], di
  00024	44 8b 41 74	 mov	 r8d, DWORD PTR [rcx+116]
  00028	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0002c	41 ff c8	 dec	 r8d
  0002f	33 d2		 xor	 edx, edx
  00031	4d 03 c0	 add	 r8, r8
  00034	e8 00 00 00 00	 call	 memset

; 1112 : 
; 1113 :     /* Set the default configuration parameters:
; 1114 :      */
; 1115 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00039	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:configuration_table
  00047	48 03 c9	 add	 rcx, rcx
  0004a	0f b7 44 ca 02	 movzx	 eax, WORD PTR [rdx+rcx*8+2]
  0004f	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 1116 :     s->good_match       = configuration_table[s->level].good_length;

  00055	0f b7 04 ca	 movzx	 eax, WORD PTR [rdx+rcx*8]
  00059	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 1117 :     s->nice_match       = configuration_table[s->level].nice_length;

  0005f	0f b7 44 ca 04	 movzx	 eax, WORD PTR [rdx+rcx*8+4]
  00064	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 1118 :     s->max_chain_length = configuration_table[s->level].max_chain;

  0006a	0f b7 44 ca 06	 movzx	 eax, WORD PTR [rdx+rcx*8+6]

; 1119 : 
; 1120 :     s->strstart = 0;
; 1121 :     s->block_start = 0L;
; 1122 :     s->lookahead = 0;
; 1123 :     s->insert = 0;
; 1124 :     s->match_length = s->prev_length = MIN_MATCH-1;
; 1125 :     s->match_available = 0;

  0006f	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  00076	89 bb 84 00 00
	00		 mov	 DWORD PTR [rbx+132], edi
  0007c	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi
  00082	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi
  00088	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
  0008e	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  00098	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2

; 1126 :     s->ins_h = 0;

  000a2	89 7b 70	 mov	 DWORD PTR [rbx+112], edi

; 1130 : #endif
; 1131 : #endif
; 1132 : }

  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi

; 1127 : #ifndef FASTEST
; 1128 : #ifdef ASMV
; 1129 :     match_init(); /* initialize the asm code */

  000af	e9 00 00 00 00	 jmp	 match_init
lm_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT fill_window
_TEXT	SEGMENT
s$ = 48
fill_window PROC					; COMDAT

; 1392 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1393 :     register unsigned n, m;
; 1394 :     register Posf *p;
; 1395 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1396 :     uInt wsize = s->w_size;

  0000f	8b 79 44	 mov	 edi, DWORD PTR [rcx+68]
  00012	48 8b d9	 mov	 rbx, rcx
  00015	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL26@fill_windo:

; 1397 : 
; 1398 :     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
; 1399 : 
; 1400 :     do {
; 1401 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00020	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  00026	8b 73 58	 mov	 esi, DWORD PTR [rbx+88]

; 1402 : 
; 1403 :         /* Deal with !@#$% 64K limit: */
; 1404 :         if (sizeof(int) <= 2) {
; 1405 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1406 :                 more = wsize;
; 1407 : 
; 1408 :             } else if (more == (unsigned)(-1)) {
; 1409 :                 /* Very unlikely, but possible on 16 bit machine if
; 1410 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1411 :                  */
; 1412 :                 more--;
; 1413 :             }
; 1414 :         }
; 1415 : 
; 1416 :         /* If the window is almost full and there is insufficient lookahead,
; 1417 :          * move the upper half to the lower one to make room in the upper half.
; 1418 :          */
; 1419 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  00029	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  0002c	2b b3 9c 00 00
	00		 sub	 esi, DWORD PTR [rbx+156]
  00032	81 c1 fa fe ff
	ff		 add	 ecx, -262		; fffffefaH
  00038	03 cf		 add	 ecx, edi
  0003a	2b f2		 sub	 esi, edx
  0003c	3b d1		 cmp	 edx, ecx
  0003e	72 6f		 jb	 SHORT $LN19@fill_windo

; 1420 : 
; 1421 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  00040	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00044	4c 8b c7	 mov	 r8, rdi
  00047	48 8d 14 39	 lea	 rdx, QWORD PTR [rcx+rdi]
  0004b	e8 00 00 00 00	 call	 memcpy

; 1422 :             s->match_start -= wsize;
; 1423 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1424 :             s->block_start -= (long) wsize;
; 1425 : 
; 1426 :             /* Slide the hash table (could be avoided with 32 bit values
; 1427 :                at the expense of memory usage). We slide even when level == 0
; 1428 :                to keep the hash table consistent if we switch back to level > 0
; 1429 :                later. (Using level 0 permanently is not an optimal usage of
; 1430 :                zlib, so we don't care about this pathological case.)
; 1431 :              */
; 1432 :             n = s->hash_size;

  00050	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]

; 1433 :             p = &s->head[n];

  00054	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00058	29 bb 98 00 00
	00		 sub	 DWORD PTR [rbx+152], edi
  0005e	29 bb 94 00 00
	00		 sub	 DWORD PTR [rbx+148], edi
  00064	29 bb 84 00 00
	00		 sub	 DWORD PTR [rbx+132], edi
  0006a	4a 8d 14 40	 lea	 rdx, QWORD PTR [rax+r8*2]
  0006e	66 90		 npad	 2
$LL18@fill_windo:

; 1434 :             do {
; 1435 :                 m = *--p;

  00070	0f b7 42 fe	 movzx	 eax, WORD PTR [rdx-2]
  00074	48 8d 52 fe	 lea	 rdx, QWORD PTR [rdx-2]

; 1436 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00078	3b c7		 cmp	 eax, edi
  0007a	72 04		 jb	 SHORT $LN29@fill_windo
  0007c	2b c7		 sub	 eax, edi
  0007e	eb 02		 jmp	 SHORT $LN30@fill_windo
$LN29@fill_windo:
  00080	33 c0		 xor	 eax, eax
$LN30@fill_windo:
  00082	66 89 02	 mov	 WORD PTR [rdx], ax

; 1437 :             } while (--n);

  00085	41 ff c8	 dec	 r8d
  00088	75 e6		 jne	 SHORT $LL18@fill_windo

; 1438 : 
; 1439 :             n = wsize;
; 1440 : #ifndef FASTEST
; 1441 :             p = &s->prev[n];

  0008a	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0008e	8b d7		 mov	 edx, edi
  00090	48 8d 0c 78	 lea	 rcx, QWORD PTR [rax+rdi*2]
$LL15@fill_windo:

; 1442 :             do {
; 1443 :                 m = *--p;

  00094	0f b7 41 fe	 movzx	 eax, WORD PTR [rcx-2]
  00098	48 8d 49 fe	 lea	 rcx, QWORD PTR [rcx-2]

; 1444 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  0009c	3b c7		 cmp	 eax, edi
  0009e	72 04		 jb	 SHORT $LN31@fill_windo
  000a0	2b c7		 sub	 eax, edi
  000a2	eb 02		 jmp	 SHORT $LN32@fill_windo
$LN31@fill_windo:
  000a4	33 c0		 xor	 eax, eax
$LN32@fill_windo:
  000a6	66 89 01	 mov	 WORD PTR [rcx], ax

; 1445 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1446 :                  * its value will never be used.
; 1447 :                  */
; 1448 :             } while (--n);

  000a9	ff ca		 dec	 edx
  000ab	75 e7		 jne	 SHORT $LL15@fill_windo

; 1449 : #endif
; 1450 :             more += wsize;

  000ad	03 f7		 add	 esi, edi
$LN19@fill_windo:

; 1451 :         }
; 1452 :         if (s->strm->avail_in == 0) break;

  000af	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000b2	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  000b6	0f 84 f7 00 00
	00		 je	 $LN24@fill_windo

; 1453 : 
; 1454 :         /* If there was no sliding:
; 1455 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1456 :          *    more == window_size - lookahead - strstart
; 1457 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1458 :          * => more >= window_size - 2*WSIZE + 2
; 1459 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1460 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1461 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1462 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1463 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1464 :          */
; 1465 :         Assert(more >= 2, "more < 2");
; 1466 : 
; 1467 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  000bc	8b 93 9c 00 00
	00		 mov	 edx, DWORD PTR [rbx+156]
  000c2	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000c8	44 8b c6	 mov	 r8d, esi
  000cb	48 03 d0	 add	 rdx, rax
  000ce	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000d2	e8 00 00 00 00	 call	 read_buf

; 1468 :         s->lookahead += n;
; 1469 : 
; 1470 :         /* Initialize the hash value now that we have some input: */
; 1471 :         if (s->lookahead + s->insert >= MIN_MATCH) {

  000d7	44 8b 8b 0c 17
	00 00		 mov	 r9d, DWORD PTR [rbx+5900]
  000de	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax
  000e4	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  000ea	41 03 c1	 add	 eax, r9d
  000ed	83 f8 03	 cmp	 eax, 3
  000f0	0f 82 a4 00 00
	00		 jb	 $LN25@fill_windo

; 1472 :             uInt str = s->strstart - s->insert;

  000f6	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 1473 :             s->ins_h = s->window[str];

  000fd	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]

; 1474 :             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);

  00101	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00107	45 2b d1	 sub	 r10d, r9d
  0010a	45 0f b6 04 12	 movzx	 r8d, BYTE PTR [r10+rdx]
  0010f	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  00113	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  00117	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  0011b	41 d3 e0	 shl	 r8d, cl
  0011e	41 33 c0	 xor	 eax, r8d
  00121	23 43 7c	 and	 eax, DWORD PTR [rbx+124]
  00124	89 43 70	 mov	 DWORD PTR [rbx+112], eax

; 1475 : #if MIN_MATCH != 3
; 1476 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1477 : #endif
; 1478 :             while (s->insert) {

  00127	45 85 c9	 test	 r9d, r9d
  0012a	74 6e		 je	 SHORT $LN25@fill_windo

; 1472 :             uInt str = s->strstart - s->insert;

  0012c	45 8d 5a 02	 lea	 r11d, DWORD PTR [r10+2]
$LL10@fill_windo:

; 1479 :                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00130	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00134	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 1480 : #ifndef FASTEST
; 1481 :                 s->prev[str & s->w_mask] = s->head[s->ins_h];

  0013a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0013e	45 0f b6 0c 03	 movzx	 r9d, BYTE PTR [r11+rax]
  00143	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00146	45 8b c2	 mov	 r8d, r10d
  00149	d3 e0		 shl	 eax, cl
  0014b	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]

; 1482 : #endif
; 1483 :                 s->head[s->ins_h] = (Pos)str;
; 1484 :                 str++;

  0014f	45 8d 5b 01	 lea	 r11d, DWORD PTR [r11+1]
  00153	44 33 c8	 xor	 r9d, eax
  00156	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  00159	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0015d	4c 23 c0	 and	 r8, rax
  00160	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00164	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00169	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0016e	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00171	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00175	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w

; 1485 :                 s->insert--;

  0017a	ff 8b 0c 17 00
	00		 dec	 DWORD PTR [rbx+5900]
  00180	8b 93 0c 17 00
	00		 mov	 edx, DWORD PTR [rbx+5900]

; 1486 :                 if (s->lookahead + s->insert < MIN_MATCH)

  00186	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  0018c	41 ff c2	 inc	 r10d
  0018f	03 ca		 add	 ecx, edx
  00191	83 f9 03	 cmp	 ecx, 3
  00194	72 04		 jb	 SHORT $LN25@fill_windo

; 1475 : #if MIN_MATCH != 3
; 1476 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1477 : #endif
; 1478 :             while (s->insert) {

  00196	85 d2		 test	 edx, edx
  00198	75 96		 jne	 SHORT $LL10@fill_windo
$LN25@fill_windo:

; 1487 :                     break;
; 1488 :             }
; 1489 :         }
; 1490 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1491 :          * but this is not important since only literal bytes will be emitted.
; 1492 :          */
; 1493 : 
; 1494 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  0019a	81 bb 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rbx+156], 262 ; 00000106H
  001a4	73 0d		 jae	 SHORT $LN24@fill_windo
  001a6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001a9	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001ad	0f 85 6d fe ff
	ff		 jne	 $LL26@fill_windo
$LN24@fill_windo:

; 1495 : 
; 1496 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1497 :      * written, then zero those bytes in order to avoid memory check reports of
; 1498 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1499 :      * the longest match routines.  Update the high water mark for the next
; 1500 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1501 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1502 :      */
; 1503 :     if (s->high_water < s->window_size) {

  001b3	8b 8b 18 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5912]
  001b9	8b 73 58	 mov	 esi, DWORD PTR [rbx+88]
  001bc	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001c1	3b ce		 cmp	 ecx, esi
  001c3	73 73		 jae	 SHORT $LN2@fill_windo

; 1504 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  001c5	8b bb 9c 00 00
	00		 mov	 edi, DWORD PTR [rbx+156]
  001cb	03 bb 94 00 00
	00		 add	 edi, DWORD PTR [rbx+148]

; 1505 :         ulg init;
; 1506 : 
; 1507 :         if (s->high_water < curr) {

  001d1	3b cf		 cmp	 ecx, edi
  001d3	73 35		 jae	 SHORT $LN5@fill_windo

; 1508 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1509 :              * bytes or up to end of window, whichever is less.
; 1510 :              */
; 1511 :             init = s->window_size - curr;

  001d5	2b f7		 sub	 esi, edi

; 1512 :             if (init > WIN_INIT)

  001d7	b8 02 01 00 00	 mov	 eax, 258		; 00000102H

; 1513 :                 init = WIN_INIT;
; 1514 :             zmemzero(s->window + curr, (unsigned)init);

  001dc	8b cf		 mov	 ecx, edi
  001de	3b f0		 cmp	 esi, eax
  001e0	0f 47 f0	 cmova	 esi, eax
  001e3	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  001e7	33 d2		 xor	 edx, edx
  001e9	44 8b c6	 mov	 r8d, esi
  001ec	e8 00 00 00 00	 call	 memset

; 1515 :             s->high_water = curr + init;

  001f1	8d 04 3e	 lea	 eax, DWORD PTR [rsi+rdi]
  001f4	89 83 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], eax

; 1527 :         }
; 1528 :     }
; 1529 : 
; 1530 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1531 :            "not enough room for search");
; 1532 : }

  001fa	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001ff	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00204	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00208	5f		 pop	 rdi
  00209	c3		 ret	 0
$LN5@fill_windo:

; 1516 :         }
; 1517 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  0020a	8d 87 02 01 00
	00		 lea	 eax, DWORD PTR [rdi+258]
  00210	3b c8		 cmp	 ecx, eax
  00212	73 24		 jae	 SHORT $LN2@fill_windo

; 1518 :             /* High water mark at or above current data, but below current data
; 1519 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1520 :              * to end of window, whichever is less.
; 1521 :              */
; 1522 :             init = (ulg)curr + WIN_INIT - s->high_water;

  00214	2b f9		 sub	 edi, ecx

; 1523 :             if (init > s->window_size - s->high_water)

  00216	2b f1		 sub	 esi, ecx
  00218	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  0021d	03 f8		 add	 edi, eax
  0021f	3b fe		 cmp	 edi, esi
  00221	0f 47 fe	 cmova	 edi, esi

; 1524 :                 init = s->window_size - s->high_water;
; 1525 :             zmemzero(s->window + s->high_water, (unsigned)init);

  00224	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  00228	33 d2		 xor	 edx, edx
  0022a	44 8b c7	 mov	 r8d, edi
  0022d	e8 00 00 00 00	 call	 memset

; 1526 :             s->high_water += init;

  00232	01 bb 18 17 00
	00		 add	 DWORD PTR [rbx+5912], edi
$LN2@fill_windo:

; 1527 :         }
; 1528 :     }
; 1529 : 
; 1530 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1531 :            "not enough room for search");
; 1532 : }

  00238	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0023d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00242	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00246	5f		 pop	 rdi
  00247	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflate_stored
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_stored PROC					; COMDAT

; 1567 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1568 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1569 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1570 :      */
; 1571 :     ulg max_block_size = 0xffff;
; 1572 :     ulg max_start;
; 1573 : 
; 1574 :     if (max_block_size > s->pending_buf_size - 5) {

  00014	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00017	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  0001c	8b ea		 mov	 ebp, edx
  0001e	83 c0 fb	 add	 eax, -5			; fffffffbH
  00021	48 8b d9	 mov	 rbx, rcx
  00024	3b c6		 cmp	 eax, esi
  00026	0f 42 f0	 cmovb	 esi, eax
  00029	33 ff		 xor	 edi, edi
  0002b	0f 1f 44 00 00	 npad	 5
$LL14@deflate_st:

; 1575 :         max_block_size = s->pending_buf_size - 5;
; 1576 :     }
; 1577 : 
; 1578 :     /* Copy as much as possible from input to output: */
; 1579 :     for (;;) {
; 1580 :         /* Fill the window as much as possible: */
; 1581 :         if (s->lookahead <= 1) {

  00030	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00036	83 f8 01	 cmp	 eax, 1
  00039	77 16		 ja	 SHORT $LN10@deflate_st

; 1582 : 
; 1583 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1584 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1585 : 
; 1586 :             fill_window(s);

  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 fill_window

; 1587 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  00043	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00049	85 c0		 test	 eax, eax
  0004b	0f 84 df 00 00
	00		 je	 $LN36@deflate_st
$LN10@deflate_st:

; 1588 : 
; 1589 :             if (s->lookahead == 0) break; /* flush the current block */
; 1590 :         }
; 1591 :         Assert(s->block_start >= 0L, "block gone");
; 1592 : 
; 1593 :         s->strstart += s->lookahead;
; 1594 :         s->lookahead = 0;
; 1595 : 
; 1596 :         /* Emit a stored block if pending_buf will be full: */
; 1597 :         max_start = s->block_start + max_block_size;

  00051	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  00057	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1598 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  0005d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00063	44 8d 04 31	 lea	 r8d, DWORD PTR [rcx+rsi]
  00067	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi
  0006d	74 05		 je	 SHORT $LN8@deflate_st
  0006f	41 3b c0	 cmp	 eax, r8d
  00072	72 4a		 jb	 SHORT $LN7@deflate_st
$LN8@deflate_st:

; 1599 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1600 :             s->lookahead = (uInt)(s->strstart - max_start);

  00074	41 2b c0	 sub	 eax, r8d

; 1601 :             s->strstart = (uInt)max_start;

  00077	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  0007e	89 83 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], eax

; 1602 :             FLUSH_BLOCK(s, 0);

  00084	85 c9		 test	 ecx, ecx
  00086	78 09		 js	 SHORT $LN18@deflate_st
  00088	48 8b d1	 mov	 rdx, rcx
  0008b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0008f	eb 03		 jmp	 SHORT $LN19@deflate_st
$LN18@deflate_st:
  00091	48 8b d7	 mov	 rdx, rdi
$LN19@deflate_st:
  00094	44 2b c1	 sub	 r8d, ecx
  00097	45 33 c9	 xor	 r9d, r9d
  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 _tr_flush_block
  000a2	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000a8	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000ab	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  000b1	e8 00 00 00 00	 call	 flush_pending
  000b6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000b9	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  000bc	74 5b		 je	 SHORT $LN30@deflate_st
$LN7@deflate_st:

; 1603 :         }
; 1604 :         /* Flush if we may have to slide, otherwise block_start may become
; 1605 :          * negative and the data will be gone:
; 1606 :          */
; 1607 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  000be	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  000c4	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  000cb	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000ce	44 2b c1	 sub	 r8d, ecx
  000d1	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000d6	44 3b c0	 cmp	 r8d, eax
  000d9	0f 82 51 ff ff
	ff		 jb	 $LL14@deflate_st

; 1608 :             FLUSH_BLOCK(s, 0);

  000df	85 c9		 test	 ecx, ecx
  000e1	78 08		 js	 SHORT $LN20@deflate_st
  000e3	8b d1		 mov	 edx, ecx
  000e5	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000e9	eb 03		 jmp	 SHORT $LN21@deflate_st
$LN20@deflate_st:
  000eb	48 8b d7	 mov	 rdx, rdi
$LN21@deflate_st:
  000ee	45 33 c9	 xor	 r9d, r9d
  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	e8 00 00 00 00	 call	 _tr_flush_block
  000f9	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000ff	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00102	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00108	e8 00 00 00 00	 call	 flush_pending
  0010d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00110	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00113	0f 85 17 ff ff
	ff		 jne	 $LL14@deflate_st
$LN30@deflate_st:

; 1602 :             FLUSH_BLOCK(s, 0);

  00119	33 c0		 xor	 eax, eax
$LN16@deflate_st:

; 1619 : }

  0011b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00120	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00125	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012e	5f		 pop	 rdi
  0012f	c3		 ret	 0
$LN36@deflate_st:

; 1587 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  00130	85 ed		 test	 ebp, ebp
  00132	74 e5		 je	 SHORT $LN30@deflate_st

; 1609 :         }
; 1610 :     }
; 1611 :     s->insert = 0;
; 1612 :     if (flush == Z_FINISH) {
; 1613 :         FLUSH_BLOCK(s, 1);

  00134	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0013a	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi
  00140	83 fd 04	 cmp	 ebp, 4
  00143	75 4a		 jne	 SHORT $LN4@deflate_st
  00145	85 c0		 test	 eax, eax
  00147	78 08		 js	 SHORT $LN22@deflate_st
  00149	8b d0		 mov	 edx, eax
  0014b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0014f	eb 03		 jmp	 SHORT $LN23@deflate_st
$LN22@deflate_st:
  00151	48 8b d7	 mov	 rdx, rdi
$LN23@deflate_st:
  00154	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0015b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00161	48 8b cb	 mov	 rcx, rbx
  00164	44 2b c0	 sub	 r8d, eax
  00167	e8 00 00 00 00	 call	 _tr_flush_block
  0016c	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00172	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00175	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0017b	e8 00 00 00 00	 call	 flush_pending
  00180	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00183	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00186	40 0f 95 c7	 setne	 dil
  0018a	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1614 :         return finish_done;

  0018d	eb 8c		 jmp	 SHORT $LN16@deflate_st
$LN4@deflate_st:

; 1615 :     }
; 1616 :     if ((long)s->strstart > s->block_start)

  0018f	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00196	44 3b c0	 cmp	 r8d, eax
  00199	7e 3d		 jle	 SHORT $LN1@deflate_st

; 1617 :         FLUSH_BLOCK(s, 0);

  0019b	85 c0		 test	 eax, eax
  0019d	78 07		 js	 SHORT $LN24@deflate_st
  0019f	48 8b f8	 mov	 rdi, rax
  001a2	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN24@deflate_st:
  001a6	44 2b c0	 sub	 r8d, eax
  001a9	45 33 c9	 xor	 r9d, r9d
  001ac	48 8b d7	 mov	 rdx, rdi
  001af	48 8b cb	 mov	 rcx, rbx
  001b2	e8 00 00 00 00	 call	 _tr_flush_block
  001b7	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  001bd	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001c0	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  001c6	e8 00 00 00 00	 call	 flush_pending
  001cb	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001ce	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001d2	0f 84 41 ff ff
	ff		 je	 $LN30@deflate_st
$LN1@deflate_st:

; 1618 :     return block_done;

  001d8	b8 01 00 00 00	 mov	 eax, 1
  001dd	e9 39 ff ff ff	 jmp	 $LN16@deflate_st
deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflate_fast
_TEXT	SEGMENT
s$ = 64
flush$ = 72
deflate_fast PROC					; COMDAT

; 1631 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	8b f2		 mov	 esi, edx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	41 be ff ff 00
	00		 mov	 r14d, 65535		; 0000ffffH
  00023	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:__ImageBase
  0002a	33 ff		 xor	 edi, edi
  0002c	41 bf 00 01 00
	00		 mov	 r15d, 256		; 00000100H
$LL20@deflate_fa:

; 1632 :     IPos hash_head;       /* head of the hash chain */
; 1633 :     int bflush;           /* set if current block must be flushed */
; 1634 : 
; 1635 :     for (;;) {
; 1636 :         /* Make sure that we always have enough lookahead, except
; 1637 :          * at the end of the input file. We need MAX_MATCH bytes
; 1638 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1639 :          * string following the next match.
; 1640 :          */
; 1641 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00032	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00038	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0003d	73 25		 jae	 SHORT $LN16@deflate_fa

; 1642 :             fill_window(s);

  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 fill_window

; 1643 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00047	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0004d	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00052	73 08		 jae	 SHORT $LN17@deflate_fa
  00054	85 f6		 test	 esi, esi
  00056	0f 84 c7 02 00
	00		 je	 $LN38@deflate_fa
$LN17@deflate_fa:

; 1644 :                 return need_more;
; 1645 :             }
; 1646 :             if (s->lookahead == 0) break; /* flush the current block */

  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 da 02 00
	00		 je	 $LN37@deflate_fa
$LN16@deflate_fa:

; 1647 :         }
; 1648 : 
; 1649 :         /* Insert the string window[strstart .. strstart+2] in the
; 1650 :          * dictionary, and set hash_head to the head of the hash chain:
; 1651 :          */
; 1652 :         hash_head = NIL;
; 1653 :         if (s->lookahead >= MIN_MATCH) {

  00064	83 f8 03	 cmp	 eax, 3
  00067	0f 82 90 00 00
	00		 jb	 $LN14@deflate_fa

; 1654 :             INSERT_STRING(s, s->strstart, hash_head);

  0006d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00071	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00078	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0007c	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  00080	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00085	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00088	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0008e	d3 e0		 shl	 eax, cl
  00090	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00094	44 33 c0	 xor	 r8d, eax
  00097	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  0009a	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0009e	4c 23 c8	 and	 r9, rax
  000a1	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000a5	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000aa	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000af	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000b2	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000b8	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  000bc	48 23 c8	 and	 rcx, rax
  000bf	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000c3	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  000c7	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000cb	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  000d2	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax

; 1655 :         }
; 1656 : 
; 1657 :         /* Find the longest match, discarding those <= prev_length.
; 1658 :          * At this point we have always match_length < MIN_MATCH
; 1659 :          */
; 1660 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  000d7	85 d2		 test	 edx, edx
  000d9	74 22		 je	 SHORT $LN14@deflate_fa
  000db	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000e1	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000e4	2b ca		 sub	 ecx, edx
  000e6	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000eb	3b c8		 cmp	 ecx, eax
  000ed	77 0e		 ja	 SHORT $LN14@deflate_fa

; 1661 :             /* To simplify the code, we prevent matches with the string
; 1662 :              * of window index 0 (in particular we have to avoid a match
; 1663 :              * of the string with itself at the start of the input file).
; 1664 :              */
; 1665 :             s->match_length = longest_match (s, hash_head);

  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 longest_match
  000f7	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LN14@deflate_fa:

; 1666 :             /* longest_match() sets match_start */
; 1667 :         }
; 1668 :         if (s->match_length >= MIN_MATCH) {

  000fd	83 bb 88 00 00
	00 03		 cmp	 DWORD PTR [rbx+136], 3
  00104	0f 82 68 01 00
	00		 jb	 $LN13@deflate_fa

; 1669 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1670 : 
; 1671 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1672 :                            s->match_length - MIN_MATCH, bflush);

  0010a	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00110	44 0f b7 83 94
	00 00 00	 movzx	 r8d, WORD PTR [rbx+148]
  00118	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0011f	66 44 2b 83 98
	00 00 00	 sub	 r8w, WORD PTR [rbx+152]
  00127	0f b6 93 88 00
	00 00		 movzx	 edx, BYTE PTR [rbx+136]
  0012e	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w
  00133	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00139	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00140	80 ea 03	 sub	 dl, 3
  00143	66 45 03 c6	 add	 r8w, r14w
  00147	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0014a	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00150	0f b6 c2	 movzx	 eax, dl
  00153	0f b6 84 28 00
	00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+rbp]
  0015b	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00163	41 0f b7 c0	 movzx	 eax, r8w
  00167	66 45 3b c7	 cmp	 r8w, r15w
  0016b	73 0a		 jae	 SHORT $LN23@deflate_fa
  0016d	0f b6 8c 28 00
	00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+rbp]
  00175	eb 0c		 jmp	 SHORT $LN24@deflate_fa
$LN23@deflate_fa:
  00177	48 c1 e8 07	 shr	 rax, 7
  0017b	0f b6 8c 28 00
	01 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+rbp+256]
$LN24@deflate_fa:
  00183	48 63 c1	 movsxd	 rax, ecx
  00186	44 8b d7	 mov	 r10d, edi
  00189	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]
  00191	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00197	ff c8		 dec	 eax
  00199	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1673 : 
; 1674 :             s->lookahead -= s->match_length;

  0019f	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]
  001a5	41 0f 94 c2	 sete	 r10b
  001a9	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax

; 1675 : 
; 1676 :             /* Insert new strings in the hash table only if the match length
; 1677 :              * is not too large. This saves time but degrades compression.
; 1678 :              */
; 1679 : #ifndef FASTEST
; 1680 :             if (s->match_length <= s->max_insert_length &&
; 1681 :                 s->lookahead >= MIN_MATCH) {

  001af	3b 83 a8 00 00
	00		 cmp	 eax, DWORD PTR [rbx+168]
  001b5	0f 87 7c 00 00
	00		 ja	 $LN12@deflate_fa
  001bb	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  001c2	72 73		 jb	 SHORT $LN12@deflate_fa

; 1682 :                 s->match_length--; /* string at strstart already in table */

  001c4	ff c8		 dec	 eax
  001c6	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
  001cc	0f 1f 40 00	 npad	 4
$LL11@deflate_fa:

; 1683 :                 do {
; 1684 :                     s->strstart++;

  001d0	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1685 :                     INSERT_STRING(s, s->strstart, hash_head);

  001d6	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001da	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  001e1	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  001e5	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  001e9	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  001ee	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001f1	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  001f7	d3 e0		 shl	 eax, cl
  001f9	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  001fd	44 33 c0	 xor	 r8d, eax
  00200	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  00203	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  00207	4c 23 c8	 and	 r9, rax
  0020a	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  0020e	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  00213	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  00218	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  0021b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0021f	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  00226	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1686 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1687 :                      * always MIN_MATCH bytes ahead.
; 1688 :                      */
; 1689 :                 } while (--s->match_length != 0);

  0022a	ff 8b 88 00 00
	00		 dec	 DWORD PTR [rbx+136]
  00230	75 9e		 jne	 SHORT $LL11@deflate_fa

; 1690 :                 s->strstart++;
; 1691 :             } else

  00232	e9 93 00 00 00	 jmp	 $LN43@deflate_fa
$LN12@deflate_fa:

; 1692 : #endif
; 1693 :             {
; 1694 :                 s->strstart += s->match_length;

  00237	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1695 :                 s->match_length = 0;
; 1696 :                 s->ins_h = s->window[s->strstart];

  0023d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00243	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]

; 1697 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  00247	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0024d	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00253	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  00258	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  0025c	41 d3 e0	 shl	 r8d, cl
  0025f	ff c0		 inc	 eax
  00261	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00265	44 33 c0	 xor	 r8d, eax
  00268	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0026c	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d

; 1698 : #if MIN_MATCH != 3
; 1699 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1700 : #endif
; 1701 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1702 :                  * matter since it will be recomputed at next deflate call.
; 1703 :                  */
; 1704 :             }
; 1705 :         } else {

  00270	eb 5e		 jmp	 SHORT $LN7@deflate_fa
$LN13@deflate_fa:

; 1706 :             /* No match, output a literal byte */
; 1707 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1708 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00272	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00278	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0027c	44 8b d7	 mov	 r10d, edi
  0027f	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00283	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00289	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00290	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00294	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0029a	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  002a1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  002a4	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  002aa	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  002b2	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  002b8	ff c8		 dec	 eax
  002ba	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  002c0	41 0f 94 c2	 sete	 r10b

; 1709 :             s->lookahead--;

  002c4	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
$LN43@deflate_fa:

; 1710 :             s->strstart++;

  002ca	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN7@deflate_fa:

; 1711 :         }
; 1712 :         if (bflush) FLUSH_BLOCK(s, 0);

  002d0	45 85 d2	 test	 r10d, r10d
  002d3	0f 84 59 fd ff
	ff		 je	 $LL20@deflate_fa
  002d9	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002df	85 c0		 test	 eax, eax
  002e1	78 08		 js	 SHORT $LN25@deflate_fa
  002e3	8b d0		 mov	 edx, eax
  002e5	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002e9	eb 03		 jmp	 SHORT $LN26@deflate_fa
$LN25@deflate_fa:
  002eb	48 8b d7	 mov	 rdx, rdi
$LN26@deflate_fa:
  002ee	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002f5	45 33 c9	 xor	 r9d, r9d
  002f8	48 8b cb	 mov	 rcx, rbx
  002fb	44 2b c0	 sub	 r8d, eax
  002fe	e8 00 00 00 00	 call	 _tr_flush_block
  00303	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00309	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0030c	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00312	e8 00 00 00 00	 call	 flush_pending
  00317	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0031a	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0031d	0f 85 0f fd ff
	ff		 jne	 $LL20@deflate_fa
$LN38@deflate_fa:
  00323	33 c0		 xor	 eax, eax
$LN21@deflate_fa:

; 1722 : }

  00325	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0032a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0032f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00334	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00338	41 5f		 pop	 r15
  0033a	41 5e		 pop	 r14
  0033c	5f		 pop	 rdi
  0033d	c3		 ret	 0
$LN37@deflate_fa:

; 1713 :     }
; 1714 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  0033e	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00344	b8 02 00 00 00	 mov	 eax, 2
  00349	3b c8		 cmp	 ecx, eax
  0034b	0f 42 c1	 cmovb	 eax, ecx
  0034e	89 83 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], eax

; 1715 :     if (flush == Z_FINISH) {

  00354	83 fe 04	 cmp	 esi, 4
  00357	75 4b		 jne	 SHORT $LN4@deflate_fa

; 1716 :         FLUSH_BLOCK(s, 1);

  00359	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0035f	85 c0		 test	 eax, eax
  00361	78 08		 js	 SHORT $LN29@deflate_fa
  00363	8b d0		 mov	 edx, eax
  00365	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00369	eb 03		 jmp	 SHORT $LN30@deflate_fa
$LN29@deflate_fa:
  0036b	48 8b d7	 mov	 rdx, rdi
$LN30@deflate_fa:
  0036e	2b c8		 sub	 ecx, eax
  00370	41 b9 01 00 00
	00		 mov	 r9d, 1
  00376	44 8b c1	 mov	 r8d, ecx
  00379	48 8b cb	 mov	 rcx, rbx
  0037c	e8 00 00 00 00	 call	 _tr_flush_block
  00381	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00387	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0038a	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00390	e8 00 00 00 00	 call	 flush_pending
  00395	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00398	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0039b	40 0f 95 c7	 setne	 dil
  0039f	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1717 :         return finish_done;

  003a2	eb 81		 jmp	 SHORT $LN21@deflate_fa
$LN4@deflate_fa:

; 1718 :     }
; 1719 :     if (s->last_lit)

  003a4	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  003aa	74 44		 je	 SHORT $LN1@deflate_fa

; 1720 :         FLUSH_BLOCK(s, 0);

  003ac	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  003b2	85 c0		 test	 eax, eax
  003b4	78 06		 js	 SHORT $LN31@deflate_fa
  003b6	8b f8		 mov	 edi, eax
  003b8	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN31@deflate_fa:
  003bc	2b c8		 sub	 ecx, eax
  003be	45 33 c9	 xor	 r9d, r9d
  003c1	48 8b d7	 mov	 rdx, rdi
  003c4	44 8b c1	 mov	 r8d, ecx
  003c7	48 8b cb	 mov	 rcx, rbx
  003ca	e8 00 00 00 00	 call	 _tr_flush_block
  003cf	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003d5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003d8	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003de	e8 00 00 00 00	 call	 flush_pending
  003e3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003e6	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  003ea	0f 84 33 ff ff
	ff		 je	 $LN38@deflate_fa
$LN1@deflate_fa:

; 1721 :     return block_done;

  003f0	b8 01 00 00 00	 mov	 eax, 1
  003f5	e9 2b ff ff ff	 jmp	 $LN21@deflate_fa
deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflate_slow
_TEXT	SEGMENT
s$ = 80
flush$ = 88
deflate_slow PROC					; COMDAT

; 1733 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00017	33 ff		 xor	 edi, edi
  00019	44 8b f2	 mov	 r14d, edx
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  00025	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:__ImageBase
  0002c	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H
  00032	8d 6f 02	 lea	 ebp, QWORD PTR [rdi+2]
  00035	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL26@deflate_sl:

; 1734 :     IPos hash_head;          /* head of hash chain */
; 1735 :     int bflush;              /* set if current block must be flushed */
; 1736 : 
; 1737 :     /* Process the input block. */
; 1738 :     for (;;) {
; 1739 :         /* Make sure that we always have enough lookahead, except
; 1740 :          * at the end of the input file. We need MAX_MATCH bytes
; 1741 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1742 :          * string following the next match.
; 1743 :          */
; 1744 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00040	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00046	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0004b	73 26		 jae	 SHORT $LN22@deflate_sl

; 1745 :             fill_window(s);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 fill_window

; 1746 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0005b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00060	73 09		 jae	 SHORT $LN23@deflate_sl
  00062	45 85 f6	 test	 r14d, r14d
  00065	0f 84 b1 02 00
	00		 je	 $LN47@deflate_sl
$LN23@deflate_sl:

; 1747 :                 return need_more;
; 1748 :             }
; 1749 :             if (s->lookahead == 0) break; /* flush the current block */

  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 8d 03 00
	00		 je	 $LN45@deflate_sl
$LN22@deflate_sl:

; 1750 :         }
; 1751 : 
; 1752 :         /* Insert the string window[strstart .. strstart+2] in the
; 1753 :          * dictionary, and set hash_head to the head of the hash chain:
; 1754 :          */
; 1755 :         hash_head = NIL;

  00073	44 8b c7	 mov	 r8d, edi

; 1756 :         if (s->lookahead >= MIN_MATCH) {

  00076	83 f8 03	 cmp	 eax, 3
  00079	72 69		 jb	 SHORT $LN21@deflate_sl

; 1757 :             INSERT_STRING(s, s->strstart, hash_head);

  0007b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0007f	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00086	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0008a	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0008e	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00093	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00096	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0009c	d3 e0		 shl	 eax, cl
  0009e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000a2	44 33 c0	 xor	 r8d, eax
  000a5	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000a8	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000ac	4c 23 c8	 and	 r9, rax
  000af	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000b3	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000b8	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000bd	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000c0	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000c6	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  000c9	48 23 c8	 and	 rcx, rax
  000cc	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000d0	44 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+rcx*2]
  000d5	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000d9	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  000e0	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN21@deflate_sl:

; 1758 :         }
; 1759 : 
; 1760 :         /* Find the longest match, discarding those <= prev_length.
; 1761 :          */
; 1762 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  000e4	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  000ea	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [rbx+152]

; 1763 :         s->match_length = MIN_MATCH-1;

  000f0	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp
  000f6	89 8b a0 00 00
	00		 mov	 DWORD PTR [rbx+160], ecx
  000fc	89 83 8c 00 00
	00		 mov	 DWORD PTR [rbx+140], eax

; 1764 : 
; 1765 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1766 :             s->strstart - hash_head <= MAX_DIST(s)) {

  00102	45 85 c0	 test	 r8d, r8d
  00105	74 5a		 je	 SHORT $LN19@deflate_sl
  00107	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  0010d	73 52		 jae	 SHORT $LN19@deflate_sl
  0010f	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00115	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00118	41 2b c8	 sub	 ecx, r8d
  0011b	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00120	3b c8		 cmp	 ecx, eax
  00122	77 3d		 ja	 SHORT $LN19@deflate_sl

; 1767 :             /* To simplify the code, we prevent matches with the string
; 1768 :              * of window index 0 (in particular we have to avoid a match
; 1769 :              * of the string with itself at the start of the input file).
; 1770 :              */
; 1771 :             s->match_length = longest_match (s, hash_head);

  00124	41 8b d0	 mov	 edx, r8d
  00127	48 8b cb	 mov	 rcx, rbx
  0012a	e8 00 00 00 00	 call	 longest_match
  0012f	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax

; 1772 :             /* longest_match() sets match_start */
; 1773 : 
; 1774 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1775 : #if TOO_FAR <= 32767
; 1776 :                 || (s->match_length == MIN_MATCH &&
; 1777 :                     s->strstart - s->match_start > TOO_FAR)
; 1778 : #endif
; 1779 :                 )) {

  00135	83 f8 05	 cmp	 eax, 5
  00138	77 27		 ja	 SHORT $LN19@deflate_sl
  0013a	83 bb b0 00 00
	00 01		 cmp	 DWORD PTR [rbx+176], 1
  00141	74 18		 je	 SHORT $LN18@deflate_sl
  00143	83 f8 03	 cmp	 eax, 3
  00146	75 19		 jne	 SHORT $LN19@deflate_sl
  00148	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0014e	2b 83 98 00 00
	00		 sub	 eax, DWORD PTR [rbx+152]
  00154	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00159	76 06		 jbe	 SHORT $LN19@deflate_sl
$LN18@deflate_sl:

; 1780 : 
; 1781 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1782 :                  * but we will ignore the current match anyway.
; 1783 :                  */
; 1784 :                 s->match_length = MIN_MATCH-1;

  0015b	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp
$LN19@deflate_sl:

; 1785 :             }
; 1786 :         }
; 1787 :         /* If there was a match at the previous step and the current
; 1788 :          * match is not better, output the previous match:
; 1789 :          */
; 1790 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  00161	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [rbx+160]
  00167	83 f8 03	 cmp	 eax, 3
  0016a	0f 82 cb 01 00
	00		 jb	 $LN17@deflate_sl
  00170	39 83 88 00 00
	00		 cmp	 DWORD PTR [rbx+136], eax
  00176	0f 87 bf 01 00
	00		 ja	 $LN17@deflate_sl

; 1791 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0017c	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]

; 1792 :             /* Do not insert strings in hash table beyond this. */
; 1793 : 
; 1794 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1795 : 
; 1796 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1797 :                            s->prev_length - MIN_MATCH, bflush);

  00182	44 0f b7 83 94
	00 00 00	 movzx	 r8d, WORD PTR [rbx+148]
  0018a	44 8b 9b 9c 00
	00 00		 mov	 r11d, DWORD PTR [rbx+156]
  00191	66 44 2b 83 8c
	00 00 00	 sub	 r8w, WORD PTR [rbx+140]
  00199	0f b6 d0	 movzx	 edx, al
  0019c	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  001a3	83 c1 fd	 add	 ecx, -3			; fffffffdH
  001a6	66 41 ff c8	 dec	 r8w
  001aa	80 ea 03	 sub	 dl, 3
  001ad	44 03 d9	 add	 r11d, ecx
  001b0	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001b6	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w
  001bb	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001c1	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001c8	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001cb	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001d1	66 45 03 c4	 add	 r8w, r12w
  001d5	0f b6 c2	 movzx	 eax, dl
  001d8	42 0f b6 84 38
	00 00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+r15]
  001e1	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  001e9	41 0f b7 c0	 movzx	 eax, r8w
  001ed	66 45 3b c5	 cmp	 r8w, r13w
  001f1	73 0b		 jae	 SHORT $LN29@deflate_sl
  001f3	42 0f b6 8c 38
	00 00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+r15]
  001fc	eb 0d		 jmp	 SHORT $LN30@deflate_sl
$LN29@deflate_sl:
  001fe	48 c1 e8 07	 shr	 rax, 7
  00202	42 0f b6 8c 38
	00 01 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+r15+256]
$LN30@deflate_sl:
  0020b	48 63 c1	 movsxd	 rax, ecx
  0020e	8b f7		 mov	 esi, edi
  00210	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]

; 1798 : 
; 1799 :             /* Insert in hash table all strings up to the end of the match.
; 1800 :              * strstart-1 and strstart are already inserted. If there is not
; 1801 :              * enough lookahead, the last two strings are not inserted in
; 1802 :              * the hash table.
; 1803 :              */
; 1804 :             s->lookahead -= s->prev_length-1;

  00218	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+160]
  0021e	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00224	ff c8		 dec	 eax
  00226	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  0022c	b8 01 00 00 00	 mov	 eax, 1
  00231	40 0f 94 c6	 sete	 sil
  00235	2b c1		 sub	 eax, ecx
  00237	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax

; 1805 :             s->prev_length -= 2;

  0023d	8d 41 fe	 lea	 eax, DWORD PTR [rcx-2]
  00240	89 83 a0 00 00
	00		 mov	 DWORD PTR [rbx+160], eax
  00246	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL16@deflate_sl:

; 1806 :             do {
; 1807 :                 if (++s->strstart <= max_insert) {

  00250	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  00256	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]
  0025d	45 3b d3	 cmp	 r10d, r11d
  00260	77 4e		 ja	 SHORT $LN15@deflate_sl

; 1808 :                     INSERT_STRING(s, s->strstart, hash_head);

  00262	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00266	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0026a	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  0026e	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  00272	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  00277	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0027d	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00280	d3 e0		 shl	 eax, cl
  00282	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00286	44 33 c8	 xor	 r9d, eax
  00289	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0028d	4d 23 c2	 and	 r8, r10
  00290	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00294	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00299	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0029e	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  002a1	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  002a5	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  002ac	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN15@deflate_sl:

; 1809 :                 }
; 1810 :             } while (--s->prev_length != 0);

  002b0	ff 8b a0 00 00
	00		 dec	 DWORD PTR [rbx+160]
  002b6	75 98		 jne	 SHORT $LL16@deflate_sl

; 1811 :             s->match_available = 0;
; 1812 :             s->match_length = MIN_MATCH-1;
; 1813 :             s->strstart++;

  002b8	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  002be	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002c5	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
  002cb	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp

; 1814 : 
; 1815 :             if (bflush) FLUSH_BLOCK(s, 0);

  002d1	85 f6		 test	 esi, esi
  002d3	0f 84 67 fd ff
	ff		 je	 $LL26@deflate_sl
  002d9	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002df	85 c0		 test	 eax, eax
  002e1	78 08		 js	 SHORT $LN31@deflate_sl
  002e3	8b d0		 mov	 edx, eax
  002e5	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002e9	eb 03		 jmp	 SHORT $LN32@deflate_sl
$LN31@deflate_sl:
  002eb	48 8b d7	 mov	 rdx, rdi
$LN32@deflate_sl:
  002ee	44 2b c0	 sub	 r8d, eax
  002f1	45 33 c9	 xor	 r9d, r9d
  002f4	48 8b cb	 mov	 rcx, rbx
  002f7	e8 00 00 00 00	 call	 _tr_flush_block
  002fc	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00302	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00305	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0030b	e8 00 00 00 00	 call	 flush_pending
$LN53@deflate_sl:
  00310	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00313	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00316	0f 85 24 fd ff
	ff		 jne	 $LL26@deflate_sl
$LN47@deflate_sl:

; 1829 :             if (s->strm->avail_out == 0) return need_more;

  0031c	33 c0		 xor	 eax, eax
$LN27@deflate_sl:
  0031e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1853 : }

  00323	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00328	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0032d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00331	41 5f		 pop	 r15
  00333	41 5e		 pop	 r14
  00335	41 5d		 pop	 r13
  00337	41 5c		 pop	 r12
  00339	5f		 pop	 rdi
  0033a	c3		 ret	 0
$LN17@deflate_sl:

; 1816 : 
; 1817 :         } else if (s->match_available) {

  0033b	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  00341	0f 84 9e 00 00
	00		 je	 $LN9@deflate_sl

; 1818 :             /* If there was no match at the previous position, output a
; 1819 :              * single literal. If there was a match but the current match
; 1820 :              * is longer, truncate the previous match to a single literal.
; 1821 :              */
; 1822 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1823 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00347	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  0034d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00351	ff c9		 dec	 ecx
  00353	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00357	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0035d	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00364	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00368	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0036e	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00375	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00378	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0037e	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  00386	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  0038c	ff c8		 dec	 eax
  0038e	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1824 :             if (bflush) {

  00394	75 3e		 jne	 SHORT $LN8@deflate_sl

; 1825 :                 FLUSH_BLOCK_ONLY(s, 0);

  00396	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0039c	85 c0		 test	 eax, eax
  0039e	78 08		 js	 SHORT $LN33@deflate_sl
  003a0	8b d0		 mov	 edx, eax
  003a2	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003a6	eb 03		 jmp	 SHORT $LN34@deflate_sl
$LN33@deflate_sl:
  003a8	48 8b d7	 mov	 rdx, rdi
$LN34@deflate_sl:
  003ab	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  003b2	45 33 c9	 xor	 r9d, r9d
  003b5	48 8b cb	 mov	 rcx, rbx
  003b8	44 2b c0	 sub	 r8d, eax
  003bb	e8 00 00 00 00	 call	 _tr_flush_block
  003c0	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003c6	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003c9	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003cf	e8 00 00 00 00	 call	 flush_pending
$LN8@deflate_sl:

; 1826 :             }
; 1827 :             s->strstart++;

  003d4	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1828 :             s->lookahead--;

  003da	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 1830 :         } else {

  003e0	e9 2b ff ff ff	 jmp	 $LN53@deflate_sl
$LN9@deflate_sl:

; 1831 :             /* There is no previous match to compare with, wait for
; 1832 :              * the next step to decide.
; 1833 :              */
; 1834 :             s->match_available = 1;
; 1835 :             s->strstart++;

  003e5	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1836 :             s->lookahead--;

  003eb	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003f1	c7 83 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+144], 1

; 1837 :         }
; 1838 :     }

  003fb	e9 40 fc ff ff	 jmp	 $LL26@deflate_sl
$LN45@deflate_sl:

; 1839 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1840 :     if (s->match_available) {

  00400	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  00406	74 45		 je	 SHORT $LN5@deflate_sl

; 1841 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1842 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00408	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  0040e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00412	ff c9		 dec	 ecx
  00414	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00418	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0041e	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00425	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00429	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0042f	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00436	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00439	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0043f	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 1843 :         s->match_available = 0;

  00447	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
$LN5@deflate_sl:

; 1844 :     }
; 1845 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  0044d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00453	3b c5		 cmp	 eax, ebp
  00455	0f 42 e8	 cmovb	 ebp, eax
  00458	89 ab 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], ebp

; 1846 :     if (flush == Z_FINISH) {

  0045e	41 83 fe 04	 cmp	 r14d, 4
  00462	75 4e		 jne	 SHORT $LN4@deflate_sl

; 1847 :         FLUSH_BLOCK(s, 1);

  00464	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  0046a	85 c9		 test	 ecx, ecx
  0046c	78 08		 js	 SHORT $LN37@deflate_sl
  0046e	8b d1		 mov	 edx, ecx
  00470	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00474	eb 03		 jmp	 SHORT $LN38@deflate_sl
$LN37@deflate_sl:
  00476	48 8b d7	 mov	 rdx, rdi
$LN38@deflate_sl:
  00479	2b c1		 sub	 eax, ecx
  0047b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00481	48 8b cb	 mov	 rcx, rbx
  00484	44 8b c0	 mov	 r8d, eax
  00487	e8 00 00 00 00	 call	 _tr_flush_block
  0048c	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00492	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00495	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0049b	e8 00 00 00 00	 call	 flush_pending
  004a0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004a3	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  004a6	40 0f 95 c7	 setne	 dil
  004aa	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1848 :         return finish_done;

  004ad	e9 6c fe ff ff	 jmp	 $LN27@deflate_sl
$LN4@deflate_sl:

; 1849 :     }
; 1850 :     if (s->last_lit)

  004b2	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  004b8	74 44		 je	 SHORT $LN1@deflate_sl

; 1851 :         FLUSH_BLOCK(s, 0);

  004ba	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  004c0	85 c9		 test	 ecx, ecx
  004c2	78 06		 js	 SHORT $LN39@deflate_sl
  004c4	8b f9		 mov	 edi, ecx
  004c6	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN39@deflate_sl:
  004ca	2b c1		 sub	 eax, ecx
  004cc	45 33 c9	 xor	 r9d, r9d
  004cf	48 8b d7	 mov	 rdx, rdi
  004d2	44 8b c0	 mov	 r8d, eax
  004d5	48 8b cb	 mov	 rcx, rbx
  004d8	e8 00 00 00 00	 call	 _tr_flush_block
  004dd	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  004e3	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  004e6	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  004ec	e8 00 00 00 00	 call	 flush_pending
  004f1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004f4	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  004f8	0f 84 1e fe ff
	ff		 je	 $LN47@deflate_sl
$LN1@deflate_sl:

; 1852 :     return block_done;

  004fe	b8 01 00 00 00	 mov	 eax, 1
  00503	e9 16 fe ff ff	 jmp	 $LN27@deflate_sl
deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflate_rle
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_rle PROC					; COMDAT

; 1864 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	33 ff		 xor	 edi, edi
  0001c	8b f2		 mov	 esi, edx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  00024	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_length_code
  0002b	0f 1f 44 00 00	 npad	 5
$LL20@deflate_rl:

; 1865 :     int bflush;             /* set if current block must be flushed */
; 1866 :     uInt prev;              /* byte at distance one to match */
; 1867 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1868 : 
; 1869 :     for (;;) {
; 1870 :         /* Make sure that we always have enough lookahead, except
; 1871 :          * at the end of the input file. We need MAX_MATCH bytes
; 1872 :          * for the longest run, plus one for the unrolled loop.
; 1873 :          */
; 1874 :         if (s->lookahead <= MAX_MATCH) {

  00030	44 8b 83 9c 00
	00 00		 mov	 r8d, DWORD PTR [rbx+156]
  00037	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  0003e	77 29		 ja	 SHORT $LN16@deflate_rl

; 1875 :             fill_window(s);

  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 fill_window

; 1876 :             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {

  00048	44 8b 83 9c 00
	00 00		 mov	 r8d, DWORD PTR [rbx+156]
  0004f	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  00056	77 08		 ja	 SHORT $LN17@deflate_rl
  00058	85 f6		 test	 esi, esi
  0005a	0f 84 03 02 00
	00		 je	 $LN36@deflate_rl
$LN17@deflate_rl:

; 1877 :                 return need_more;
; 1878 :             }
; 1879 :             if (s->lookahead == 0) break; /* flush the current block */

  00060	45 85 c0	 test	 r8d, r8d
  00063	0f 84 17 02 00
	00		 je	 $LN35@deflate_rl
$LN16@deflate_rl:

; 1880 :         }
; 1881 : 
; 1882 :         /* See how many times the previous byte repeats */
; 1883 :         s->match_length = 0;

  00069	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi

; 1884 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0006f	41 83 f8 03	 cmp	 r8d, 3
  00073	0f 82 be 00 00
	00		 jb	 $LN9@deflate_rl
  00079	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 b0 00 00
	00		 je	 $LN9@deflate_rl

; 1885 :             scan = s->window + s->strstart - 1;

  00087	4c 8b 4b 50	 mov	 r9, QWORD PTR [rbx+80]
  0008b	4c 03 c8	 add	 r9, rax
  0008e	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]

; 1886 :             prev = *scan;

  00092	0f b6 10	 movzx	 edx, BYTE PTR [rax]

; 1887 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  00095	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00099	3b d1		 cmp	 edx, ecx
  0009b	0f 85 96 00 00
	00		 jne	 $LN9@deflate_rl
  000a1	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000a5	3b d1		 cmp	 edx, ecx
  000a7	0f 85 8a 00 00
	00		 jne	 $LN9@deflate_rl
  000ad	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  000b1	48 83 c0 03	 add	 rax, 3
  000b5	3b d1		 cmp	 edx, ecx
  000b7	0f 85 7a 00 00
	00		 jne	 $LN9@deflate_rl

; 1888 :                 strend = s->window + s->strstart + MAX_MATCH;

  000bd	49 81 c1 02 01
	00 00		 add	 r9, 258			; 00000102H
$LL13@deflate_rl:

; 1889 :                 do {
; 1890 :                 } while (prev == *++scan && prev == *++scan &&
; 1891 :                          prev == *++scan && prev == *++scan &&
; 1892 :                          prev == *++scan && prev == *++scan &&
; 1893 :                          prev == *++scan && prev == *++scan &&
; 1894 :                          scan < strend);

  000c4	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000c8	48 ff c0	 inc	 rax
  000cb	3b d1		 cmp	 edx, ecx
  000cd	75 52		 jne	 SHORT $LN10@deflate_rl
  000cf	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000d3	48 ff c0	 inc	 rax
  000d6	3b d1		 cmp	 edx, ecx
  000d8	75 47		 jne	 SHORT $LN10@deflate_rl
  000da	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000de	48 ff c0	 inc	 rax
  000e1	3b d1		 cmp	 edx, ecx
  000e3	75 3c		 jne	 SHORT $LN10@deflate_rl
  000e5	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000e9	48 ff c0	 inc	 rax
  000ec	3b d1		 cmp	 edx, ecx
  000ee	75 31		 jne	 SHORT $LN10@deflate_rl
  000f0	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000f4	48 ff c0	 inc	 rax
  000f7	3b d1		 cmp	 edx, ecx
  000f9	75 26		 jne	 SHORT $LN10@deflate_rl
  000fb	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000ff	48 ff c0	 inc	 rax
  00102	3b d1		 cmp	 edx, ecx
  00104	75 1b		 jne	 SHORT $LN10@deflate_rl
  00106	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0010a	48 ff c0	 inc	 rax
  0010d	3b d1		 cmp	 edx, ecx
  0010f	75 10		 jne	 SHORT $LN10@deflate_rl
  00111	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00115	48 ff c0	 inc	 rax
  00118	3b d1		 cmp	 edx, ecx
  0011a	75 05		 jne	 SHORT $LN10@deflate_rl
  0011c	49 3b c1	 cmp	 rax, r9
  0011f	72 a3		 jb	 SHORT $LL13@deflate_rl
$LN10@deflate_rl:

; 1895 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  00121	41 2b c1	 sub	 eax, r9d
  00124	8d 88 02 01 00
	00		 lea	 ecx, DWORD PTR [rax+258]

; 1896 :                 if (s->match_length > s->lookahead)

  0012a	41 3b c8	 cmp	 ecx, r8d
  0012d	41 0f 47 c8	 cmova	 ecx, r8d
  00131	89 8b 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ecx
$LN9@deflate_rl:

; 1897 :                     s->match_length = s->lookahead;
; 1898 :             }
; 1899 :             Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
; 1900 :         }
; 1901 : 
; 1902 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1903 :         if (s->match_length >= MIN_MATCH) {

  00137	83 bb 88 00 00
	00 03		 cmp	 DWORD PTR [rbx+136], 3
  0013e	72 75		 jb	 SHORT $LN8@deflate_rl

; 1904 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1905 : 
; 1906 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  00140	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00146	0f b6 93 88 00
	00 00		 movzx	 edx, BYTE PTR [rbx+136]
  0014d	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00154	66 89 2c 48	 mov	 WORD PTR [rax+rcx*2], bp
  00158	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0015e	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00165	80 ea 03	 sub	 dl, 3
  00168	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0016b	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00171	0f b6 c2	 movzx	 eax, dl
  00174	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  00179	8b cf		 mov	 ecx, edi
  0017b	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00183	66 ff 83 b0 09
	00 00		 inc	 WORD PTR [rbx+2480]
  0018a	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00190	ff c8		 dec	 eax
  00192	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1907 : 
; 1908 :             s->lookahead -= s->match_length;

  00198	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]

; 1909 :             s->strstart += s->match_length;
; 1910 :             s->match_length = 0;

  0019e	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  001a4	0f 94 c1	 sete	 cl
  001a7	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax
  001ad	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1911 :         } else {

  001b3	eb 5c		 jmp	 SHORT $LN7@deflate_rl
$LN8@deflate_rl:

; 1912 :             /* No match, output a literal byte */
; 1913 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1914 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001b5	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  001bb	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001bf	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001c3	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001c9	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  001d0	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  001d4	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001da	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001e1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001e4	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001ea	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  001f2	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  001f8	8b cf		 mov	 ecx, edi
  001fa	ff c8		 dec	 eax
  001fc	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  00202	0f 94 c1	 sete	 cl

; 1915 :             s->lookahead--;

  00205	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 1916 :             s->strstart++;

  0020b	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN7@deflate_rl:

; 1917 :         }
; 1918 :         if (bflush) FLUSH_BLOCK(s, 0);

  00211	85 c9		 test	 ecx, ecx
  00213	0f 84 17 fe ff
	ff		 je	 $LL20@deflate_rl
  00219	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0021f	85 c0		 test	 eax, eax
  00221	78 08		 js	 SHORT $LN25@deflate_rl
  00223	8b d0		 mov	 edx, eax
  00225	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00229	eb 03		 jmp	 SHORT $LN26@deflate_rl
$LN25@deflate_rl:
  0022b	48 8b d7	 mov	 rdx, rdi
$LN26@deflate_rl:
  0022e	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00235	45 33 c9	 xor	 r9d, r9d
  00238	48 8b cb	 mov	 rcx, rbx
  0023b	44 2b c0	 sub	 r8d, eax
  0023e	e8 00 00 00 00	 call	 _tr_flush_block
  00243	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00249	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0024c	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00252	e8 00 00 00 00	 call	 flush_pending
  00257	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0025a	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0025d	0f 85 cd fd ff
	ff		 jne	 $LL20@deflate_rl
$LN36@deflate_rl:
  00263	33 c0		 xor	 eax, eax
$LN21@deflate_rl:

; 1928 : }

  00265	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0026a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0026f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00274	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00279	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0027d	41 5e		 pop	 r14
  0027f	c3		 ret	 0
$LN35@deflate_rl:

; 1919 :     }
; 1920 :     s->insert = 0;

  00280	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi

; 1921 :     if (flush == Z_FINISH) {

  00286	83 fe 04	 cmp	 esi, 4
  00289	75 4d		 jne	 SHORT $LN4@deflate_rl

; 1922 :         FLUSH_BLOCK(s, 1);

  0028b	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00291	85 c0		 test	 eax, eax
  00293	78 08		 js	 SHORT $LN27@deflate_rl
  00295	8b d0		 mov	 edx, eax
  00297	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0029b	eb 03		 jmp	 SHORT $LN28@deflate_rl
$LN27@deflate_rl:
  0029d	48 8b d7	 mov	 rdx, rdi
$LN28@deflate_rl:
  002a0	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002a7	44 8b cd	 mov	 r9d, ebp
  002aa	48 8b cb	 mov	 rcx, rbx
  002ad	44 2b c0	 sub	 r8d, eax
  002b0	e8 00 00 00 00	 call	 _tr_flush_block
  002b5	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  002bb	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002be	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  002c4	e8 00 00 00 00	 call	 flush_pending
  002c9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002cc	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  002cf	40 0f 95 c7	 setne	 dil
  002d3	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1923 :         return finish_done;

  002d6	eb 8d		 jmp	 SHORT $LN21@deflate_rl
$LN4@deflate_rl:

; 1924 :     }
; 1925 :     if (s->last_lit)

  002d8	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  002de	74 49		 je	 SHORT $LN1@deflate_rl

; 1926 :         FLUSH_BLOCK(s, 0);

  002e0	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002e6	85 c0		 test	 eax, eax
  002e8	78 06		 js	 SHORT $LN29@deflate_rl
  002ea	8b f8		 mov	 edi, eax
  002ec	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN29@deflate_rl:
  002f0	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002f7	45 33 c9	 xor	 r9d, r9d
  002fa	48 8b d7	 mov	 rdx, rdi
  002fd	44 2b c0	 sub	 r8d, eax
  00300	48 8b cb	 mov	 rcx, rbx
  00303	e8 00 00 00 00	 call	 _tr_flush_block
  00308	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0030e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00311	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00317	e8 00 00 00 00	 call	 flush_pending
  0031c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0031f	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00323	0f 84 3a ff ff
	ff		 je	 $LN36@deflate_rl
$LN1@deflate_rl:

; 1927 :     return block_done;

  00329	8b c5		 mov	 eax, ebp
  0032b	e9 35 ff ff ff	 jmp	 $LN21@deflate_rl
deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\workdir\c++source\zlib128\zlib-1.2.8\deflate.c
;	COMDAT deflate_huff
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_huff PROC					; COMDAT

; 1937 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	33 ff		 xor	 edi, edi
$LL11@deflate_hu:

; 1938 :     int bflush;             /* set if current block must be flushed */
; 1939 : 
; 1940 :     for (;;) {
; 1941 :         /* Make sure that we have a literal to write. */
; 1942 :         if (s->lookahead == 0) {

  00016	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0001c	75 14		 jne	 SHORT $LN8@deflate_hu

; 1943 :             fill_window(s);

  0001e	48 8b cb	 mov	 rcx, rbx
  00021	e8 00 00 00 00	 call	 fill_window

; 1944 :             if (s->lookahead == 0) {

  00026	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0002c	0f 84 bf 00 00
	00		 je	 $LN22@deflate_hu
$LN8@deflate_hu:

; 1946 :                     return need_more;
; 1947 :                 break;      /* flush the current block */
; 1948 :             }
; 1949 :         }
; 1950 : 
; 1951 :         /* Output a literal byte */
; 1952 :         s->match_length = 0;
; 1953 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1954 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00032	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00038	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0003c	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00042	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00046	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0004c	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00053	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00057	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0005d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00064	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00067	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0006d	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 1955 :         s->lookahead--;
; 1956 :         s->strstart++;

  00075	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  0007b	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00081	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  00087	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0008e	ff c8		 dec	 eax
  00090	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1957 :         if (bflush) FLUSH_BLOCK(s, 0);

  00096	0f 85 7a ff ff
	ff		 jne	 $LL11@deflate_hu
  0009c	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  000a2	85 c0		 test	 eax, eax
  000a4	78 08		 js	 SHORT $LN14@deflate_hu
  000a6	8b d0		 mov	 edx, eax
  000a8	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000ac	eb 03		 jmp	 SHORT $LN15@deflate_hu
$LN14@deflate_hu:
  000ae	48 8b d7	 mov	 rdx, rdi
$LN15@deflate_hu:
  000b1	44 2b c0	 sub	 r8d, eax
  000b4	45 33 c9	 xor	 r9d, r9d
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 _tr_flush_block
  000bf	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000c5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c8	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  000ce	e8 00 00 00 00	 call	 flush_pending
  000d3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d6	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  000d9	0f 85 37 ff ff
	ff		 jne	 $LL11@deflate_hu
$LN23@deflate_hu:
  000df	33 c0		 xor	 eax, eax

; 1966 :     return block_done;
; 1967 : }

  000e1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
$LN22@deflate_hu:

; 1945 :                 if (flush == Z_NO_FLUSH)

  000f1	85 f6		 test	 esi, esi
  000f3	74 ea		 je	 SHORT $LN23@deflate_hu

; 1958 :     }
; 1959 :     s->insert = 0;

  000f5	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi

; 1960 :     if (flush == Z_FINISH) {

  000fb	83 fe 04	 cmp	 esi, 4
  000fe	75 5e		 jne	 SHORT $LN4@deflate_hu

; 1961 :         FLUSH_BLOCK(s, 1);

  00100	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00106	85 c0		 test	 eax, eax
  00108	78 08		 js	 SHORT $LN16@deflate_hu
  0010a	8b d0		 mov	 edx, eax
  0010c	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00110	eb 03		 jmp	 SHORT $LN17@deflate_hu
$LN16@deflate_hu:
  00112	48 8b d7	 mov	 rdx, rdi
$LN17@deflate_hu:
  00115	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0011c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00122	48 8b cb	 mov	 rcx, rbx
  00125	44 2b c0	 sub	 r8d, eax
  00128	e8 00 00 00 00	 call	 _tr_flush_block
  0012d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00133	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00136	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0013c	e8 00 00 00 00	 call	 flush_pending
  00141	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00144	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00147	40 0f 95 c7	 setne	 dil
  0014b	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1966 :     return block_done;
; 1967 : }

  0014e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00153	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00158	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
$LN4@deflate_hu:

; 1962 :         return finish_done;
; 1963 :     }
; 1964 :     if (s->last_lit)

  0015e	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  00164	74 49		 je	 SHORT $LN1@deflate_hu

; 1965 :         FLUSH_BLOCK(s, 0);

  00166	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0016c	85 c0		 test	 eax, eax
  0016e	78 06		 js	 SHORT $LN18@deflate_hu
  00170	8b f8		 mov	 edi, eax
  00172	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN18@deflate_hu:
  00176	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0017d	45 33 c9	 xor	 r9d, r9d
  00180	48 8b d7	 mov	 rdx, rdi
  00183	44 2b c0	 sub	 r8d, eax
  00186	48 8b cb	 mov	 rcx, rbx
  00189	e8 00 00 00 00	 call	 _tr_flush_block
  0018e	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00194	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00197	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0019d	e8 00 00 00 00	 call	 flush_pending
  001a2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001a5	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001a9	0f 84 30 ff ff
	ff		 je	 $LN23@deflate_hu
$LN1@deflate_hu:

; 1966 :     return block_done;
; 1967 : }

  001af	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001b4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001b9	b8 01 00 00 00	 mov	 eax, 1
  001be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c2	5f		 pop	 rdi
  001c3	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
END
